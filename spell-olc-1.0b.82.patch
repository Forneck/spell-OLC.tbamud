diff -uN ./orig/act.wizard.c ./act.wizard.c
--- ./orig/act.wizard.c	2020-02-25 19:18:51.514369528 -0500
+++ ./act.wizard.c	2020-02-25 19:28:26.872945351 -0500
@@ -34,6 +34,7 @@
 #include "quest.h"
 #include "ban.h"
 #include "screen.h"
+#include "spedit.h"
 
 /* local utility functions with file scope */
 static int perform_set(struct char_data *ch, struct char_data *vict, int mode, char *val_arg);
@@ -673,15 +674,15 @@
       send_to_char(ch, "Hours left: [%d]\r\n", GET_OBJ_VAL(j, 2));
     break;
   case ITEM_SCROLL:
-  case ITEM_POTION:
+  case ITEM_POTION: 
     send_to_char(ch, "Spells: (Level %d) %s, %s, %s\r\n", GET_OBJ_VAL(j, 0),
-	    skill_name(GET_OBJ_VAL(j, 1)), skill_name(GET_OBJ_VAL(j, 2)),
-	    skill_name(GET_OBJ_VAL(j, 3)));
+	    get_spell_name(GET_OBJ_VAL(j, 1)), get_spell_name(GET_OBJ_VAL(j, 2)),
+	    get_spell_name(GET_OBJ_VAL(j, 3)));
     break;
   case ITEM_WAND:
   case ITEM_STAFF:
     send_to_char(ch, "Spell: %s at level %d, %d (of %d) charges remaining\r\n",
-	    skill_name(GET_OBJ_VAL(j, 3)), GET_OBJ_VAL(j, 0),
+	    get_spell_name(GET_OBJ_VAL(j, 3)), GET_OBJ_VAL(j, 0),
 	    GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 1));
     break;
   case ITEM_WEAPON:
@@ -914,10 +915,14 @@
   /* Routine to show what spells a char is affected by */
   if (k->affected) {
     for (aff = k->affected; aff; aff = aff->next) {
-      send_to_char(ch, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1, CCCYN(ch, C_NRM), skill_name(aff->spell), CCNRM(ch, C_NRM));
+      send_to_char(ch, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1, CCCYN(ch, C_NRM), get_spell_name(aff->spell), CCNRM(ch, C_NRM));
 
-      if (aff->modifier)
-	send_to_char(ch, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
+      if (aff->modifier) {
+        if (!IS_SET_AR(AFF_FLAGS(k), AFF_PROTECT))
+	  send_to_char(ch, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
+        else
+          send_to_char(ch, "%%%d resist spell (%d): '%s'", aff->modifier, aff->location, get_spell_name(aff->location));
+      }
 
       if (aff->bitvector[0] || aff->bitvector[1] || aff->bitvector[2] || aff->bitvector[3]) {
         if (aff->modifier)
diff -uN ./orig/class.c ./class.c
--- ./orig/class.c	2020-02-25 19:18:51.514369528 -0500
+++ ./class.c	2020-02-25 19:19:09.937725785 -0500
@@ -1554,88 +1554,6 @@
   return FALSE;
 }
 
-/* SPELLS AND SKILLS.  This area defines which spells are assigned to which
- * classes, and the minimum level the character must be to use the spell or
- * skill. */
-void init_spell_levels(void)
-{
-  /* MAGES */
-  spell_level(SPELL_MAGIC_MISSILE, CLASS_MAGIC_USER, 1);
-  spell_level(SPELL_DETECT_INVIS, CLASS_MAGIC_USER, 2);
-  spell_level(SPELL_DETECT_MAGIC, CLASS_MAGIC_USER, 2);
-  spell_level(SPELL_CHILL_TOUCH, CLASS_MAGIC_USER, 3);
-  spell_level(SPELL_INFRAVISION, CLASS_MAGIC_USER, 3);
-  spell_level(SPELL_INVISIBLE, CLASS_MAGIC_USER, 4);
-  spell_level(SPELL_ARMOR, CLASS_MAGIC_USER, 4);
-  spell_level(SPELL_BURNING_HANDS, CLASS_MAGIC_USER, 5);
-  spell_level(SPELL_LOCATE_OBJECT, CLASS_MAGIC_USER, 6);
-  spell_level(SPELL_STRENGTH, CLASS_MAGIC_USER, 6);
-  spell_level(SPELL_SHOCKING_GRASP, CLASS_MAGIC_USER, 7);
-  spell_level(SPELL_SLEEP, CLASS_MAGIC_USER, 8);
-  spell_level(SPELL_LIGHTNING_BOLT, CLASS_MAGIC_USER, 9);
-  spell_level(SPELL_BLINDNESS, CLASS_MAGIC_USER, 9);
-  spell_level(SPELL_DETECT_POISON, CLASS_MAGIC_USER, 10);
-  spell_level(SPELL_COLOR_SPRAY, CLASS_MAGIC_USER, 11);
-  spell_level(SPELL_ENERGY_DRAIN, CLASS_MAGIC_USER, 13);
-  spell_level(SPELL_CURSE, CLASS_MAGIC_USER, 14);
-  spell_level(SPELL_POISON, CLASS_MAGIC_USER, 14);
-  spell_level(SPELL_FIREBALL, CLASS_MAGIC_USER, 15);
-  spell_level(SPELL_CHARM, CLASS_MAGIC_USER, 16);
-  spell_level(SPELL_IDENTIFY, CLASS_MAGIC_USER, 20);
-  spell_level(SPELL_FLY, CLASS_MAGIC_USER, 22);
-  spell_level(SPELL_ENCHANT_WEAPON, CLASS_MAGIC_USER, 26);
-  spell_level(SPELL_CLONE, CLASS_MAGIC_USER, 30);
-
-  /* CLERICS */
-  spell_level(SPELL_CURE_LIGHT, CLASS_CLERIC, 1);
-  spell_level(SPELL_ARMOR, CLASS_CLERIC, 1);
-  spell_level(SPELL_CREATE_FOOD, CLASS_CLERIC, 2);
-  spell_level(SPELL_CREATE_WATER, CLASS_CLERIC, 2);
-  spell_level(SPELL_DETECT_POISON, CLASS_CLERIC, 3);
-  spell_level(SPELL_DETECT_ALIGN, CLASS_CLERIC, 4);
-  spell_level(SPELL_CURE_BLIND, CLASS_CLERIC, 4);
-  spell_level(SPELL_BLESS, CLASS_CLERIC, 5);
-  spell_level(SPELL_DETECT_INVIS, CLASS_CLERIC, 6);
-  spell_level(SPELL_BLINDNESS, CLASS_CLERIC, 6);
-  spell_level(SPELL_INFRAVISION, CLASS_CLERIC, 7);
-  spell_level(SPELL_PROT_FROM_EVIL, CLASS_CLERIC, 8);
-  spell_level(SPELL_POISON, CLASS_CLERIC, 8);
-  spell_level(SPELL_GROUP_ARMOR, CLASS_CLERIC, 9);
-  spell_level(SPELL_CURE_CRITIC, CLASS_CLERIC, 9);
-  spell_level(SPELL_SUMMON, CLASS_CLERIC, 10);
-  spell_level(SPELL_REMOVE_POISON, CLASS_CLERIC, 10);
-  spell_level(SPELL_IDENTIFY, CLASS_CLERIC, 11);
-  spell_level(SPELL_WORD_OF_RECALL, CLASS_CLERIC, 12);
-  spell_level(SPELL_DARKNESS, CLASS_CLERIC, 12);
-  spell_level(SPELL_EARTHQUAKE, CLASS_CLERIC, 12);
-  spell_level(SPELL_DISPEL_EVIL, CLASS_CLERIC, 14);
-  spell_level(SPELL_DISPEL_GOOD, CLASS_CLERIC, 14);
-  spell_level(SPELL_SANCTUARY, CLASS_CLERIC, 15);
-  spell_level(SPELL_CALL_LIGHTNING, CLASS_CLERIC, 15);
-  spell_level(SPELL_HEAL, CLASS_CLERIC, 16);
-  spell_level(SPELL_CONTROL_WEATHER, CLASS_CLERIC, 17);
-  spell_level(SPELL_SENSE_LIFE, CLASS_CLERIC, 18);
-  spell_level(SPELL_HARM, CLASS_CLERIC, 19);
-  spell_level(SPELL_GROUP_HEAL, CLASS_CLERIC, 22);
-  spell_level(SPELL_REMOVE_CURSE, CLASS_CLERIC, 26);
-
-  /* THIEVES */
-  spell_level(SKILL_SNEAK, CLASS_THIEF, 1);
-  spell_level(SKILL_PICK_LOCK, CLASS_THIEF, 2);
-  spell_level(SKILL_BACKSTAB, CLASS_THIEF, 3);
-  spell_level(SKILL_STEAL, CLASS_THIEF, 4);
-  spell_level(SKILL_HIDE, CLASS_THIEF, 5);
-  spell_level(SKILL_TRACK, CLASS_THIEF, 6);
-
-  /* WARRIORS */
-  spell_level(SKILL_KICK, CLASS_WARRIOR, 1);
-  spell_level(SKILL_RESCUE, CLASS_WARRIOR, 3);
-  spell_level(SKILL_BANDAGE, CLASS_WARRIOR, 7);
-  spell_level(SKILL_TRACK, CLASS_WARRIOR, 9);
-  spell_level(SKILL_BASH, CLASS_WARRIOR, 12);
-  spell_level(SKILL_WHIRLWIND, CLASS_WARRIOR, 16);
-}
-
 /* This is the exp given to implementors -- it must always be greater than the
  * exp required for immortality, plus at least 20,000 or so. */
 #define EXP_MAX  10000000
diff -uN ./orig/comm.c ./comm.c
--- ./orig/comm.c	2020-02-25 19:18:51.514369528 -0500
+++ ./comm.c	2020-02-25 19:19:09.937725785 -0500
@@ -2135,6 +2135,7 @@
     case CON_HEDIT:
     case CON_QEDIT:
     case CON_MSGEDIT:
+    case CON_SPEDIT:
       cleanup_olc(d, CLEANUP_ALL);
       break;
     default:
@@ -2507,6 +2508,11 @@
       case 'n':
 	i = PERS(ch, to);
 	break;
+      case 'b': // act like 'p' if obj exists, otherwise act like 'N'. 
+        if (obj) {
+          CHECK_NULL(obj, OBJS(obj, to));
+          break;
+        }
       case 'N':
 	CHECK_NULL(vict_obj, PERS((const struct char_data *) vict_obj, to));
 	dg_victim = (struct char_data *) vict_obj;
diff -uN ./orig/constants.c ./constants.c
--- ./orig/constants.c	2020-02-25 19:18:51.514369528 -0500
+++ ./constants.c	2020-02-25 19:19:09.937725785 -0500
@@ -284,6 +284,7 @@
   "HIDE",
   "UNUSED",
   "CHARM",
+  "PROT-SPELL",
   "\n"
 };
 
@@ -953,6 +954,48 @@
   "InProgress",
   "\n"
 };
+
+
+/* spells flags used by spedit OLC */
+const char *targ_flags[] =
+{
+ "IGNORE",
+ "CHAR_ROOM",
+ "CHAR_WORLD",
+ "FIGHT_SELF",
+ "FIGHT_VICT",
+ "SELF_ONLY",
+ "NOT_SELF",
+ "OBJ_INV",
+ "OBJ_ROOM",
+ "OBJ_WORLD",
+ "OBJ_EQUIP",
+ "GROUP",
+ "GROUP_VICT"
+};
+
+
+/* Magic aff flags used by spedit OLC system */
+const char *mag_flags[] = 
+{
+"DAMAGE",
+"AFFECTS",
+"UNAFFECTS",
+"POINTS",
+"ALTER_OBJS",
+"GROUPS",
+"MASSES",
+"AREAS",
+"SUMMONS",
+"CREATIONS",
+"MANUAL",
+"ROOMS",
+"VIOLENT",
+"ACCDUR",
+"ACCMOD",
+"PROTECTION"
+};
+
 /* --- End of constants arrays. --- */
 
 /* Various arrays we count so we can check the world files.  These
diff -uN ./orig/constants.h ./constants.h
--- ./orig/constants.h	2020-02-25 19:18:51.518369387 -0500
+++ ./constants.h	2020-02-25 19:19:09.937725785 -0500
@@ -39,6 +39,8 @@
 extern const char *fullness[];
 extern const char *weekdays[];
 extern const char *month_name[];
+extern const char *mag_flags[];
+extern const char *targ_flags[];
 extern const struct str_app_type str_app[];
 extern const struct dex_skill_type dex_app_skill[];
 extern const struct dex_app_type dex_app[];
diff -uN ./orig/db.c ./db.c
--- ./orig/db.c	2020-02-25 19:18:51.518369387 -0500
+++ ./db.c	2020-02-25 19:19:09.937725785 -0500
@@ -38,8 +38,14 @@
 #include "mud_event.h"
 #include "msgedit.h"
 #include "screen.h"
+#include "spedit.h"
 #include <sys/stat.h>
 
+extern void spedit_free_memory();
+extern void create_spells_db();
+extern void set_spells_function();
+extern int boot_spells();
+
 /*  declarations of most of the 'global' variables */
 struct config_data config_info; /* Game configuration list.	 */
 
@@ -454,6 +460,12 @@
   log("Loading rooms.");
   index_boot(DB_BOOT_WLD);
 
+  log("Loading spells.");
+  if (boot_spells())
+    set_spells_function();
+  else
+    create_spells_db();
+
   log("Renumbering rooms.");
   renum_world();
 
@@ -672,6 +684,8 @@
   /* Events */
   event_free_all();
 
+  /* Spells */
+  spedit_free_memory();
 }
 
 /* body of the booting system */
@@ -707,9 +721,6 @@
   if (file_to_string_alloc(GREETINGS_FILE, &GREETINGS) == 0)
     prune_crlf(GREETINGS);
 
-  log("Loading spell definitions.");
-  mag_assign_spells();
-
   boot_world();
 
   log("Loading help entries.");
@@ -747,12 +758,8 @@
     assign_the_quests();
   }
 
-  log("Assigning spell and skill levels.");
-  init_spell_levels();
-
-  log("Sorting command list and spells.");
+  log("Sorting command list.");
   sort_commands();
-  sort_spells();
 
   log("Booting mail system.");
   if (!scan_file()) {
@@ -3768,34 +3775,45 @@
 
 static int check_object_spell_number(struct obj_data *obj, int val)
 {
-  int error = FALSE;
+  int error = FALSE, spellnum;
   const char *spellname;
+  struct str_spells *spell;
 
-  if (GET_OBJ_VAL(obj, val) == -1 || GET_OBJ_VAL(obj, val) == 0) /* no spell */
+  spellnum = GET_OBJ_VAL(obj, val);
+  if ((spellnum == -1) || (spellnum == 0)) /* no spell */
     return (error);
 
-  /* Check for negative spells, spells beyond the top define, and any spell
-   * which is actually a skill. */
-  if (GET_OBJ_VAL(obj, val) < 0)
-    error = TRUE;
-  if (GET_OBJ_VAL(obj, val) > TOP_SPELL_DEFINE)
-    error = TRUE;
-  if (GET_OBJ_VAL(obj, val) > MAX_SPELLS && GET_OBJ_VAL(obj, val) <= MAX_SKILLS)
-    error = TRUE;
-  if (error)
+  /* Check for negative spells, spells beyond the top define. */
+  if ((spellnum < 0) || (spellnum > TOP_SPELL_DEFINE)) {
     log("SYSERR: Object #%d (%s) has out of range spell #%d.",
-	GET_OBJ_VNUM(obj), obj->short_description, GET_OBJ_VAL(obj, val));
-
-  if (scheck)		/* Spell names don't exist in syntax check mode. */
-    return (error);
+	GET_OBJ_VNUM(obj), obj->short_description, spellnum);
+    error = TRUE;
+  }
 
-  /* Now check for unnamed spells. */
-  spellname = skill_name(GET_OBJ_VAL(obj, val));
+  spell = get_spell_by_vnum(spellnum);
+  if (!spell) {
+    log("SYSERR: Object #%d (%s) has non-existent spell #%d.",
+	GET_OBJ_VNUM(obj), obj->short_description, spellnum);
+    error = TRUE;
+  } else {
+      spellname = skill_name(spellnum);
 
-  if ((spellname == unused_spellname || !str_cmp("UNDEFINED", spellname)) && (error = TRUE))
-    log("SYSERR: Object #%d (%s) uses '%s' spell #%d.",
+      /* Check spell availability */
+      if (spell->status == unavailable) {
+        log("SYSERR: Object #%d (%s) uses disabled '%s' spell #%d.",
 		GET_OBJ_VNUM(obj), obj->short_description, spellname,
-		GET_OBJ_VAL(obj, val));
+		spellnum);
+        error = TRUE;
+      } else // no needs to check for "Undefined" named, if it's disabled.
+
+      /* Now check for unnamed spells. */
+      if (!str_cmp("Undefined", spellname)) {
+        log("SYSERR: Object #%d (%s) uses '%s' spell #%d.",
+		GET_OBJ_VNUM(obj), obj->short_description, spellname,
+		spellnum);
+        error = TRUE;
+      }
+     }
 
   return (error);
 }
diff -uN ./orig/db.h ./db.h
--- ./orig/db.h	2020-02-25 19:18:51.518369387 -0500
+++ ./db.h	2020-02-25 19:19:09.937725785 -0500
@@ -46,7 +46,7 @@
 #define LIB_PLROBJS	"plrobjs/"
 #define LIB_PLRVARS	"plrvars/"
 #define LIB_HOUSE	"house/"
-#define LIB_PLRFILES    "plrfiles/"
+#define LIB_PLRFILES	"plrfiles/"
 #define SLASH		"/"
 #else
 #error "Unknown path components."
@@ -56,6 +56,7 @@
 #define SUF_TEXT	"text"
 #define SUF_MEM	        "mem"
 #define SUF_PLR		"plr"
+#define SUF_PLRSPELLS   "spells"
 
 #if defined(CIRCLE_AMIGA)
 #define EXE_FILE "/bin/circle" /* maybe use argv[0] but it's not reliable */
@@ -107,6 +108,7 @@
 #define SOCMESS_FILE	LIB_MISC"socials"  /* messages for social acts	*/
 #define SOCMESS_FILE_NEW LIB_MISC"socials.new"  /* messages for social acts with aedit patch*/
 #define XNAME_FILE	LIB_MISC"xnames"   /* invalid name substrings	*/
+#define SPELL_FILE	LIB_MISC"spells"   /* stored spells file 	*/
 
 /* BEGIN: Assumed default locations for logfiles, mainly used in do_file. */
 /**/
diff -uN ./orig/dg_misc.c ./dg_misc.c
--- ./orig/dg_misc.c	2020-02-25 19:18:51.518369387 -0500
+++ ./dg_misc.c	2020-02-25 19:19:09.941725647 -0500
@@ -21,6 +21,7 @@
 #include "spells.h"
 #include "constants.h"
 #include "fight.h"
+#include "spedit.h"
 
 
 /* copied from spell_parser.c: */
@@ -39,6 +40,7 @@
   struct char_data *tch = NULL;
   struct obj_data *tobj = NULL;
   struct room_data *caster_room = NULL;
+  struct str_spells *spell;
   char *s, *t;
   int spellnum, target = 0;
   char buf2[MAX_STRING_LENGTH], orig_cmd[MAX_INPUT_LENGTH];
@@ -80,31 +82,32 @@
   t = strtok(NULL, "\0");
 
   /* spellnum = search_block(s, spells, 0); */
-  spellnum = find_skill_num(s);
-  if ((spellnum < 1) || (spellnum > MAX_SPELLS)) {
+  spell = get_spell_by_name(s, SPSK);
+  if (!spell) {
     script_log("Trigger: %s, VNum %d. dg_cast: invalid spell name (%s)",
       GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), orig_cmd);
     return;
-  }
+  } else
+      spellnum = spell->vnum;
 
   /* Find the target */
   if (t != NULL) {
     one_argument(strcpy(buf2, t), t);
     skip_spaces(&t);
   }
-  if (!IS_SET(SINFO.targets, TAR_IGNORE) && t != NULL && *t) {
+  if (!IS_SET(spell->targ_flags, TAR_IGNORE) && t != NULL && *t) {
     if (!target &&
-          (IS_SET(SINFO.targets, TAR_CHAR_ROOM) ||
-           IS_SET(SINFO.targets, TAR_CHAR_WORLD))) {
+          (IS_SET(spell->targ_flags, TAR_CHAR_ROOM) ||
+           IS_SET(spell->targ_flags, TAR_CHAR_WORLD))) {
       if ((tch = get_char(t)) != NULL)
         target = TRUE;
     }
 
     if (!target &&
-          (IS_SET(SINFO.targets, TAR_OBJ_INV) ||
-           IS_SET(SINFO.targets, TAR_OBJ_EQUIP) ||
-           IS_SET(SINFO.targets, TAR_OBJ_ROOM) ||
-           IS_SET(SINFO.targets, TAR_OBJ_WORLD))) {
+          (IS_SET(spell->targ_flags, TAR_OBJ_INV) ||
+           IS_SET(spell->targ_flags, TAR_OBJ_EQUIP) ||
+           IS_SET(spell->targ_flags, TAR_OBJ_ROOM) ||
+           IS_SET(spell->targ_flags, TAR_OBJ_WORLD))) {
       if ((tobj = get_obj(t)) != NULL)
         target = TRUE;
     }
@@ -116,7 +119,7 @@
     }
   }
 
-  if (IS_SET(SINFO.routines, MAG_GROUPS)) {
+  if (IS_SET(spell->mag_flags, MAG_GROUPS)) {
     script_log("Trigger: %s, VNum %d. dg_cast: group spells not permitted (%s)",
       GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), orig_cmd);
     return;
diff -uN ./orig/dg_variables.c ./dg_variables.c
--- ./orig/dg_variables.c	2020-02-25 19:18:51.518369387 -0500
+++ ./dg_variables.c	2020-02-25 19:19:09.941725647 -0500
@@ -26,6 +26,7 @@
 #include "quest.h"
 #include "act.h"
 #include "genobj.h"
+#include "spedit.h"
 
 /* Utility functions */
 
@@ -67,13 +68,14 @@
 /* perhaps not the best place for this, but I didn't want a new file */
 char *skill_percent(struct char_data *ch, char *skill)
 {
+  struct str_spells *spell;
   static char retval[16];
-  int skillnum;
 
-  skillnum = find_skill_num(skill);
-  if (skillnum<=0) return("unknown skill");
+  spell = get_spell_by_name(skill, SPSK);
+  if (!spell)
+    return("unknown skill");
 
-  snprintf(retval, sizeof(retval), "%d", GET_SKILL(ch, skillnum));
+  snprintf(retval, sizeof(retval), "%d", GET_SKILL(ch, spell->vnum));
   return retval;
 }
 
@@ -600,8 +602,8 @@
         case 'a':
           if (!str_cmp(field, "affect")) {
             if (subfield && *subfield) {
-              int spell = find_skill_num(subfield);
-              if (affected_by_spell(c, spell))
+              struct str_spells *spell = get_spell_by_name(subfield, SPSK);
+              if (spell && affected_by_spell(c, spell->vnum))
                 strcpy(str, "1");
               else
                 strcpy(str, "0");
@@ -1045,10 +1047,10 @@
               amount = one_word(subfield, skillname);
               skip_spaces(&amount);
               if (amount && *amount && is_number(amount)) {
-                int skillnum = find_skill_num(skillname);
-                if (skillnum > 0) {
+                struct str_spells *spell = get_spell_by_name(skillname, SPSK);
+                if (spell) {
                   int new_value = MAX(0, MIN(100, atoi(amount)));
-                  SET_SKILL(c, skillnum, new_value);
+                  SET_SKILL(c, spell->vnum, new_value);
                 }
               }
             }
diff -uN ./orig/formula.c ./formula.c
--- ./orig/formula.c	1969-12-31 19:00:00.000000000 -0500
+++ ./formula.c	2020-02-25 19:19:09.941725647 -0500
@@ -0,0 +1,737 @@
+/* *************************************************************************** */
+/* code:    formula.c                                                          */
+/* desc:    perform mathematics formula and return a value or an error message.*/
+/*          (using operators, variables, conditional ? :, and logical)         */
+/* author:  Bob Castillo (castillo7@hotmail.com)                               */
+/* version: 0.5b      (for circle MUD 3.x with Oasis OLC)                      */
+/* date:    25 dec 1999.                                                       */
+/*          2020: updated, bugs fix, etc. now for TBA MUD 2020.                */
+/* *************************************************************************** */
+/* Copyright (c) 1999 castillo7@hotmail.com
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE. */
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "comm.h"
+#include "utils.h"
+#include "spells.h"
+#include "oasis.h"
+#include "spedit.h"
+#include "db.h"
+#include "formula.h"
+#include "string.h"
+
+//#define DEBUG_FORMULA
+
+const char *list_codes[] = {
+   " ",             /* 00 */
+   "&&",            /* 01 (a) */
+   "||",            /* 02 (b) */
+   ">=",            /* 03 (c) */
+   ">",             /* 04 (d) */
+   "<=",            /* 05 (e) */
+   "<",             /* 06 (f) */
+   "==",            /* 07 (g) */
+   "!=",            /* 08 (h) */
+   "!",             /* 09 (i) */
+   "^",             /* 10 (j) */
+   "&",             /* 11 (k) */
+   "|",             /* 12 (l) */
+   "-",             /* 13 (m) */
+   "+",             /* 14 (n) */
+   "/",             /* 15 (o) */
+   "*",             /* 16 (p) */
+   "(",             /* 17 (q) */
+   ")",             /* 18 (r) */
+   "?",             /* 19 (s) */
+   ":",             /* 20 (t) */
+   "RAND(",         /* 21 (u) */
+   "SELF.",         /* 22 (v) */
+   "VICT.",         /* 23 (w) */
+   "%",             /* 24 (x) */
+                    /*    (y) (reserved for digit) */
+   "STR",           /* 25 (z) */
+   "DEX",           /* 26 (z) */
+   "INT",           /* 27 (z) */
+   "WIS",           /* 28 (z) */
+   "CON",           /* 29 (z) */
+   "CHA",           /* 30 (z) */
+   "CLASS",         /* 31 (z) */
+   "LEVEL",         /* 32 (z) */
+   "AGE",           /* 33 (z) */
+   "WEIGHT",        /* 34 (z) */
+   "HEIGHT",        /* 35 (z) */
+   "MAXMANA",       /* 36 (z) */
+   "MAXHIT",        /* 37 (z) */
+   "MAXMOVE",       /* 38 (z) */
+   "GOLD",          /* 39 (z) */
+   "EXP",           /* 40 (z) */
+   "ARMOR",         /* 41 (z) */
+   "HITROLL",       /* 42 (z) */
+   "DAMROLL",       /* 43 (z) */
+   "SAVPARA",       /* 44 (z) */
+   "SAVROD",        /* 45 (z) */
+   "SAVPETRI",      /* 46 (z) */
+   "SAVBREATH",     /* 47 (z) */
+   "SAVSPELL",      /* 48 (z) */
+   "HIT",           /* 49 (z) */
+   "MANA",          /* 50 (z) */
+   "MOVE",          /* 51 (z) */
+   "GOOD",          /* 52 (z) */
+   "NEUTRAL",       /* 53 (z) */
+   "EVIL",          /* 54 (z) */
+   "DICE(",         /* 55 (A) */
+   ",",             /* 56 (B) */
+   "PARAM",         /* 57 (C) */
+   "\n"
+};
+
+void add_to_formula (struct formula **head_formula, int command, int value)
+{
+ struct formula *Q, *ptr, *prev = NULL;
+
+ CREATE (Q, struct formula, 1);
+ for (ptr = *head_formula; ptr; prev = ptr, ptr = ptr->next);
+ if (prev == NULL) 
+   *head_formula = Q;
+ else
+   prev->next = Q;
+ Q->prev = prev;
+ Q->next = NULL;
+
+ Q->command = command;
+ Q->value = value;
+ Q->sign = 1;
+ Q->next = NULL;
+}
+
+void free_formula (struct formula **head_formula) 
+{
+ struct formula *q = *head_formula, *n = NULL;
+
+ while (q) {
+   n = q->next;
+  free (q);
+  q = n;
+ }
+
+ *head_formula = NULL;
+}
+
+int get_formula_typeact (char *str, int *ptr) 
+{
+ int cpt = 0;
+
+ if (str[*ptr] == ' ')
+   return CODE_SPACE;
+ else
+   if ((str[*ptr] >= '0') && (str[*ptr] <= '9'))
+     return CODE_DIGIT;
+ while (list_codes[++cpt][0] != '\n') 
+   if (!strncmp(list_codes[cpt], (char *) &str[*ptr], strlen(list_codes[cpt]))) {
+     *ptr += strlen(list_codes[cpt]) - 1;
+     return cpt;      
+   }
+ return -1;
+}
+
+int check_formula_syntax (int otype_act, int type_act) 
+{
+ // CHAR_TYPE[0][] can't follow [1][]
+ const char *test [4][2] = {
+ {"abcdefghjklmnopqstuxA",  "abcdefghjkloprstxzB"},        // can follow: imnquvwy  
+                                                           //     !,-,+,(,rand(,self.,vict.,digit
+ {"i",                     "abcdefghijkloprstB"},          // '!' can follow mnquvwzA = -,+,(,rand(,self.,vict., digit, dice( 
+ {"ryz",                   "iquvwyzA"},                    // digit, ')', variables CAN'T follow: 
+                                                           //             digit, !, (, rand(, self., vict., variables, dice(.
+ {"vw",                    "abcdefghijklmnopqrstuvwxyAB"}  // self., vict. can follow z = variables.
+ };
+ int i;
+
+ for (i=0; i<4; i++) {
+   if (strchr (test[i][0], CHAR_CODE(otype_act))) {
+     if (strchr (test[i][1], CHAR_CODE(type_act))) 
+       return (otype_act * 100 + type_act);
+     else
+       return 0; 
+   }
+ }
+ return 0;
+}
+
+void send_formula_error (struct char_data *ch, int error, int spell_vnum, int syserr)
+{
+ char buf[2048];
+
+ const char *error_5000[] = {
+ "Unknown variable or operator",               /* 5000 */
+ "it should have as much '(' and ')'",         /* 5001 */
+ "it should have as much '?' and ':'",         /* 5002 */
+ "can't perform formula. failed to solve",     /* 5003 */
+ "':' was expected but not found",             /* 5004 */
+ "A formula can't end by ':'",                 /* 5005 */
+ "division by 0",                              /* 5006 */
+ "Unsupported +++",                            /* 5007 */
+ "Unsupported ---",                            /* 5008 */
+ "it should have as much 'dice(' and ','",     /* 5009 */
+ "',' expected but not found"
+ };                 
+
+ if (syserr)
+   sprintf (buf, "SYSERR: got error (%d) from spell (%d) : ", error, spell_vnum);
+
+ if ((error >= 5000) && (error <= LAST_5K_ERROR))
+   snprintf(buf, sizeof(buf), "SYNTAX: %s", error_5000 [error-5000]);
+ else
+   if ((error >= 9900) || (error < 6000))
+      snprintf (buf, sizeof(buf), "SYNTAX: %s can't follow %s", 
+             ((error/100) == CODE_DIGIT) ? "a number" : list_codes[error/100],
+             ((error%100) == CODE_DIGIT) ? "a number" : list_codes[error%100]);
+   else 
+   if (error >= ERROR_7000)
+      snprintf (buf, sizeof(buf), "SYNTAX: A formula can't end by %s", list_codes[error-ERROR_7000]);
+   else if (error >= 6000)
+      snprintf (buf, sizeof(buf), "SYNTAX: A formula can't start by %s", list_codes[error-6000]);
+
+ if (syserr == TRUE) 
+   mudlog (BRF, LVL_BUILDER, TRUE, "%s", buf);
+ else {
+   send_to_char (ch, "%s\r\n", buf);
+ }
+}
+
+#ifdef DEBUG_FORMULA
+void show_formula (struct char_data *ch, struct formula *head_formula)  
+{
+ char buf[2048];
+
+ int cpt = 0;
+ struct formula *Q; 
+
+ strcpy (buf, "formula : ");
+ for (Q = head_formula; Q; Q=Q->next, cpt++) { 
+   if (Q->command == CODE_DIGIT) 
+     sprintf (buf, "%s%d", buf, Q->value);
+   else
+     sprintf (buf, "%s%s", buf, ((Q->command == CODE_ART_SUB) && (Q->next) && 
+                                 (Q->next->sign == -1)) ? "+" : ((Q->command == CODE_ART_ADD) &&
+                                 (Q->next) &&  (Q->next->sign == -1)) ? "-" : list_codes[Q->command]);
+  }
+  sprintf (buf, "%s, nodes: %d\r\n", buf, cpt);
+  send_to_char (ch, "%s", buf);
+}
+
+void show_ABC(struct char_data *ch, struct formula *C) 
+{
+ struct formula *A = NULL, *B = NULL;
+
+ if (C)
+   B = C->prev;
+
+ if (B)
+   A = B->prev;
+
+ if (A)
+ send_to_char(ch, "A) Command: %d\r\n"
+                  "   Sign:    %d\r\n"
+                  "   Value:   %d\r\n", A->command, A->sign, A->value);
+ if (B)
+ send_to_char(ch, "B) Command: %d\r\n"
+                  "   Sign:    %d\r\n"
+                  "   Value:   %d\r\n", B->command, B->sign, B->value);
+ if (C)
+ send_to_char(ch, "C) Command: %d\r\n"
+                  "   Sign:    %d\r\n"
+                  "   Value:   %d\r\n", C->command, C->sign, C->value);
+}
+#endif
+
+void remove_node (struct formula **head_formula, struct formula *ptr)
+{
+ if (ptr->prev) 
+   ptr->prev->next = ptr->next;
+ else 
+   *head_formula = ptr->next;
+ if (ptr->next) 
+   ptr->next->prev = ptr->prev;
+ free (ptr);
+}
+
+int remove_brace (struct formula **head_formula, struct formula *C, // int * rts_code, 
+                  struct char_data *ch)
+{
+ struct formula *A, *B;
+
+ B = C->prev;
+ A = B->prev;
+
+#ifdef DEBUG_FORMULA
+ send_to_char(ch, "remove_brace\r\n");
+// show_ABC(ch, C);
+#endif
+
+ if (B->command == CODE_ART_RAND) {
+   B->command = CODE_DIGIT;
+   B->value = (B->value < 0) ? 0 : rand_number(1, B->value);
+
+   remove_node (head_formula, C);
+
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+   return 1;
+ }
+
+ if (!A) {
+  B->command = CODE_DIGIT;
+
+  remove_node (head_formula, C);
+
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+  return 1;
+ }
+
+ // fix alias 12
+ if (B->command == CODE_ART_OBRACE) {
+   B->command = CODE_DIGIT;
+
+   remove_node (head_formula, C);
+
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+   return 1;
+ }
+
+ // remove typical (9) or rand(9)
+ if ((A->command == CODE_ART_OBRACE) || (A->command == CODE_ART_RAND)) {
+   if (A->command == CODE_ART_RAND)
+     B->value = (B->sign == -1) ? 0 : rand_number(1, B->value);
+
+   remove_node (head_formula, C);
+   remove_node (head_formula, A);
+
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+   return 1; 
+ }
+
+ if (A->command == CODE_COMMA) {
+#ifdef DEBUG_FORMULA
+   send_to_char(ch, "dice (%d, %d)\r\n", A->prev->value, B->value);
+#endif
+   B->value = dice(A->prev->value, B->value);
+   remove_node (head_formula, C);
+   remove_node (head_formula, A);
+   if (!A->prev || !A->prev->prev) {
+     log("SYSERR: Formula something went wrong!.");
+     return 0;
+   }
+   remove_node (head_formula, A->prev);
+   remove_node (head_formula, A->prev->prev);
+
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+   return 1;
+ }
+ return 0; 
+}
+
+struct formula *formula_do_oper (struct formula **head_formula, struct formula *B,
+                                 int spell_vnum, struct char_data *ch, int
+                                 *rts_code)
+{ 
+ struct formula *A, *C;
+
+ if (!(A = B->prev) && (B->command != CODE_ART_NOT) 
+                    && (B->command != CODE_ART_ADD)
+                    && (B->command != CODE_ART_SUB)) {
+   *rts_code = 6000 + B->command;
+   return NULL;
+  } 
+
+ if (!(C = B->next)) {
+   *rts_code = ERROR_7000 + B->command;
+   return NULL;
+ }
+
+ switch (C->command) {
+   case CODE_ART_SUB : if (C->next)
+                         C->next->sign = -1;  
+                       remove_node (head_formula, C);
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+                       return (B); 
+   case CODE_ART_ADD : remove_node (head_formula, C);
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+                       return (B);
+ }
+
+ if (A) {               /* !20 or -10, +10 there's no A*/
+   A->value *= A->sign;
+   A->sign = 1;
+ }
+ C->value *= C->sign;
+ C->sign = 1;
+ switch (B->command) {
+   case CODE_CON_IF    : if (!C->next || (C->next->command != CODE_CON_ELSE)) {
+                           *rts_code = ERROR_5004;
+                           return NULL;
+                         } else {
+                             if (!C->next->next) {
+                               *rts_code = ERROR_5005; 
+                               return NULL;
+                             }
+                             A->value = A->value ? C->value : C->next->next->value;
+                             remove_node (head_formula, C->next->next);
+                             remove_node (head_formula, C->next);
+                             remove_node (head_formula, C);
+                             remove_node (head_formula, B);
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+                           }
+                         return (A);   
+   case CODE_LOG_OR    : A->value = (A->value || C->value) ? 1 : 0 ; break;
+   case CODE_LOG_AND   : A->value = (A->value && C->value) ? 1 : 0 ; break;
+   case CODE_LOG_GREQ  : A->value = (A->value >= C->value) ? 1 : 0 ; break;
+   case CODE_LOG_GR    : A->value = (A->value >  C->value) ? 1 : 0 ; break;
+   case CODE_LOG_LTEQ  : A->value = (A->value <= C->value) ? 1 : 0 ; break;
+   case CODE_LOG_LT    : A->value = (A->value <  C->value) ? 1 : 0 ; break;
+   case CODE_LOG_EQ    : A->value = (A->value == C->value) ? 1 : 0 ; break;
+   case CODE_LOG_NOTEQ : A->value = (A->value != C->value) ? 1 : 0 ; break;
+   case CODE_ART_XOR   : A->value = (A->value ^  C->value); break;
+   case CODE_ART_AND   : A->value = (A->value &  C->value); break;
+   case CODE_ART_OR    : A->value = (A->value |  C->value); break;
+   case CODE_ART_MOD   : A->value = (A->value %  C->value); break;
+   case CODE_ART_SUB   : if (!A) { 
+                           C->sign = -1;
+                           remove_node (head_formula, B);
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+                           return (C);
+                         } else
+                             A->value = (A->value - C->value);
+                         break; 
+   case CODE_ART_ADD   : if (!A) {
+                           remove_node (head_formula, B);
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+                           return (C);
+                         } else
+                             A->value = (A->value + C->value); 
+                         break;
+   case CODE_ART_DIV   : if (C->value)
+                           A->value = (A->value / C->value);
+                         else {
+                           *rts_code = ERROR_5006;
+                           return NULL;
+                         } 
+                         break;
+   case CODE_ART_MUL : A->value = (A->value * C->value); break; 
+   case CODE_ART_NOT : C->sign  = 1;
+                       C->value = !C->value ? 1 : 0;
+                       remove_node (head_formula, B);
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+                       return (C);
+ }
+ remove_node(head_formula, C); 
+ remove_node(head_formula, B);
+// this code does the same in a quicker way, but above is easier to understand
+// ------------------------------------
+// if ((A->next = C->next))
+//   (C->next)->prev = A;
+// free (C);                     
+// free (B);
+#ifdef DEBUG_FORMULA
+   show_formula(ch, *head_formula);
+#endif
+ return (A);
+}
+
+int perform_formula (struct formula **head_formula, int spell_vnum,
+                     struct char_data *ch, int syserr, int *rts_code) 
+{
+  const char *priority_check[5] = {"ijkl", "opx", "nm", "abcdefgh", "s"};
+  int exit = 0, brace, result, mode;
+  int inf_loop = 0;
+  struct formula *Q, *ptr, *tmp;
+
+  if (!*head_formula)
+    return 0;
+
+  do {
+    for (ptr = NULL, Q = *head_formula; Q; Q = Q->next)
+      if ((Q->command == CODE_ART_OBRACE) || (Q->command == CODE_ART_RAND) || (Q->command == CODE_ART_DICE)) 
+        ptr = Q;
+
+    if (ptr == NULL) {
+      ptr = *head_formula;
+      exit = 1;
+    };
+
+    brace = 1; 
+    mode = 0;
+    tmp = ptr;
+
+    do {
+      if (++inf_loop > 1000) {
+        *rts_code = ERROR_5003;
+        send_formula_error (ch, *rts_code, spell_vnum, syserr);
+        free_formula(head_formula);
+        mudlog (BRF, LVL_BUILDER, TRUE, "SYSERR: Infinite loop detected in formula");
+        return 0; 
+      }
+      while (ptr && ptr->command != CODE_ART_CBRACE) {
+        if (strchr (priority_check[mode], CHAR_CODE(ptr->command))) {
+          ptr = formula_do_oper (head_formula, ptr, spell_vnum, ch, rts_code);
+          if (*rts_code) {
+            send_formula_error (ch, *rts_code, spell_vnum, syserr);
+            free_formula(head_formula);
+            return 0; 
+          }
+        }
+        else
+          ptr = ptr->next;
+      }
+
+      if (ptr && remove_brace(head_formula, ptr, ch))
+        brace = 0;
+
+      if (++mode > 4)  
+        brace = 0;
+      else
+        ptr = tmp;
+
+    } while (brace);
+  } while (!exit);
+
+#ifdef DEBUG_FORMULA
+  show_formula(ch, *head_formula);
+#endif
+
+  result = (*head_formula)->value * (*head_formula)->sign;
+  free_formula(head_formula);
+  return (result);
+}
+
+int formula_interpreter (struct char_data *self, struct char_data *vict, 
+                         int spell_vnum, int syserr, char *cmd, int param, int *rts_code)
+{
+ char buf[2048];
+
+ const char bad_start_code[] = "abcdefghjkloprstxzB";
+ const char bad_end_code[] = "abcdefghijklmnopqstuvwxAB";
+
+ struct formula *head_formula = NULL;
+ int i = 0, num = 0, otype_act  = 0, type_act = 0, self_vict = -1; 
+ int cpt_obrace = 0, cpt_cbrace = 0, cpt_if   = 0, cpt_else  = 0;
+ int cpt_dice = 0, cpt_comma = 0;
+ int cpt_char = 1;
+
+ *rts_code = 0;
+
+ if (!self) {
+   *rts_code = ERROR_8000;
+   return 0;
+ }
+
+ if (!cmd || !*cmd)
+   return 0;
+
+ // if no vict, let's self act as the victim.
+ if (!vict)
+   vict = self;
+
+ // remove all spaces in the formula, and truncate if cmd is bigger than my buffer 2048.
+ buf[0] = ' ';
+
+ for (i=0; i<strlen(cmd) && (i < 2046); i++) {
+   switch (cmd [i]) {
+     case '(' : cpt_obrace++; break;
+     case ')' : cpt_cbrace++; break;
+     case '?' : cpt_if++;     break;
+     case ':' : cpt_else++;   break;
+     case ',' : cpt_comma++;  break;
+   }
+   if (cmd[i] != ' ')  
+     buf[cpt_char++] = toupper(cmd[i]);
+ }
+ buf[cpt_char] = ' '; 
+ buf[cpt_char+1] = '\x0';
+
+ if (strstr(buf, "+++")) {
+   *rts_code = ERROR_5007;
+   send_formula_error (self, *rts_code, spell_vnum, syserr);
+   return 0;
+ }
+
+ if (strstr(buf, "---")) {
+   *rts_code = ERROR_5008;
+   send_formula_error (self, *rts_code, spell_vnum, syserr);
+   return 0;
+ }
+
+ for (i=0; i<strlen(buf); i++) {
+   if (strncmp(&buf[i], "DICE(", 5) == 0)
+     cpt_dice++;
+ }
+
+ if (cpt_obrace != cpt_cbrace) {
+   *rts_code = ERROR_5001;
+   send_formula_error (self, *rts_code, spell_vnum, syserr);
+   return 0;
+ }
+
+ if (cpt_if != cpt_else) {
+   *rts_code = ERROR_5002;
+   send_formula_error (self, *rts_code, spell_vnum, syserr);
+   return 0;
+ }
+
+ if (cpt_dice != cpt_comma) {
+   *rts_code = ERROR_5009;
+   send_formula_error (self, *rts_code, spell_vnum, syserr);
+   return 0;
+  }
+
+ for (i=0; i<strlen(buf); i++) {
+   if (type_act)
+     otype_act = type_act;
+   if (!(type_act = get_formula_typeact ( buf, &i )) && (i<strlen(buf)-1)) 
+     continue;              
+
+   if (!otype_act)  {
+     if (strchr(bad_start_code, CHAR_CODE(type_act))) {
+       *rts_code = ERROR_6000 + type_act;
+       send_formula_error (self, *rts_code, spell_vnum, syserr);
+       return 0;
+     }
+   }
+
+   if (type_act == -1) {
+     *rts_code = ERROR_5000;
+     send_formula_error (self, *rts_code, spell_vnum, syserr);
+     free_formula (&head_formula);
+     return 0;  
+   } else
+       if (type_act && ((type_act != CODE_DIGIT) || (otype_act != CODE_DIGIT))) 
+         if ((*rts_code = check_formula_syntax (otype_act, type_act))) { 
+           send_formula_error (self, *rts_code, spell_vnum, syserr);
+           free_formula (&head_formula);
+           return 0;
+         }
+
+   if ((otype_act == CODE_IDE_SELF) || (otype_act == CODE_IDE_VICT))
+     switch (type_act) {
+       case CODE_VAR_IS_GOOD :   num = IS_GOOD(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_IS_NEUTRAL: num = IS_NEUTRAL(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_IS_EVIL :   num = IS_EVIL(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_STR :       num = GET_STR(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_DEX :       num = GET_DEX(self_vict == CODE_IDE_SELF ? self : vict); 
+                                 break;
+       case CODE_VAR_INT :       num = GET_INT(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_WIS :       num = GET_WIS(self_vict == CODE_IDE_SELF ? self : vict); 
+                                 break;
+       case CODE_VAR_CON :       num = GET_CON(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break; 
+       case CODE_VAR_CHA :       num = GET_CHA(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_CLASS :     num = GET_CLASS(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break; 
+       case CODE_VAR_LEVEL :     num = GET_LEVEL(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_AGE :       num = GET_AGE(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_WEIGHT :    num = GET_WEIGHT(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_HEIGHT :    num = GET_HEIGHT(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_MANA :      num = GET_MANA(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_MAXMANA :   num = GET_MAX_MANA(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_HIT :       num = GET_HIT(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_MAXHIT :    num = GET_MAX_HIT(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_MOVE :      num = GET_MOVE(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_MAXMOVE :   num = GET_MAX_MOVE(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_GOLD :      num = GET_GOLD(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_EXP :       num = GET_EXP(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_ARMOR :     num = GET_AC(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_HITROLL :   num = GET_HITROLL(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_DAMROLL :   num = GET_DAMROLL(self_vict == CODE_IDE_SELF ? self : vict);
+                                 break;
+       case CODE_VAR_SAVPARA :   num = GET_SAVE(self_vict == CODE_IDE_SELF ? self : vict, SAVING_PARA);
+                                 break;
+       case CODE_VAR_SAVROD :    num = GET_SAVE(self_vict == CODE_IDE_SELF ? self : vict, SAVING_ROD);
+                                 break;
+       case CODE_VAR_SAVPETRI :  num = GET_SAVE(self_vict == CODE_IDE_SELF ? self : vict, SAVING_PETRI);
+                                 break;
+       case CODE_VAR_SAVBREATH : num = GET_SAVE(self_vict == CODE_IDE_SELF ? self : vict, SAVING_BREATH);
+                                 break;
+       case CODE_VAR_SAVSPELL :  num = GET_SAVE(self_vict == CODE_IDE_SELF ? self : vict, SAVING_SPELL); 
+                                 break;  
+     } else {
+         if (otype_act && ((otype_act != CODE_DIGIT) || (type_act != CODE_DIGIT))) {
+           add_to_formula (&head_formula, otype_act, num);
+           num = 0; 
+         } 
+         switch (type_act) {
+            case CODE_IDE_SELF :
+            case CODE_IDE_VICT : self_vict = type_act; break;
+            case CODE_DIGIT    : num = num * 10 + (buf[i] - '0'); break; 
+            case CODE_PARAM    : num = param; break;
+         }
+       }
+  }
+
+#ifdef DEBUG_FORMULA
+   show_formula (self, head_formula);
+#endif
+
+ if (strchr(bad_end_code, CHAR_CODE(otype_act))) {
+   *rts_code = ERROR_7000 + otype_act;
+   send_formula_error (self, *rts_code, spell_vnum, syserr);
+   free_formula (&head_formula);
+   return 0;
+ }
+
+ return (perform_formula(&head_formula, spell_vnum, self, syserr, rts_code));
+}
+
+ACMD(do_formula) {
+ int rts_code;
+
+ send_to_char (ch, "value: %d\r\n", formula_interpreter (ch, 0, 0, FALSE, argument, 0, &rts_code));
+}
diff -uN ./orig/formula.h ./formula.h
--- ./orig/formula.h	1969-12-31 19:00:00.000000000 -0500
+++ ./formula.h	2020-02-25 19:19:09.941725647 -0500
@@ -0,0 +1,111 @@
+/* Copyright (c) 1999 castillo7@hotmail.com
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE. */
+
+#ifndef SPEDIT_FORMULA
+#define SPEDIT_FORMULA
+
+int formula_interpreter (struct char_data *self, struct char_data *vict,
+                         int spell_vnum, int syserr, char *cmd, int param, int *rts_code);
+
+#define CODE_SPACE         0     /* a space      */
+#define CODE_LOG_AND       1     /* logical      */  
+#define CODE_LOG_OR        2  
+#define CODE_LOG_GREQ      3  
+#define CODE_LOG_GR        4  
+#define CODE_LOG_LTEQ      5 
+#define CODE_LOG_LT        6
+#define CODE_LOG_EQ        7 
+#define CODE_LOG_NOTEQ     8
+#define CODE_ART_NOT       9     /* arithmetic   */
+#define CODE_ART_XOR       10
+#define CODE_ART_AND       11
+#define CODE_ART_OR        12
+#define CODE_ART_SUB       13
+#define CODE_ART_ADD       14
+#define CODE_ART_DIV       15
+#define CODE_ART_MUL       16
+#define CODE_ART_OBRACE    17
+#define CODE_ART_CBRACE    18
+#define CODE_CON_IF        19    /* conditional  */
+#define CODE_CON_ELSE      20 
+#define CODE_ART_RAND      21    /* arithmetic   */
+#define CODE_IDE_SELF      22    /* identifier   */
+#define CODE_IDE_VICT      23
+#define CODE_ART_MOD       24
+
+#define CODE_VAR_FIRST     25    /* variable     */
+#define CODE_VAR_STR       25
+#define CODE_VAR_DEX       26
+#define CODE_VAR_INT       27
+#define CODE_VAR_WIS       28
+#define CODE_VAR_CON       29
+#define CODE_VAR_CHA       30
+#define CODE_VAR_CLASS     31
+#define CODE_VAR_LEVEL     32
+#define CODE_VAR_AGE       33
+#define CODE_VAR_WEIGHT    34
+#define CODE_VAR_HEIGHT    35
+#define CODE_VAR_MAXMANA   36
+#define CODE_VAR_MAXHIT    37
+#define CODE_VAR_MAXMOVE   38
+#define CODE_VAR_GOLD      39
+#define CODE_VAR_EXP       40
+#define CODE_VAR_ARMOR     41
+#define CODE_VAR_HITROLL   42
+#define CODE_VAR_DAMROLL   43
+#define CODE_VAR_SAVPARA   44
+#define CODE_VAR_SAVROD    45
+#define CODE_VAR_SAVPETRI  46
+#define CODE_VAR_SAVBREATH 47
+#define CODE_VAR_SAVSPELL  48
+#define CODE_VAR_HIT       49
+#define CODE_VAR_MANA      50
+#define CODE_VAR_MOVE      51
+#define CODE_VAR_IS_GOOD   52
+#define CODE_VAR_IS_NEUTRAL 53
+#define CODE_VAR_IS_EVIL   54
+#define CODE_VAR_LAST      54    /* last variable  */ 
+#define CODE_ART_DICE      55    /* this was added later */
+#define CODE_COMMA         56
+#define CODE_PARAM         57
+
+#define CODE_DIGIT         99    /* digit 0 to 9 */
+#define ERROR_5000         5000  /* Unknow variable or operator */
+#define ERROR_5001         5001  /* formula don't have as much ( as ) */
+#define ERROR_5002         5002  /* formula don't have as much ? as : */
+#define ERROR_5003         5003  /* failed to resolve the formula */
+#define ERROR_5004         5004  /* : expected but not found */
+#define ERROR_5005         5005  /* a formula can't end by : */
+#define ERROR_5006         5006  /* division by 0 */
+#define ERROR_5007         5007  /* +++ Unsupported */
+#define ERROR_5008         5008  /* --- Unsupported */
+#define ERROR_5009         5009  /* formula don't have as much 'dice' as ',' */ 
+#define ERROR_5010         5010  /* , expected but not found */
+#define LAST_5K_ERROR      5010
+#define ERROR_6000         6000  /* a formula can't start by */
+#define ERROR_7000         7000  /* a formula can't end by */
+#define ERROR_8000         8000  /* no self passed to formula interpreter */
+
+#define CHAR_CODE(x)       ((x) == CODE_DIGIT ? 'y' : \
+                            (x) == CODE_PARAM ? 'y' : \
+                            (x) == CODE_COMMA ? 'B' : \
+                            (x) == CODE_ART_DICE ? 'A' : \
+                            (x) >= CODE_VAR_FIRST ? 'z' : \
+                            (x) -  CODE_LOG_AND   + 'a') 
+
+struct formula {
+  int    command;
+  int    value;
+  int    sign;
+  struct formula *next;
+  struct formula *prev;
+};
+
+#endif
diff -uN ./orig/formula.README ./formula.README
--- ./orig/formula.README	1969-12-31 19:00:00.000000000 -0500
+++ ./formula.README	2020-02-25 19:19:09.941725647 -0500
@@ -0,0 +1,82 @@
+
+Formula: solve mathematics formula using combinations of operators, 
+variables and numbers. 
+
+List of operators and variables:
+
+Operators : && Logical AND            Variables: GOOD     |  HITROLL
+            || Logical OR                        NEUTRAL  |  DAMROLL
+            >= Rel. greater or equal             EVIL     |  SAVPARA 
+            >  Relational greater                STR      |  SAVROD
+            <= Rel. less or equal                DEX      |  SAVPETRI
+            <  Relational less                   INT      |  SAVBREATH
+            == Relational equal                  WIS      |  SAVSPELL
+            != Relational not equal              CON
+            !  NOT                               CHA
+            ^  Bitwise exclusive OR              CLASS
+            &  Bitwise AND                       LEVEL
+            |  Bitwise inclusive OR              AGE 
+            -  Subtraction                       HEIGHT
+            +  Addition                          WEIGHT 
+            /  Division                          HIT
+            *  Multiplication                    MANA
+            %  Modulus                           MOVE
+            () Parentheses                       MAXMANA
+            RAND() Random                        MAXHIT
+            DICE(a, b)                           MAXMOVE
+            ?: Ternary operator                  GOLD
+            SELF.                                EXP  
+            VICT.                                ARMOR
+                                                 PARAM
+
+All variables (except PARAM), must be precedes by either SELF. or VICT.
+
+Return value(s):
+
+SELF.MANA  = Caster mana
+VICT.DEX   = Victim dexterity.
+SELF.CLASS = 0 (Magical User)
+             1 (Cleric)
+             2 (Thief)
+             3 (Warrior)
+PARAM      = special level. 
+             " 
+                  This is used by some spells, it represent obj level or 
+                  caster level.
+
+             for e.g: a staff that cast a level 12 spell. PARAM will return 12.
+             In most case PARAM just return SELF.LEVEL   "
+
+Operator:
+RAND(value) : randomize number between 1 and value.
+
+Operator:
+DICE(a, b)  : help dice.
+
+Conditional Operator:
+? :         : A ? B : C 
+              if A is true return B otherwise return C.
+
+examples: 
+
+formula 1200 + (self.class == 0 ? 10 : (self.class == 1 ? 20 : 30))
+return 1210, 1220, 1230 based on the caster CLASS.
+
+Numbers:
+All numbers must be integer, this version doesn't support real number yet.
+
+a) BAD: self.int * 2.4
+b) GOOD: self.int * 2 + self.int * 4 / 10
+
+Note: (b) result would NOT be rounded. Decimal would be dropped.
+
+Notes: 
+
+1) If a formula is wrong or fail. It will return 0. 
+
+2) All levels of ? : require to be between parenthese, or the result would be wrong.
+
+GOOD: formula 1200 + (self.class == 0 ? 10 : (self.class == 1 ? 20 : 30))
+BAD:  formula 1200 + self.class == 0 ? 10 : self.class == 1 ? 20 : 30
+
+(6 feb 2020)
diff -uN ./orig/handler.c ./handler.c
--- ./orig/handler.c	2020-02-25 19:18:51.518369387 -0500
+++ ./handler.c	2020-02-25 19:19:09.941725647 -0500
@@ -199,7 +199,8 @@
     break;
 
   default:
-    log("SYSERR: Unknown apply adjust %d attempt (%s, affect_modify).", loc, __FILE__);
+    if (loc > NUM_APPLIES + NUM_AFF_FLAGS)
+      log("SYSERR: Unknown apply adjust %d attempt (%s, affect_modify).", loc, __FILE__);
     break;
 
   } /* switch */
diff -uN ./orig/interpreter.c ./interpreter.c
--- ./orig/interpreter.c	2020-02-25 19:18:51.522369247 -0500
+++ ./interpreter.c	2020-02-25 19:19:09.941725647 -0500
@@ -37,6 +37,9 @@
 #include "prefedit.h"
 #include "ibt.h"
 #include "mud_event.h"
+#include "spedit.h"
+
+ACMD(do_formula);
 
 /* local (file scope) functions */
 static int perform_dupe_check(struct descriptor_data *d);
@@ -101,17 +104,17 @@
   { "autosac"  , "autosac" , POS_DEAD    , do_gen_tog , 0, SCMD_AUTOSAC },
   { "autosplit", "autospl" , POS_DEAD    , do_gen_tog , 0, SCMD_AUTOSPLIT },
 
-  { "backstab" , "ba"      , POS_STANDING, do_backstab , 1, 0 },
+  { "backstab" , "ba"      , POS_STANDING, do_cast , 1, SKILL_BACKSTAB },
   { "ban"      , "ban"     , POS_DEAD    , do_ban      , LVL_GRGOD, 0 },
-  { "bandage"  , "band"    , POS_RESTING , do_bandage  , 1, 0 },
+  { "bandage"  , "band"    , POS_RESTING , do_cast  , 1, SKILL_BANDAGE },
   { "balance"  , "bal"     , POS_STANDING, do_not_here , 1, 0 },
-  { "bash"     , "bas"     , POS_FIGHTING, do_bash     , 1, 0 },
+  { "bash"     , "bas"     , POS_FIGHTING, do_cast     , 1, SKILL_BASH },
   { "brief"    , "br"      , POS_DEAD    , do_gen_tog  , 0, SCMD_BRIEF },
   { "buildwalk", "buildwalk", POS_STANDING, do_gen_tog , LVL_BUILDER, SCMD_BUILDWALK },
   { "buy"      , "bu"      , POS_STANDING, do_not_here , 0, 0 },
   { "bug"      , "bug"     , POS_DEAD    , do_ibt      , 0, SCMD_BUG },
 
-  { "cast"     , "c"       , POS_SITTING , do_cast     , 1, 0 },
+  { "cast"     , "c"       , POS_SITTING , do_cast     , 1, SCMD_SPELL },
   { "cedit"    , "cedit"   , POS_DEAD    , do_oasis_cedit, LVL_IMPL, 0 },
   { "changelog", "cha"     , POS_DEAD    , do_changelog, LVL_IMPL, 0 },
   { "check"    , "ch"      , POS_STANDING, do_not_here , 1, 0 },
@@ -151,6 +154,7 @@
   { "file"     , "file"    , POS_SLEEPING, do_file     , LVL_GOD, 0 },
   { "flee"     , "fl"      , POS_FIGHTING, do_flee     , 1, 0 },
   { "follow"   , "fol"     , POS_RESTING , do_follow   , 0, 0 },
+  { "formula"  , "form"    , POS_DEAD    , do_formula  , LVL_GOD, 0 },
   { "freeze"   , "freeze"  , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_FREEZE },
 
   { "get"      , "g"       , POS_RESTING , do_get      , 0, 0 },
@@ -170,7 +174,7 @@
   { "happyhour", "ha"      , POS_DEAD    , do_happyhour, 0, 0 },
   { "hedit"    , "hedit"   , POS_DEAD    , do_oasis_hedit, LVL_GOD , 0 },
   { "helpcheck", "helpch"  , POS_DEAD    , do_helpcheck, LVL_GOD, 0 },
-  { "hide"     , "hi"      , POS_RESTING , do_hide     , 1, 0 },
+  { "hide"     , "hi"      , POS_RESTING , do_cast     , 1, SKILL_HIDE },
   { "hindex"   , "hind"    , POS_DEAD    , do_hindex   , 0, 0 },
   { "handbook" , "handb"   , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_HANDBOOK },
   { "hcontrol" , "hcontrol", POS_DEAD    , do_hcontrol , LVL_GRGOD, 0 },
@@ -192,7 +196,7 @@
   { "junk"     , "j"       , POS_RESTING , do_drop     , 0, SCMD_JUNK },
 
   { "kill"     , "k"       , POS_FIGHTING, do_kill     , 0, 0 },
-  { "kick"     , "ki"      , POS_FIGHTING, do_kick     , 1, 0 },
+  { "kick"     , "ki"      , POS_FIGHTING, do_cast     , 1, SKILL_KICK },
 
   { "look"     , "l"       , POS_RESTING , do_look     , 0, SCMD_LOOK },
   { "last"     , "last"    , POS_DEAD    , do_last     , LVL_GOD, 0 },
@@ -266,7 +270,7 @@
   { "rent"     , "rent"    , POS_STANDING, do_not_here , 1, 0 },
   { "report"   , "repo"    , POS_RESTING , do_report   , 0, 0 },
   { "reroll"   , "rero"    , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_REROLL },
-  { "rescue"   , "resc"    , POS_FIGHTING, do_rescue   , 1, 0 },
+  { "rescue"   , "resc"    , POS_FIGHTING, do_cast   , 1, SKILL_RESCUE },
   { "restore"  , "resto"   , POS_DEAD    , do_restore  , LVL_GOD, 0 },
   { "return"   , "retu"    , POS_DEAD    , do_return   , 0, 0 },
   { "redit"    , "redit"   , POS_DEAD    , do_oasis_redit, LVL_BUILDER, 0 },
@@ -295,13 +299,15 @@
   { "skillset" , "skillset", POS_SLEEPING, do_skillset , LVL_GRGOD, 0 },
   { "sleep"    , "sl"      , POS_SLEEPING, do_sleep    , 0, 0 },
   { "slist"    , "slist"   , POS_SLEEPING, do_oasis_list, LVL_BUILDER, SCMD_OASIS_SLIST },
-  { "sneak"    , "sneak"   , POS_STANDING, do_sneak    , 1, 0 },
+  { "sneak"    , "sneak"   , POS_STANDING, do_cast    , 1, SKILL_SNEAK },
   { "snoop"    , "snoop"   , POS_DEAD    , do_snoop    , LVL_GOD, 0 },
+  { "spedit"   , "spe"     , POS_DEAD    , do_spedit   , LVL_GRGOD, 0 },
+  { "splist"   , "splist"  , POS_DEAD    , do_splist   , LVL_BUILDER, 0 },
   { "socials"  , "socials" , POS_DEAD    , do_commands , 0, SCMD_SOCIALS },
   { "split"    , "split"   , POS_SITTING , do_split    , 1, 0 },
   { "stand"    , "st"      , POS_RESTING , do_stand    , 0, 0 },
   { "stat"     , "stat"    , POS_DEAD    , do_stat     , LVL_IMMORT, 0 },
-  { "steal"    , "ste"     , POS_STANDING, do_steal    , 1, 0 },
+  { "steal"    , "ste"     , POS_STANDING, do_cast    , 1, SKILL_STEAL },
   { "switch"   , "switch"  , POS_DEAD    , do_switch   , LVL_GOD, 0 },
 
   { "tell"     , "t"       , POS_DEAD    , do_tell     , 0, 0 },
@@ -313,7 +319,7 @@
   { "title"    , "title"   , POS_DEAD    , do_title    , 0, 0 },
   { "time"     , "time"    , POS_DEAD    , do_time     , 0, 0 },
   { "toggle"   , "toggle"  , POS_DEAD    , do_toggle   , 0, 0 },
-  { "track"    , "track"   , POS_STANDING, do_track    , 0, 0 },
+  { "track"    , "track"   , POS_STANDING, do_cast    , 0, SKILL_TRACK },
   { "transfer" , "transfer", POS_SLEEPING, do_trans    , LVL_GOD, 0 },
   { "trigedit" , "trigedit", POS_DEAD    , do_oasis_trigedit, LVL_BUILDER, 0 },
   { "typo"     , "typo"    , POS_DEAD    , do_ibt      , 0, SCMD_TYPO },
@@ -343,7 +349,7 @@
   { "whois"    , "whoi"    , POS_DEAD    , do_whois    , 0, 0 },
   { "whoami"   , "whoami"  , POS_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI },
   { "where"    , "where"   , POS_RESTING , do_where    , 1, 0 },
-  { "whirlwind", "whirl"   , POS_FIGHTING, do_whirlwind, 0, 0 },
+  { "whirlwind", "whirl"   , POS_FIGHTING, do_cast, 0, SKILL_WHIRLWIND },
   { "whisper"  , "whisper" , POS_RESTING , do_spec_comm, 0, SCMD_WHISPER },
   { "wield"    , "wie"     , POS_RESTING , do_wield    , 0, 0 },
   { "withdraw" , "withdraw", POS_STANDING, do_not_here , 1, 0 },
@@ -530,6 +536,14 @@
 
   if (*complete_cmd_info[cmd].command == '\n') {
     int found = 0;
+
+    struct str_spells *skill = get_spell_by_name(arg, SKILL);
+
+    if (skill) {
+      do_cast(ch, line, 1, skill->vnum); 
+      return;
+    }
+
     send_to_char(ch, "%s", CONFIG_HUH);
 
     for (cmd = 0; *cmd_info[cmd].command != '\n'; cmd++)
@@ -1339,6 +1353,7 @@
     { CON_PREFEDIT, prefedit_parse },
     { CON_IBTEDIT, ibtedit_parse },
     { CON_MSGEDIT, msgedit_parse },
+    { CON_SPEDIT, spedit_parse },
     { -1, NULL }
   };
 
diff -uN ./orig/interpreter.h ./interpreter.h
--- ./orig/interpreter.h	2020-02-25 19:18:51.522369247 -0500
+++ ./interpreter.h	2020-02-25 19:19:09.941725647 -0500
@@ -118,6 +118,9 @@
 #define SCMD_OASIS_TLIST       5
 #define SCMD_OASIS_QLIST       6
 
+/* do_cast */
+#define SCMD_SPELL	0
+
 /* Necessary for CMD_IS macro.  Borland needs the structure defined first
  * so it has been moved down here. */
 
diff -uN ./orig/magic.c ./magic.c
--- ./orig/magic.c	2020-02-25 19:18:51.522369247 -0500
+++ ./magic.c	2020-02-25 19:37:42.016061059 -0500
@@ -22,12 +22,11 @@
 #include "class.h"
 #include "fight.h"
 #include "mud_event.h"
-
+#include "spedit.h"
+#include "formula.h"
 
 /* local file scope function prototypes */
 static int mag_materials(struct char_data *ch, IDXTYPE item0, IDXTYPE item1, IDXTYPE item2, int extract, int verbose);
-static void perform_mag_groups(int level, struct char_data *ch, struct char_data *tch, int spellnum, int savetype);
-
 
 /* Negative apply_saving_throw[] values make saving throws better! So do
  * negative modifiers.  Though people may be used to the reverse of that.
@@ -59,6 +58,7 @@
 {
   struct affected_type *af, *next;
   struct char_data *i;
+  struct str_spells *spell;
 
   for (i = character_list; i; i = i->next)
     for (af = i->affected; af; af = next) {
@@ -68,11 +68,13 @@
       else if (af->duration == -1)	/* No action */
 	;
       else {
-	if ((af->spell > 0) && (af->spell <= MAX_SPELLS))
-	  if (!af->next || (af->next->spell != af->spell) ||
-	      (af->next->duration > 0))
-	    if (spell_info[af->spell].wear_off_msg)
-	      send_to_char(i, "%s\r\n", spell_info[af->spell].wear_off_msg);
+	if ((af->spell > 0) && (af->spell <= MAX_SKILLS)) {
+	  if (!af->next || (af->next->spell != af->spell) || (af->next->duration > 0)) {
+            spell = get_spell_by_vnum(af->spell);
+	    if (spell && spell->messages.wear_off)
+	      send_to_char(i, "%s\r\n", spell->messages.wear_off);
+          }
+        }
 	affect_remove(i, af);
       }
     }
@@ -195,96 +197,48 @@
 int mag_damage(int level, struct char_data *ch, struct char_data *victim,
 		     int spellnum, int savetype)
 {
+  struct str_spells *spell;
   int dam = 0;
+  int rts_code;
 
   if (victim == NULL || ch == NULL)
     return (0);
 
-  switch (spellnum) {
-    /* Mostly mages */
-  case SPELL_MAGIC_MISSILE:
-  case SPELL_CHILL_TOUCH:	/* chill touch also has an affect */
-    if (IS_MAGIC_USER(ch))
-      dam = dice(1, 8) + 1;
-    else
-      dam = dice(1, 6) + 1;
-    break;
-  case SPELL_BURNING_HANDS:
-    if (IS_MAGIC_USER(ch))
-      dam = dice(3, 8) + 3;
-    else
-      dam = dice(3, 6) + 3;
-    break;
-  case SPELL_SHOCKING_GRASP:
-    if (IS_MAGIC_USER(ch))
-      dam = dice(5, 8) + 5;
-    else
-      dam = dice(5, 6) + 5;
-    break;
-  case SPELL_LIGHTNING_BOLT:
-    if (IS_MAGIC_USER(ch))
-      dam = dice(7, 8) + 7;
-    else
-      dam = dice(7, 6) + 7;
-    break;
-  case SPELL_COLOR_SPRAY:
-    if (IS_MAGIC_USER(ch))
-      dam = dice(9, 8) + 9;
-    else
-      dam = dice(9, 6) + 9;
-    break;
-  case SPELL_FIREBALL:
-    if (IS_MAGIC_USER(ch))
-      dam = dice(11, 8) + 11;
-    else
-      dam = dice(11, 6) + 11;
-    break;
-
-    /* Mostly clerics */
-  case SPELL_DISPEL_EVIL:
-    dam = dice(6, 8) + 6;
-    if (IS_EVIL(ch)) {
-      victim = ch;
-      dam = GET_HIT(ch) - 1;
-    } else if (IS_GOOD(victim)) {
-      act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
-      return (0);
-    }
-    break;
-  case SPELL_DISPEL_GOOD:
-    dam = dice(6, 8) + 6;
-    if (IS_GOOD(ch)) {
-      victim = ch;
-      dam = GET_HIT(ch) - 1;
-    } else if (IS_EVIL(victim)) {
-      act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
-      return (0);
-    }
-    break;
-
-
-  case SPELL_CALL_LIGHTNING:
-    dam = dice(7, 8) + 7;
-    break;
+  spell = get_spell_by_vnum(spellnum);
 
-  case SPELL_HARM:
-    dam = dice(8, 8) + 8;
-    break;
-
-  case SPELL_ENERGY_DRAIN:
-    if (GET_LEVEL(victim) <= 2)
-      dam = 100;
-    else
-      dam = dice(1, 10);
-    break;
+  if (!spell) {
+    log("SYSERR: spell not found vnum %d passed to mag_damage.", spellnum);
+    return dam;
+  }
 
-    /* Area spells */
-  case SPELL_EARTHQUAKE:
-    dam = dice(2, 8) + level;
-    break;
+  if (!spell->damages) {
+    log("SYSERR: no damages set for spell vnum %d passed to mag_damage.", spellnum);
+    return dam;
+  }
 
-  } /* switch(spellnum) */
+  dam = MIN(spell->max_dam, MAX(0, formula_interpreter (ch, victim, spellnum, TRUE, spell->damages, level, &rts_code)));
 
+  // special spells that formula interpreter can't deal with.
+  switch (spellnum) {
+    case SPELL_DISPEL_EVIL: if (IS_EVIL(ch)) {
+                              victim = ch;
+                              dam = GET_HIT(ch) - 1;
+                            } else 
+                                if (IS_GOOD(victim)) {
+                                  act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
+                                  return (0);
+                                }
+                            break;
+    case SPELL_DISPEL_GOOD : if (IS_GOOD(ch)) {
+                               victim = ch;
+                               dam = GET_HIT(ch) - 1;
+                             } else 
+                                 if (IS_EVIL(victim)) {
+                                   act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
+                                   return (0);
+                                 }
+                             break;
+  }
 
   /* divide damage by two if victim makes his saving throw */
   if (mag_savingthrow(victim, savetype, 0))
@@ -298,224 +252,87 @@
 /* Every spell that does an affect comes through here.  This determines the
  * effect, whether it is added or replacement, whether it is legal or not, etc.
  * affect_join(vict, aff, add_dur, avg_dur, add_mod, avg_mod) */
-#define MAX_SPELL_AFFECTS 5	/* change if more needed */
-
-void mag_affects(int level, struct char_data *ch, struct char_data *victim,
-		      int spellnum, int savetype)
+int mag_affects(int level, struct char_data *ch, struct char_data *victim,
+                int spellnum, int savetype)
 {
   struct affected_type af[MAX_SPELL_AFFECTS];
   bool accum_affect = FALSE, accum_duration = FALSE;
-  const char *to_vict = NULL, *to_room = NULL;
-  int i, j;
-
+  int i, j, rts_code, affect, effect = 0;
+  struct str_spells *spell;
 
   if (victim == NULL || ch == NULL)
-    return;
+    return MAGIC_FAILED;
+
+  spell = get_spell_by_vnum(spellnum);
+  if (!spell) {
+    log("SYSERR: unknown spellnum %d passed to mag_affects.", spellnum);
+    return MAGIC_FAILED;
+  }
 
   for (i = 0; i < MAX_SPELL_AFFECTS; i++) {
     new_affect(&(af[i]));
     af[i].spell = spellnum;
-  }
 
-  switch (spellnum) {
-
-  case SPELL_CHILL_TOUCH:
-    af[0].location = APPLY_STR;
-    if (mag_savingthrow(victim, savetype, 0))
-      af[0].duration = 1;
-    else
-      af[0].duration = 4;
-    af[0].modifier = -1;
-    accum_duration = TRUE;
-    to_vict = "You feel your strength wither!";
-    break;
-
-  case SPELL_ARMOR:
-    af[0].location = APPLY_AC;
-    af[0].modifier = -20;
-    af[0].duration = 24;
-    accum_duration = TRUE;
-    to_vict = "You feel someone protecting you.";
-    break;
+    int applnum = spell->applies[i].appl_num;
 
-  case SPELL_BLESS:
-    af[0].location = APPLY_HITROLL;
-    af[0].modifier = 2;
-    af[0].duration = 6;
-
-    af[1].location = APPLY_SAVING_SPELL;
-    af[1].modifier = -1;
-    af[1].duration = 6;
+    if (applnum <= APPLY_NONE) {
+      af[i].location = APPLY_NONE;
+      af[i].modifier = 0;
+    } else if (applnum < NUM_APPLIES) {
+             af[i].location = spell->applies[i].appl_num;
+             af[i].modifier = formula_interpreter (ch, victim, spellnum, TRUE, spell->applies[i].modifier, level, &rts_code);
+           } else {
+               af[i].location = spell->applies[i].appl_num; 
+
+               affect = applnum;
+               SET_BIT_AR(af[i].bitvector, affect - NUM_APPLIES);
+           }
+
+    af[i].duration = MAX(1, formula_interpreter (ch, victim, spellnum, TRUE, spell->applies[i].duration, level, &rts_code));
 
-    accum_duration = TRUE;
-    to_vict = "You feel righteous.";
-    break;
-
-  case SPELL_BLINDNESS:
-    if (MOB_FLAGGED(victim, MOB_NOBLIND) || GET_LEVEL(victim) >= LVL_IMMORT || mag_savingthrow(victim, savetype, 0)) {
-      send_to_char(ch, "You fail.\r\n");
-      return;
-    }
-
-    af[0].location = APPLY_HITROLL;
-    af[0].modifier = -4;
-    af[0].duration = 2;
-    SET_BIT_AR(af[0].bitvector, AFF_BLIND);
-
-    af[1].location = APPLY_AC;
-    af[1].modifier = 40;
-    af[1].duration = 2;
-    SET_BIT_AR(af[1].bitvector, AFF_BLIND);
-
-    to_room = "$n seems to be blinded!";
-    to_vict = "You have been blinded!";
-    break;
-
-  case SPELL_CURSE:
-    if (mag_savingthrow(victim, savetype, 0)) {
-      send_to_char(ch, "%s", CONFIG_NOEFFECT);
-      return;
-    }
-
-    af[0].location = APPLY_HITROLL;
-    af[0].duration = 1 + (GET_LEVEL(ch) / 2);
-    af[0].modifier = -1;
-    SET_BIT_AR(af[0].bitvector, AFF_CURSE);
-
-    af[1].location = APPLY_DAMROLL;
-    af[1].duration = 1 + (GET_LEVEL(ch) / 2);
-    af[1].modifier = -1;
-    SET_BIT_AR(af[1].bitvector, AFF_CURSE);
-
-    accum_duration = TRUE;
-    accum_affect = TRUE;
-    to_room = "$n briefly glows red!";
-    to_vict = "You feel very uncomfortable.";
-    break;
-
-  case SPELL_DETECT_ALIGN:
-    af[0].duration = 12 + level;
-    SET_BIT_AR(af[0].bitvector, AFF_DETECT_ALIGN);
-    accum_duration = TRUE;
-    to_vict = "Your eyes tingle.";
-    break;
-
-  case SPELL_DETECT_INVIS:
-    af[0].duration = 12 + level;
-    SET_BIT_AR(af[0].bitvector, AFF_DETECT_INVIS);
-    accum_duration = TRUE;
-    to_vict = "Your eyes tingle.";
-    break;
-
-  case SPELL_DETECT_MAGIC:
-    af[0].duration = 12 + level;
-    SET_BIT_AR(af[0].bitvector, AFF_DETECT_MAGIC);
-    accum_duration = TRUE;
-    to_vict = "Your eyes tingle.";
-    break;
-
-  case SPELL_FLY:
-    af[0].duration = 24;
-    SET_BIT_AR(af[0].bitvector, AFF_FLYING);
-    accum_duration = TRUE;
-    to_vict = "You float above the ground.";
-    break;
-
-  case SPELL_INFRAVISION:
-    af[0].duration = 12 + level;
-    SET_BIT_AR(af[0].bitvector, AFF_INFRAVISION);
-    accum_duration = TRUE;
-    to_vict = "Your eyes glow red.";
-    to_room = "$n's eyes glow red.";
-    break;
-
-  case SPELL_INVISIBLE:
-    if (!victim)
-      victim = ch;
-
-    af[0].duration = 12 + (GET_LEVEL(ch) / 4);
-    af[0].modifier = -40;
-    af[0].location = APPLY_AC;
-    SET_BIT_AR(af[0].bitvector, AFF_INVISIBLE);
-    accum_duration = TRUE;
-    to_vict = "You vanish.";
-    to_room = "$n slowly fades out of existence.";
-    break;
-
-  case SPELL_POISON:
-    if (mag_savingthrow(victim, savetype, 0)) {
-      send_to_char(ch, "%s", CONFIG_NOEFFECT);
-      return;
-    }
-
-    af[0].location = APPLY_STR;
-    af[0].duration = GET_LEVEL(ch);
-    af[0].modifier = -2;
-    SET_BIT_AR(af[0].bitvector, AFF_POISON);
-    to_vict = "You feel very sick.";
-    to_room = "$n gets violently ill!";
-    break;
-
-  case SPELL_PROT_FROM_EVIL:
-    af[0].duration = 24;
-    SET_BIT_AR(af[0].bitvector, AFF_PROTECT_EVIL);
-    accum_duration = TRUE;
-    to_vict = "You feel invulnerable!";
-    break;
-
-  case SPELL_SANCTUARY:
-    af[0].duration = 4;
-    SET_BIT_AR(af[0].bitvector, AFF_SANCTUARY);
-
-    accum_duration = TRUE;
-    to_vict = "A white aura momentarily surrounds you.";
-    to_room = "$n is surrounded by a white aura.";
-    break;
-
-  case SPELL_SLEEP:
-    if (!CONFIG_PK_ALLOWED && !IS_NPC(ch) && !IS_NPC(victim))
-      return;
-    if (MOB_FLAGGED(victim, MOB_NOSLEEP))
-      return;
-    if (mag_savingthrow(victim, savetype, 0))
-      return;
-
-    af[0].duration = 4 + (GET_LEVEL(ch) / 4);
-    SET_BIT_AR(af[0].bitvector, AFF_SLEEP);
-
-    if (GET_POS(victim) > POS_SLEEPING) {
-      send_to_char(victim, "You feel very sleepy...  Zzzz......\r\n");
-      act("$n goes to sleep.", TRUE, victim, 0, 0, TO_ROOM);
-      GET_POS(victim) = POS_SLEEPING;
-    }
-    break;
-
-  case SPELL_STRENGTH:
-    if (GET_ADD(victim) == 100)
-      return;
-
-    af[0].location = APPLY_STR;
-    af[0].duration = (GET_LEVEL(ch) / 2) + 4;
-    af[0].modifier = 1 + (level > 18);
-    accum_duration = TRUE;
-    accum_affect = TRUE;
-    to_vict = "You feel stronger!";
-    break;
+    if (spell->mag_flags & MAG_ACCDUR)
+      accum_duration = TRUE;
 
-  case SPELL_SENSE_LIFE:
-    to_vict = "Your feel your awareness improve.";
-    af[0].duration = GET_LEVEL(ch);
-    SET_BIT_AR(af[0].bitvector, AFF_SENSE_LIFE);
-    accum_duration = TRUE;
-    break;
+    if (spell->mag_flags & MAG_ACCMOD)
+      accum_affect = TRUE;
 
-  case SPELL_WATERWALK:
-    af[0].duration = 24;
-    SET_BIT_AR(af[0].bitvector, AFF_WATERWALK);
-    accum_duration = TRUE;
-    to_vict = "You feel webbing between your toes.";
-    break;
-  }
+    // specials spells that formula interpreter can't deal with:
+    switch (spellnum) {
+      case SPELL_CHILL_TOUCH: if (mag_savingthrow(victim, savetype, 0))
+                                af[i].duration = 1;
+                              break;
+      case SPELL_BLINDNESS:   if (MOB_FLAGGED(victim, MOB_NOBLIND) || GET_LEVEL(victim) >= LVL_IMMORT ||
+                                  mag_savingthrow(victim, savetype, 0)) {
+                                return MAGIC_FAILED;
+                              }
+                              break;
+      case SPELL_CURSE:       if (mag_savingthrow(victim, savetype, 0)) {
+                                return MAGIC_FAILED;
+                              }
+                              break;
+      case SPELL_INVISIBLE:   if (!victim)
+                                victim = ch;
+                              break;
+      case SPELL_POISON:      if (mag_savingthrow(victim, savetype, 0)) {
+                                return MAGIC_FAILED;
+                              }
+                              break;
+      case SPELL_SLEEP:       if (!CONFIG_PK_ALLOWED && !IS_NPC(ch) && !IS_NPC(victim))
+                                return MAGIC_FAILED;
+                              if (MOB_FLAGGED(victim, MOB_NOSLEEP))
+                                return MAGIC_FAILED;
+                              if (mag_savingthrow(victim, savetype, 0))
+                                return MAGIC_FAILED;
+
+                              if (GET_POS(victim) > POS_SLEEPING) {
+                                effect++;
+                                GET_POS(victim) = POS_SLEEPING;
+                              }
+                              break;
+      case SPELL_STRENGTH:    if (GET_ADD(victim) == 100)
+                                return MAGIC_NOEFFECT;
+   }
+ }
 
   /* If this is a mob that has this affect set in its mob file, do not perform
    * the affect.  This prevents people from un-sancting mobs by sancting them
@@ -523,49 +340,82 @@
   if (IS_NPC(victim) && !affected_by_spell(victim, spellnum)) {
     for (i = 0; i < MAX_SPELL_AFFECTS; i++) {
       for (j=1; j<NUM_AFF_FLAGS; j++) {
-        if (IS_SET_AR(af[i].bitvector, j) && AFF_FLAGGED(victim, j)) {
-          send_to_char(ch, "%s", CONFIG_NOEFFECT);
-          return;
-        }
+        if (IS_SET_AR(af[i].bitvector, j) && AFF_FLAGGED(victim, j))
+          return MAGIC_NOEFFECT;
       }
     }
   }
 
   /* If the victim is already affected by this spell, and the spell does not
    * have an accumulative effect, then fail the spell. */
-  if (affected_by_spell(victim,spellnum) && !(accum_duration||accum_affect)) {
-    send_to_char(ch, "%s", CONFIG_NOEFFECT);
-    return;
-  }
+  if (affected_by_spell(victim,spellnum) && !(accum_duration||accum_affect))
+    return MAGIC_NOEFFECT;
 
   for (i = 0; i < MAX_SPELL_AFFECTS; i++)
     if (af[i].bitvector[0] || af[i].bitvector[1] ||
         af[i].bitvector[2] || af[i].bitvector[3] ||
-        (af[i].location != APPLY_NONE))
+        (af[i].location != APPLY_NONE)) {
       affect_join(victim, af+i, accum_duration, FALSE, accum_affect, FALSE);
+      effect++;
+    }
+
+  if (effect)
+    return MAGIC_SUCCESS;
+  else
+    return MAGIC_NOEFFECT;
+}
 
-  if (to_vict != NULL)
-    act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
-  if (to_room != NULL)
-    act(to_room, TRUE, victim, 0, ch, TO_ROOM);
+int mag_protections(int level, struct char_data *ch, struct char_data *tch, 
+                    int spellnum, int spellprot, int dur, int res)
+{
+  struct str_spells *spell;
+  struct affected_type af;
+  int accum_duration = FALSE;
+
+  if (tch == NULL || ch == NULL)
+    return MAGIC_FAILED;
+
+  spell = get_spell_by_vnum(spellnum);
+
+  if (!spell) {
+    log("SYSERR: unknown spellnum %d passed to mag_affects.", spellnum);
+    return MAGIC_FAILED;
+  }
+          
+  if (spell->mag_flags & MAG_ACCDUR)
+    accum_duration = TRUE;
+  new_affect(&af);
+  SET_BIT_AR(af.bitvector, AFF_PROTECT);
+  af.spell = spellnum;
+  af.location = spellprot;
+  af.modifier = res;
+  af.duration = dur;
+
+  affect_join(tch, &af, accum_duration, FALSE, FALSE, FALSE);
+  return MAGIC_SUCCESS;
 }
 
 /* This function is used to provide services to mag_groups.  This function is
  * the one you should change to add new group spells. */
-static void perform_mag_groups(int level, struct char_data *ch,
-			struct char_data *tch, int spellnum, int savetype)
+static int perform_mag_groups(int level, struct char_data *ch,
+	                      struct char_data *tch, int spellnum, int savetype)
 {
+  int flags = 0;
+
   switch (spellnum) {
     case SPELL_GROUP_HEAL:
-    mag_points(level, ch, tch, SPELL_HEAL, savetype);
+    flags = mag_points(level, ch, tch, SPELL_HEAL, savetype);
     break;
   case SPELL_GROUP_ARMOR:
-    mag_affects(level, ch, tch, SPELL_ARMOR, savetype);
+    flags = mag_affects(level, ch, tch, SPELL_ARMOR, savetype);
     break;
   case SPELL_GROUP_RECALL:
     spell_recall(level, ch, tch, NULL);
+    flags = MAGIC_SUCCESS;
     break;
   }
+
+  return flags;
 }
 
 /* Every spell that affects the group should run through here perform_mag_groups
@@ -573,30 +423,40 @@
  * affect everyone grouped with the caster who is in the room, caster last. To
  * add new group spells, you shouldn't have to change anything in mag_groups.
  * Just add a new case to perform_mag_groups. */
-void mag_groups(int level, struct char_data *ch, int spellnum, int savetype)
+int mag_groups(int level, struct char_data *ch, int spellnum, int savetype)
 {
+  int ret_flags = 0;
+
   struct char_data *tch;
 
   if (ch == NULL)
-    return;
+    return MAGIC_FAILED;
 
   if (!GROUP(ch))
-    return;
+    return MAGIC_FAILED;
     
   while ((tch = (struct char_data *) simple_list(GROUP(ch)->members)) != NULL) {
     if (IN_ROOM(tch) != IN_ROOM(ch))
       continue;
     if (tch == ch)
       continue;
-    perform_mag_groups(level, ch, tch, spellnum, savetype);
+    ret_flags |= perform_mag_groups(level, ch, tch, spellnum, savetype);
   }
-  perform_mag_groups(level, ch, ch, spellnum, savetype);
+  ret_flags |= perform_mag_groups(level, ch, ch, spellnum, savetype);
+
+  if (ret_flags & MAGIC_SUCCESS)
+    return MAGIC_SUCCESS;
+
+  if (ret_flags == MAGIC_FAILED)
+    return MAGIC_FAILED;
+
+  return MAGIC_NOEFFECT;
 }
 
 
 /* Mass spells affect every creature in the room except the caster. No spells
  * of this class currently implemented. */
-void mag_masses(int level, struct char_data *ch, int spellnum, int savetype)
+int mag_masses(int level, struct char_data *ch, int spellnum, int savetype)
 {
   struct char_data *tch, *tch_next;
 
@@ -608,34 +468,25 @@
     switch (spellnum) {
     }
   }
+
+  // return NOEFFECT for now since mag_masses doesn't support any spells yet.
+  return MAGIC_NOEFFECT;
 }
 
 /* Every spell that affects an area (room) runs through here.  These are
  * generally offensive spells.  This calls mag_damage to do the actual damage.
  * All spells listed here must also have a case in mag_damage() in order for
  * them to work. Area spells have limited targets within the room. */
-void mag_areas(int level, struct char_data *ch, int spellnum, int savetype)
+int mag_areas(int level, struct char_data *ch, int spellnum, int savetype)
 {
   struct char_data *tch, *next_tch;
-  const char *to_char = NULL, *to_room = NULL;
+  struct str_spells *spell;
+  int effect = 0;
 
   if (ch == NULL)
-    return;
-
-  /* to add spells just add the message here plus an entry in mag_damage for
-   * the damaging part of the spell.   */
-  switch (spellnum) {
-  case SPELL_EARTHQUAKE:
-    to_char = "You gesture and the earth begins to shake all around you!";
-    to_room ="$n gracefully gestures and the earth begins to shake violently!";
-    break;
-  }
-
-  if (to_char != NULL)
-    act(to_char, FALSE, ch, 0, 0, TO_CHAR);
-  if (to_room != NULL)
-    act(to_room, FALSE, ch, 0, 0, TO_ROOM);
+    return MAGIC_FAILED;
 
+  spell = get_spell_by_vnum(spellnum);
 
   for (tch = world[IN_ROOM(ch)].people; tch; tch = next_tch) {
     next_tch = tch->next_in_room;
@@ -654,37 +505,25 @@
       continue;
     if (!IS_NPC(ch) && IS_NPC(tch) && AFF_FLAGGED(tch, AFF_CHARM))
       continue;
-    if (!IS_NPC(tch) && spell_info[spellnum].violent && GROUP(tch) && GROUP(ch) && GROUP(ch) == GROUP(tch))
+    if (!IS_NPC(tch) && (spell->mag_flags & MAG_VIOLENT) && GROUP(tch) && GROUP(ch) && GROUP(ch) == GROUP(tch))
       continue;
 	if ((spellnum == SPELL_EARTHQUAKE) && AFF_FLAGGED(tch, AFF_FLYING))
 	  continue;
     /* Doesn't matter if they die here so we don't check. -gg 6/24/98 */
+    effect++;
     mag_damage(level, ch, tch, spellnum, 1);
   }
+
+  if (effect) 
+    return MAGIC_SUCCESS;
+  else
+    return MAGIC_NOEFFECT;
 }
 
 /*----------------------------------------------------------------------------*/
 /* Begin Magic Summoning - Generic Routines and Local Globals */
 /*----------------------------------------------------------------------------*/
 
-/* Every spell which summons/gates/conjours a mob comes through here. */
-/* These use act(), don't put the \r\n. */
-static const char *mag_summon_msgs[] = {
-  "\r\n",
-  "$n makes a strange magical gesture; you feel a strong breeze!",
-  "$n animates a corpse!",
-  "$N appears from a cloud of thick blue smoke!",
-  "$N appears from a cloud of thick green smoke!",
-  "$N appears from a cloud of thick red smoke!",
-  "$N disappears in a thick black cloud!"
-  "As $n makes a strange magical gesture, you feel a strong breeze.",
-  "As $n makes a strange magical gesture, you feel a searing heat.",
-  "As $n makes a strange magical gesture, you feel a sudden chill.",
-  "As $n makes a strange magical gesture, you feel the dust swirl.",
-  "$n magically divides!",
-  "$n animates a corpse!"
-};
-
 /* Keep the \r\n because these use send_to_char. */
 static const char *mag_summon_fail_msgs[] = {
   "\r\n",
@@ -697,87 +536,96 @@
   "There is no corpse!\r\n"
 };
 
-/* Defines for Mag_Summons */
-#define MOB_CLONE            10   /**< vnum for the clone mob. */
-#define OBJ_CLONE            161  /**< vnum for clone material. */
-#define MOB_ZOMBIE           11   /**< vnum for the zombie mob. */
-
-void mag_summons(int level, struct char_data *ch, struct obj_data *obj,
+int mag_summons(int level, struct char_data *ch, struct obj_data *obj,
 		      int spellnum, int savetype)
 {
   struct char_data *mob = NULL;
   struct obj_data *tobj, *next_obj;
-  int pfail = 0, msg = 0, fmsg = 0, num = 1, handle_corpse = FALSE, i;
+  int pfail = 0, fmsg = 0, handle_corpse = FALSE;
   mob_vnum mob_num;
+  obj_vnum obj_num;
+  struct str_spells *spell;
+  int rts_code;
 
   if (ch == NULL)
-    return;
+    return MAGIC_FAILED;
 
-  switch (spellnum) {
-  case SPELL_CLONE:
-    msg = 10;
-    fmsg = rand_number(2, 6);	/* Random fail message. */
-    mob_num = MOB_CLONE;
-    /*
-     * We have designated the clone spell as the example for how to use the
-     * mag_materials function.
-     * In stock tbaMUD it checks to see if the character has item with
-     * vnum 161 which is a set of sacrificial entrails. If we have the entrails
-     * the spell will succeed,  and if not, the spell will fail 102% of the time
-     * (prevents random success... see below).
-     * The object is extracted and the generic cast messages are displayed.
-     */
-    if( !mag_materials(ch, OBJ_CLONE, NOTHING, NOTHING, TRUE, TRUE) )
-      pfail = 102; /* No materials, spell fails. */
-    else
-      pfail = 0;	/* We have the entrails, spell is successfully cast. */
-    break;
+  spell = get_spell_by_vnum(spellnum);
+
+  if (!spell) {
+    log("SYSERR: unknown spellnum %d passed to mag_summons.", spellnum);
+    return MAGIC_FAILED;
+  }
 
-  case SPELL_ANIMATE_DEAD:
+  if (spellnum == SPELL_ANIMATE_DEAD) {
     if (obj == NULL || !IS_CORPSE(obj)) {
       act(mag_summon_fail_msgs[7], FALSE, ch, 0, 0, TO_CHAR);
-      return;
+      return MAGIC_FAILED;
     }
     handle_corpse = TRUE;
-    msg = 11;
-    fmsg = rand_number(2, 6);	/* Random fail message. */
-    mob_num = MOB_ZOMBIE;
-    pfail = 10;	/* 10% failure, should vary in the future. */
-    break;
-
-  default:
-    return;
   }
 
+  fmsg = rand_number(2, 6);	/* Random fail message. */
+  if (spell->summon_mob) {
+    mob_num = MAX(0, formula_interpreter (ch, ch, spellnum, TRUE, spell->summon_mob, level, &rts_code));
+
+    // mob_num is unsigned, it won't catch negative value from formula_interpreter.
+    // I'm using MAX(0, formula), and consider 0 illegal.
+    if (mob_num == 0) {
+      log("SYSERR: Illegal mobile to summon at mag_summons.");
+      return MAGIC_FAILED;
+    }
+  }
+  else {
+    log("SYSERR: No mobile to summon at mag_summons.");
+    return MAGIC_FAILED;
+  }
+
+  if (spell->summon_req) {
+    pfail = 0;
+    obj_num = MAX(0, formula_interpreter (ch, ch, spellnum, TRUE, spell->summon_req, level, &rts_code));
+
+    // same as mob_num.
+    if (obj_num == 0) {
+      log("SYSERR: Illegal object required to summon at mag_summons.");
+      pfail = 102;
+    } else
+        if (!mag_materials(ch, obj_num, NOTHING, NOTHING, TRUE, TRUE))
+          pfail = 102;
+  } else
+      pfail = 10; /* 10% failure, should vary in the future. */ 
+
   if (AFF_FLAGGED(ch, AFF_CHARM)) {
     send_to_char(ch, "You are too giddy to have any followers!\r\n");
-    return;
+    return MAGIC_NOEFFECT;
   }
+
   if (rand_number(0, 101) < pfail) {
     send_to_char(ch, "%s", mag_summon_fail_msgs[fmsg]);
-    return;
+    return MAGIC_NOEFFECT; // since we send a special fail message, return NOEFFECT makes more sens.
   }
-  for (i = 0; i < num; i++) {
-    if (!(mob = read_mobile(mob_num, VIRTUAL))) {
-      send_to_char(ch, "You don't quite remember how to make that creature.\r\n");
-      return;
-    }
-    char_to_room(mob, IN_ROOM(ch));
-    IS_CARRYING_W(mob) = 0;
-    IS_CARRYING_N(mob) = 0;
-    SET_BIT_AR(AFF_FLAGS(mob), AFF_CHARM);
-    if (spellnum == SPELL_CLONE) {
-      /* Don't mess up the prototype; use new string copies. */
-      mob->player.name = strdup(GET_NAME(ch));
-      mob->player.short_descr = strdup(GET_NAME(ch));
-    }
-    act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
-    load_mtrigger(mob);
-    add_follower(mob, ch);
-    
-    if (GROUP(ch) && GROUP_LEADER(GROUP(ch)) == ch)
-      join_group(mob, GROUP(ch));    
+
+  if (!(mob = read_mobile(mob_num, VIRTUAL))) {
+    send_to_char(ch, "You don't quite remember how to make that creature.\r\n");
+    return MAGIC_NOEFFECT;
+  }
+  char_to_room(mob, IN_ROOM(ch));
+  IS_CARRYING_W(mob) = 0;
+  IS_CARRYING_N(mob) = 0;
+  SET_BIT_AR(AFF_FLAGS(mob), AFF_CHARM);
+
+  if (spellnum == SPELL_CLONE) {
+    /* Don't mess up the prototype; use new string copies. */
+    mob->player.name = strdup(GET_NAME(ch));
+    mob->player.short_descr = strdup(GET_NAME(ch));
   }
+
+  load_mtrigger(mob);
+  add_follower(mob, ch);
+    
+  if (GROUP(ch) && GROUP_LEADER(GROUP(ch)) == ch)
+    join_group(mob, GROUP(ch));    
+
   if (handle_corpse) {
     for (tobj = obj->contains; tobj; tobj = next_obj) {
       next_obj = tobj->next_content;
@@ -786,106 +634,117 @@
     }
     extract_obj(obj);
   }
+  return MAGIC_SUCCESS;
 }
 
-/* Clean up the defines used for mag_summons. */
-#undef MOB_CLONE
-#undef OBJ_CLONE
-#undef MOB_ZOMBIE
-
 /*----------------------------------------------------------------------------*/
 /* End Magic Summoning - Generic Routines and Local Globals */
 /*----------------------------------------------------------------------------*/
 
 
-void mag_points(int level, struct char_data *ch, struct char_data *victim,
-		     int spellnum, int savetype)
+int mag_points(int level, struct char_data *ch, struct char_data *victim,
+               int spellnum, int savetype)
 {
-  int healing = 0, move = 0;
+  struct str_spells *spell;
+
+  int hp, mana, move, gold, rts_code, effect = 0;;
 
   if (victim == NULL)
-    return;
+    return MAGIC_FAILED;
 
-  switch (spellnum) {
-  case SPELL_CURE_LIGHT:
-    healing = dice(1, 8) + 1 + (level / 4);
-    send_to_char(victim, "You feel better.\r\n");
-    break;
-  case SPELL_CURE_CRITIC:
-    healing = dice(3, 8) + 3 + (level / 4);
-    send_to_char(victim, "You feel a lot better!\r\n");
-    break;
-  case SPELL_HEAL:
-    healing = 100 + dice(3, 8);
-    send_to_char(victim, "A warm feeling floods your body.\r\n");
-    break;
+  spell = get_spell_by_vnum(spellnum);
+
+  if (!spell) {
+    log("SYSERR: unknown spellnum %d passed to mag_points.", spellnum);
+    return MAGIC_FAILED;
+  }
+
+  if (spell->points.hp) {
+    hp = formula_interpreter (ch, victim, spellnum, TRUE, spell->points.hp, level, &rts_code);
+    GET_HIT(victim) = MIN(GET_MAX_HIT(victim), MAX(1, GET_HIT(victim) + hp));
+    effect++;
+  }
+
+  if (spell->points.mana) {
+    mana = formula_interpreter (ch, victim, spellnum, TRUE, spell->points.mana, level, &rts_code);
+    GET_MANA(victim) = MIN(GET_MAX_MANA(victim), MAX(0, GET_MANA(victim) + mana));
+    effect++;
   }
-  GET_HIT(victim) = MIN(GET_MAX_HIT(victim), GET_HIT(victim) + healing);
-  GET_MOVE(victim) = MIN(GET_MAX_MOVE(victim), GET_MOVE(victim) + move);
+
+  if (spell->points.move) {
+    move = formula_interpreter (ch, victim, spellnum, TRUE, spell->points.move, level, &rts_code);
+    GET_MOVE(victim) = MIN(GET_MAX_MOVE(victim), MAX(0, GET_MOVE(victim) + move));
+    effect++;
+  }
+
+  if (spell->points.gold) {
+    gold = formula_interpreter (ch, victim, spellnum, TRUE, spell->points.gold, level, &rts_code);
+    GET_GOLD(victim) = MAX(0, GET_GOLD(victim) + gold);
+    effect++;
+  }
+
   update_pos(victim);
+  if (effect)
+    return MAGIC_SUCCESS;
+  else
+    return MAGIC_NOEFFECT;
 }
 
-void mag_unaffects(int level, struct char_data *ch, struct char_data *victim,
+int mag_unaffects(int level, struct char_data *ch, struct char_data *victim,
 		        int spellnum, int type)
 {
-  int spell = 0, msg_not_affected = TRUE;
-  const char *to_vict = NULL, *to_room = NULL;
+  int i, dispel = 0, effect = 0, rts_code;
+  struct str_spells *spell;
 
   if (victim == NULL)
-    return;
+    return MAGIC_FAILED;
 
-  switch (spellnum) {
-  case SPELL_HEAL:
-    /* Heal also restores health, so don't give the "no effect" message if the
-     * target isn't afflicted by the 'blindness' spell. */
-    msg_not_affected = FALSE;
-    /* fall-through */
-  case SPELL_CURE_BLIND:
-    spell = SPELL_BLINDNESS;
-    to_vict = "Your vision returns!";
-    to_room = "There's a momentary gleam in $n's eyes.";
-    break;
-  case SPELL_REMOVE_POISON:
-    spell = SPELL_POISON;
-    to_vict = "A warm feeling runs through your body!";
-    to_room = "$n looks better.";
-    break;
-  case SPELL_REMOVE_CURSE:
-    spell = SPELL_CURSE;
-    to_vict = "You don't feel so unlucky.";
-    break;
-  default:
+  spell = get_spell_by_vnum(spellnum);
+  if (!spell) {
     log("SYSERR: unknown spellnum %d passed to mag_unaffects.", spellnum);
-    return;
-  }
+    return MAGIC_FAILED;
+  } 
 
-  if (!affected_by_spell(victim, spell)) {
-    if (msg_not_affected)
-      send_to_char(ch, "%s", CONFIG_NOEFFECT);
-    return;
+  // complementary messages for the spell HEAL.
+  if ((spellnum == SPELL_HEAL) && (affected_by_spell(victim, SPELL_BLINDNESS))) {
+    act("Your vision returns!", FALSE, victim, 0, ch, TO_CHAR);
+    act("There's a momentary gleam in $n's eyes.", TRUE, victim, 0, ch, TO_ROOM);
+  } 
+
+  for (i=0; i<MAX_SPELL_DISPEL; i++) {
+    if (spell->dispel[i]) 
+      dispel = formula_interpreter (ch, victim, spellnum, TRUE, spell->dispel[i], level, &rts_code);
+    else
+      continue;
+
+    if (dispel <= 0) 
+      log("SYSERR: Invalid dispel spell vnum: %d", dispel);
+    else
+      if (affected_by_spell(victim, dispel)) { 
+        effect++;
+        affect_from_char(victim, dispel);
+      }
   }
 
-  affect_from_char(victim, spell);
-  if (to_vict != NULL)
-    act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
-  if (to_room != NULL)
-    act(to_room, TRUE, victim, 0, ch, TO_ROOM);
+  if (effect)
+    return MAGIC_SUCCESS;
+  else
+    return MAGIC_NOEFFECT;
 }
 
-void mag_alter_objs(int level, struct char_data *ch, struct obj_data *obj,
+int mag_alter_objs(int level, struct char_data *ch, struct obj_data *obj,
 		         int spellnum, int savetype)
 {
-  const char *to_char = NULL, *to_room = NULL;
+  int effect = 1;
 
   if (obj == NULL)
-    return;
+    return MAGIC_FAILED;
 
   switch (spellnum) {
     case SPELL_BLESS:
       if (!OBJ_FLAGGED(obj, ITEM_BLESS) &&
 	  (GET_OBJ_WEIGHT(obj) <= 5 * GET_LEVEL(ch))) {
 	SET_BIT_AR(GET_OBJ_EXTRA(obj), ITEM_BLESS);
-	to_char = "$p glows briefly.";
       }
       break;
     case SPELL_CURSE:
@@ -893,21 +752,18 @@
 	SET_BIT_AR(GET_OBJ_EXTRA(obj), ITEM_NODROP);
 	if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
 	  GET_OBJ_VAL(obj, 2)--;
-	to_char = "$p briefly glows red.";
       }
       break;
     case SPELL_INVISIBLE:
       if (!OBJ_FLAGGED(obj, ITEM_NOINVIS) && !OBJ_FLAGGED(obj, ITEM_INVISIBLE)) {
         SET_BIT_AR(GET_OBJ_EXTRA(obj), ITEM_INVISIBLE);
-        to_char = "$p vanishes.";
       }
       break;
     case SPELL_POISON:
       if (((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) ||
          (GET_OBJ_TYPE(obj) == ITEM_FOUNTAIN) ||
          (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && !GET_OBJ_VAL(obj, 3)) {
-      GET_OBJ_VAL(obj, 3) = 1;
-      to_char = "$p steams briefly.";
+        GET_OBJ_VAL(obj, 3) = 1;
       }
       break;
     case SPELL_REMOVE_CURSE:
@@ -915,7 +771,6 @@
         REMOVE_BIT_AR(GET_OBJ_EXTRA(obj), ITEM_NODROP);
         if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
           GET_OBJ_VAL(obj, 2)++;
-        to_char = "$p briefly glows blue.";
       }
       break;
     case SPELL_REMOVE_POISON:
@@ -923,60 +778,70 @@
          (GET_OBJ_TYPE(obj) == ITEM_FOUNTAIN) ||
          (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && GET_OBJ_VAL(obj, 3)) {
         GET_OBJ_VAL(obj, 3) = 0;
-        to_char = "$p steams briefly.";
       }
       break;
+    default: effect = 0;
   }
 
-  if (to_char == NULL)
-    send_to_char(ch, "%s", CONFIG_NOEFFECT);
+  if (effect)
+    return MAGIC_SUCCESS;
   else
-    act(to_char, TRUE, ch, obj, 0, TO_CHAR);
-
-  if (to_room != NULL)
-    act(to_room, TRUE, ch, obj, 0, TO_ROOM);
-  else if (to_char != NULL)
-    act(to_char, TRUE, ch, obj, 0, TO_ROOM);
+    return MAGIC_NOEFFECT;
 }
 
-void mag_creations(int level, struct char_data *ch, int spellnum)
+int mag_creations(int level, struct char_data *ch, int spellnum)
 {
   struct obj_data *tobj;
+  struct str_spells *spell;
   obj_vnum z;
+  int i, rts_code, effect = 0, goofed = 0;
 
   if (ch == NULL)
-    return;
-  /* level = MAX(MIN(level, LVL_IMPL), 1); - Hm, not used. */
+    return MAGIC_FAILED;
 
-  switch (spellnum) {
-  case SPELL_CREATE_FOOD:
-    z = 10;
-    break;
-  default:
-    send_to_char(ch, "Spell unimplemented, it would seem.\r\n");
-    return;
-  }
+  spell = get_spell_by_vnum(spellnum);
 
-  if (!(tobj = read_object(z, VIRTUAL))) {
-    send_to_char(ch, "I seem to have goofed.\r\n");
-    log("SYSERR: spell_creations, spell %d, obj %d: obj not found",
-	    spellnum, z);
-    return;
-  }
-  obj_to_char(tobj, ch);
-  act("$n creates $p.", FALSE, ch, tobj, 0, TO_ROOM);
-  act("You create $p.", FALSE, ch, tobj, 0, TO_CHAR);
-  load_otrigger(tobj);
+  if (!spell) {
+    log("SYSERR: spell_creations, spell %d not found", spellnum);
+    return MAGIC_FAILED; 
+  }
+
+  for (i=0; i<MAX_SPELL_OBJECTS; i++) {
+    if (spell->objects[i]) {
+      z = MAX(0, formula_interpreter (ch, ch, spellnum, TRUE, spell->objects[i], level, &rts_code));
+
+      if (!rts_code && z) {
+        if (!(tobj = read_object(z, VIRTUAL))) {
+          goofed = 1;
+          log("SYSERR: spell_creations, spell %d, obj %d: obj not found", spellnum, z);
+        } else {
+            obj_to_char(tobj, ch);
+            act("$n creates $p.", FALSE, ch, tobj, 0, TO_ROOM);
+            act("You create $p.", FALSE, ch, tobj, 0, TO_CHAR);
+            load_otrigger(tobj);
+            effect++;
+          }
+      }  else
+           log("SYSERR: spell_creations, formula interpreter failed on spell %d", spellnum);
+    }
+  }
+   
+  // special message, if object(s) creation failed.
+  if (goofed)
+    send_to_char(ch, "I seem to have %sgoofed.\r\n", effect ? "a little " : "");
+
+  if (effect)
+    return MAGIC_SUCCESS;
+  else
+    return MAGIC_NOEFFECT;
 }
 
-void mag_rooms(int level, struct char_data *ch, int spellnum)
+int mag_rooms(int level, struct char_data *ch, int spellnum)
 {
   room_rnum rnum;
   int duration = 0;
   bool failure = FALSE;
   event_id IdNum = eNULL;
-  const char *msg = NULL;
-  const char *room = NULL;
   
   rnum = IN_ROOM(ch);
   
@@ -991,20 +856,14 @@
         
       duration = 5;
       SET_BIT_AR(ROOM_FLAGS(rnum), ROOM_DARK);
-        
-      msg = "You cast a shroud of darkness upon the area.";
-      room = "$n casts a shroud of darkness upon this area.";
     break;
   
   }
   
-  if (failure || IdNum == eNULL) {
-    send_to_char(ch, "You failed!\r\n");
-    return;
-  }
-  
-  send_to_char(ch, "%s\r\n", msg);
-  act(room, FALSE, ch, 0, 0, TO_ROOM);
+  if (failure || IdNum == eNULL)
+    return MAGIC_FAILED;
   
   NEW_EVENT(eSPL_DARKNESS, &world[rnum], NULL, duration * PASSES_PER_SEC);
+
+  return MAGIC_SUCCESS;
 }
diff -uN ./orig/Makefile ./Makefile
--- ./orig/Makefile	2020-02-25 19:18:51.522369247 -0500
+++ ./Makefile	2020-02-25 19:19:09.945725507 -0500
@@ -21,8 +21,8 @@
 
 LIBS =  -lcrypt 
 
-SRCFILES := act.comm.c act.informative.c act.item.c act.movement.c act.offensive.c act.other.c act.social.c act.wizard.c aedit.c asciimap.c ban.c boards.c bsd-snprintf.c castle.c cedit.c class.c comm.c config.c constants.c db.c dg_comm.c dg_db_scripts.c dg_event.c dg_handler.c dg_misc.c dg_mobcmd.c dg_objcmd.c dg_olc.c dg_scripts.c dg_triggers.c dg_variables.c dg_wldcmd.c fight.c genmob.c genobj.c genolc.c genqst.c genshp.c genwld.c genzon.c graph.c handler.c hedit.c house.c ibt.c improved-edit.c interpreter.c limits.c lists.c magic.c mail.c medit.c mobact.c modify.c msgedit.c mud_event.c oasis.c oasis_copy.c oasis_delete.c oasis_list.c objsave.c oedit.c players.c prefedit.c protocol.c qedit.c quest.c random.c redit.c sedit.c shop.c spec_assign.c spec_procs.c spell_parser.c spells.c tedit.c utils.c weather.c zedit.c zmalloc.c
-OBJFILES := act.comm.o act.informative.o act.item.o act.movement.o act.offensive.o act.other.o act.social.o act.wizard.o aedit.o asciimap.o ban.o boards.o bsd-snprintf.o castle.o cedit.o class.o comm.o config.o constants.o db.o dg_comm.o dg_db_scripts.o dg_event.o dg_handler.o dg_misc.o dg_mobcmd.o dg_objcmd.o dg_olc.o dg_scripts.o dg_triggers.o dg_variables.o dg_wldcmd.o fight.o genmob.o genobj.o genolc.o genqst.o genshp.o genwld.o genzon.o graph.o handler.o hedit.o house.o ibt.o improved-edit.o interpreter.o limits.o lists.o magic.o mail.o medit.o mobact.o modify.o msgedit.o mud_event.o oasis.o oasis_copy.o oasis_delete.o oasis_list.o objsave.o oedit.o players.o prefedit.o protocol.o qedit.o quest.o random.o redit.o sedit.o shop.o spec_assign.o spec_procs.o spell_parser.o spells.o tedit.o utils.o weather.o zedit.o zmalloc.o
+SRCFILES := act.comm.c act.informative.c act.item.c act.movement.c act.offensive.c act.other.c act.social.c act.wizard.c aedit.c asciimap.c ban.c boards.c bsd-snprintf.c castle.c cedit.c class.c comm.c config.c constants.c db.c dg_comm.c dg_db_scripts.c dg_event.c dg_handler.c dg_misc.c dg_mobcmd.c dg_objcmd.c dg_olc.c dg_scripts.c dg_triggers.c dg_variables.c dg_wldcmd.c fight.c formula.c genmob.c genobj.c genolc.c genqst.c genshp.c genwld.c genzon.c graph.c handler.c hedit.c house.c ibt.c improved-edit.c interpreter.c limits.c lists.c magic.c mail.c medit.c mobact.c modify.c msgedit.c mud_event.c oasis.c oasis_copy.c oasis_delete.c oasis_list.c objsave.c oedit.c players.c prefedit.c protocol.c qedit.c quest.c random.c redit.c sedit.c shop.c spec_assign.c spec_procs.c spedit.c spell_parser.c spells.c spells_assign.c spells_script.c tedit.c utils.c weather.c zedit.c zmalloc.c
+OBJFILES := act.comm.o act.informative.o act.item.o act.movement.o act.offensive.o act.other.o act.social.o act.wizard.o aedit.o asciimap.o ban.o boards.o bsd-snprintf.o castle.o cedit.o class.o comm.o config.o constants.o db.o dg_comm.o dg_db_scripts.o dg_event.o dg_handler.o dg_misc.o dg_mobcmd.o dg_objcmd.o dg_olc.o dg_scripts.o dg_triggers.o dg_variables.o dg_wldcmd.o fight.o formula.o genmob.o genobj.o genolc.o genqst.o genshp.o genwld.o genzon.o graph.o handler.o hedit.o house.o ibt.o improved-edit.o interpreter.o limits.o lists.o magic.o mail.o medit.o mobact.o modify.o msgedit.o mud_event.o oasis.o oasis_copy.o oasis_delete.o oasis_list.o objsave.o oedit.o players.o prefedit.o protocol.o qedit.o quest.o random.o redit.o sedit.o shop.o spec_assign.o spec_procs.o spedit.o spell_parser.o spells.o spells_assign.o spells_script.o tedit.o utils.o weather.o zedit.o zmalloc.o
 
 default: all
 
diff -uN ./orig/mobact.c ./mobact.c
--- ./orig/mobact.c	2020-02-25 19:18:51.522369247 -0500
+++ ./mobact.c	2020-02-25 19:19:09.945725507 -0500
@@ -148,13 +148,23 @@
       }
     }
 
+    /* Help your master */
+    if (AFF_FLAGGED(ch, AFF_CHARM) && ch->master) {
+      vict = FIGHTING(ch->master);
+      if (vict && vict != ch) {
+        act("$n jumps to the aid of $N!", FALSE, ch, 0, ch->master, TO_ROOM);
+        hit(ch, vict, TYPE_UNDEFINED);
+      }
+    }
+
     /* Helper Mobs */
-    if (MOB_FLAGGED(ch, MOB_HELPER) && (!AFF_FLAGGED(ch, AFF_BLIND) || !AFF_FLAGGED(ch, AFF_CHARM))) 
+    if (!FIGHTING(ch) && MOB_FLAGGED(ch, MOB_HELPER) && 
+       (!AFF_FLAGGED(ch, AFF_BLIND) || !AFF_FLAGGED(ch, AFF_CHARM))) 
     {
       found = FALSE;
       for (vict = world[IN_ROOM(ch)].people; vict && !found; vict = vict->next_in_room) 
       {
-	      if (ch == vict || !IS_NPC(vict) || !FIGHTING(vict))
+        if (ch == vict || !IS_NPC(vict) || !FIGHTING(vict))
           continue; 
         if (GROUP(vict) && GROUP(vict) == GROUP(ch))
           continue;
diff -uN ./orig/modify.c ./modify.c
--- ./orig/modify.c	2020-02-25 19:18:51.522369247 -0500
+++ ./modify.c	2020-02-25 19:19:09.945725507 -0500
@@ -26,6 +26,7 @@
 #include "modify.h"
 #include "quest.h"
 #include "ibt.h"
+#include "spedit.h"
 
 /* local (file scope) function prototpyes  */
 static char *next_page(char *str, struct char_data *ch);
@@ -176,6 +177,7 @@
         case CON_REDIT:
         case CON_MEDIT:
         case CON_OEDIT:
+        case CON_SPEDIT:
         case CON_PLR_DESC:
         case CON_TRIGEDIT:
         case CON_HEDIT:
@@ -222,6 +224,7 @@
       { CON_HEDIT, hedit_string_cleanup },
       { CON_QEDIT  , qedit_string_cleanup },
       { CON_IBTEDIT, ibtedit_string_cleanup },
+      { CON_SPEDIT, spedit_string_cleanup },
       { -1, NULL }
     };
 
@@ -307,9 +310,11 @@
 ACMD(do_skillset)
 {
   struct char_data *vict;
+  struct str_spells *spell;
   char name[MAX_INPUT_LENGTH];
   char buf[MAX_INPUT_LENGTH], helpbuf[MAX_STRING_LENGTH];
-  int skill, value, i, qend, pc, pl;
+  char *sname;
+  int value, i, qend, pc, pl;
 
   argument = one_argument(argument, name);
 
@@ -317,9 +322,10 @@
     send_to_char(ch, "Syntax: skillset <name> '<skill>' <value>\r\n"
 		"Skill being one of the following:\r\n");
     for (qend = 0, i = 0; i <= TOP_SPELL_DEFINE; i++) {
-      if (spell_info[i].name == unused_spellname)	/* This is valid. */
+      sname = get_spell_name(i);
+      if (sname == UNDEF_SPELL)	/* This is valid. */
 	continue;
-      send_to_char(ch, "%18s", spell_info[i].name);
+      send_to_char(ch, "%18s", sname);
       if (qend++ % 4 == 3)
 	send_to_char(ch, "\r\n");
     }
@@ -356,10 +362,14 @@
   }
   strcpy(helpbuf, (argument + 1));	/* strcpy: OK (MAX_INPUT_LENGTH <= MAX_STRING_LENGTH) */
   helpbuf[qend - 1] = '\0';
-  if ((skill = find_skill_num(helpbuf)) <= 0) {
+
+  spell = get_spell_by_name(helpbuf, SPSK);
+  if (!spell) {
     send_to_char(ch, "Unrecognized skill.\r\n");
     return;
-  }
+  } else
+      sname = spell->name;
+
   argument += qend + 1;		/* skip to next parameter */
   argument = one_argument(argument, buf);
 
@@ -379,20 +389,27 @@
   if (IS_NPC(vict)) {
     send_to_char(ch, "You can't set NPC skills.\r\n");
     return;
+  } 
+
+  int minlevel = get_spell_level(spell->vnum, pc); 
+
+  // -1 means not found. not assigned to this class.
+  if (minlevel == -1) {
+    send_to_char(ch, "%s cannot be learned in class %s.\r\n", sname, pc_class_types[pc]);
+    return;
   }
-  if ((spell_info[skill].min_level[(pc)] >= LVL_IMMORT) && (pl < LVL_IMMORT)) {
-    send_to_char(ch, "%s cannot be learned by mortals.\r\n", spell_info[skill].name);
+  if ((minlevel >= LVL_IMMORT) && (pl < LVL_IMMORT)) {
+    send_to_char(ch, "%s cannot be learned by mortals.\r\n", sname);
     return;
-  } else if (spell_info[skill].min_level[(pc)] > pl) {
+  } else if (minlevel > pl) {
     send_to_char(ch, "%s is a level %d %s.\r\n", GET_NAME(vict), pl, pc_class_types[pc]);
-    send_to_char(ch, "The minimum level for %s is %d for %ss.\r\n", spell_info[skill].name, spell_info[skill].min_level[(pc)], pc_class_types[pc]);
+    send_to_char(ch, "The minimum level for %s is %d for %ss.\r\n", sname, minlevel, pc_class_types[pc]);
+    return;
   }
 
-  /* find_skill_num() guarantees a valid spell_info[] index, or -1, and we
-   * checked for the -1 above so we are safe here. */
-  SET_SKILL(vict, skill, value);
-  mudlog(BRF, LVL_IMMORT, TRUE, "%s changed %s's %s to %d.", GET_NAME(ch), GET_NAME(vict), spell_info[skill].name, value);
-  send_to_char(ch, "You change %s's %s to %d.\r\n", GET_NAME(vict), spell_info[skill].name, value);
+  SET_SKILL(vict, spell->vnum, value);
+  mudlog(BRF, LVL_IMMORT, TRUE, "%s changed %s's %s to %d.", GET_NAME(ch), GET_NAME(vict), sname, value);
+  send_to_char(ch, "You change %s's %s to %d.\r\n", GET_NAME(vict), sname, value);
 }
 
 /* By Michael Buselli. Traverse down the string until the begining of the next
diff -uN ./orig/msgedit.c ./msgedit.c
--- ./orig/msgedit.c	2020-02-25 19:18:51.522369247 -0500
+++ ./msgedit.c	2020-02-25 19:19:09.945725507 -0500
@@ -18,6 +18,7 @@
 #include "genolc.h"
 #include "interpreter.h"
 #include "modify.h"
+#include "spedit.h"
 
 /* Statics */
 static void free_messages_type(struct msg_type *msg);
@@ -160,9 +161,9 @@
   for (i = 0; i < MAX_MESSAGES / 2; i++, half++)
     if (fight_messages[i].msg != NULL && len < sizeof(buf)) {
       count += fight_messages[i].number_of_attacks;
-      len += snprintf(buf + len, sizeof(buf) - len, "%-2d) [%-3d] %d, %-18s%s", i, fight_messages[i].a_type, fight_messages[i].number_of_attacks, fight_messages[i].a_type < TOP_SPELL_DEFINE ? spell_info[fight_messages[i].a_type].name : "Unknown", half < MAX_MESSAGES && fight_messages[half].msg ? "   " : "\r\n");
+      len += snprintf(buf + len, sizeof(buf) - len, "%-2d) [%-3d] %d, %-18s%s", i, fight_messages[i].a_type, fight_messages[i].number_of_attacks, get_spell_name(fight_messages[i].a_type), half < MAX_MESSAGES && fight_messages[half].msg ? "   " : "\r\n");
       if (half < MAX_MESSAGES && fight_messages[half].msg)
-        len += snprintf(buf + len, sizeof(buf) - len, "%-2d) [%-3d] %d, %-18s\r\n", half, fight_messages[half].a_type, fight_messages[half].number_of_attacks, fight_messages[half].a_type < TOP_SPELL_DEFINE ? spell_info[fight_messages[half].a_type].name : "Unknown");
+        len += snprintf(buf + len, sizeof(buf) - len, "%-2d) [%-3d] %d, %-18s\r\n", half, fight_messages[half].a_type, fight_messages[half].number_of_attacks, get_spell_name(fight_messages[half].a_type));
     }
     
   snprintf(buf + len, sizeof(buf) - len, "Total Messages: %d\r\n", count);  
@@ -188,7 +189,7 @@
     if (fight_messages[i].msg == NULL)
       continue;
     if (fight_messages[i].a_type > 0 && fight_messages[i].a_type < TOP_SPELL_DEFINE)
-      fprintf(fp, "* %s %d\n", PRINT_MSG(spell_info[fight_messages[i].a_type].name), fight_messages[i].a_type);
+      fprintf(fp, "* %s %d\n", get_spell_name(fight_messages[i].a_type), fight_messages[i].a_type);
     else
       fprintf(fp, "* %d\n", fight_messages[i].a_type);
              
@@ -357,7 +358,7 @@
   get_char_colors(d->character);
   
   write_to_output(d, "%sMsg Edit: %s[%s%dx%d%s] [%s$n: Attacker | $N: Victim%s]%s\r\n", cyn, grn, yel, OLC_NUM(d), OLC_MSG_LIST(d)->number_of_attacks, grn, yel, grn, nrm);
-  write_to_output(d, "%s1%s) %sAction Type: %s%d %s[%s%s%s]%s\r\n", grn, yel, cyn, yel, OLC_MSG_LIST(d)->a_type,  grn, yel, OLC_MSG_LIST(d)->a_type < TOP_SPELL_DEFINE ? spell_info[OLC_MSG_LIST(d)->a_type].name : "Unknown", grn, nrm);
+  write_to_output(d, "%s1%s) %sAction Type: %s%d %s[%s%s%s]%s\r\n", grn, yel, cyn, yel, OLC_MSG_LIST(d)->a_type,  grn, yel, get_spell_name(OLC_MSG_LIST(d)->a_type), grn, nrm);
    
   write_to_output(d, "   %sDeath Messages:\r\n"
                      "%sA%s) CHAR : %s %s\r\n"
diff -uN ./orig/oasis.c ./oasis.c
--- ./orig/oasis.c	2020-02-25 19:18:51.522369247 -0500
+++ ./oasis.c	2020-02-25 19:19:09.945725507 -0500
@@ -27,9 +27,10 @@
 #include "quest.h"
 #include "ibt.h"
 #include "msgedit.h"
+#include "spedit.h"
 
 /* Global variables defined here, used elsewhere */
-const char *nrm, *grn, *cyn, *yel;
+const char *nrm, *grn, *cyn, *yel, *YEL, *bln, *red;
 
 /* Internal Function prototypes  */
 static void free_config(struct config_data *data);
@@ -51,6 +52,9 @@
   grn = CCGRN(ch, C_NRM);
   cyn = CCCYN(ch, C_NRM);
   yel = CCYEL(ch, C_NRM);
+  bln = CCFBLU(ch, C_NRM);
+  YEL = CBYEL(ch, C_NRM);
+  red = CCRED(ch, C_NRM);
 }
 
 /* This procedure frees up the strings and/or the structures attatched to a
@@ -171,6 +175,8 @@
      free(OLC_STORAGE(d));
      OLC_STORAGE(d) = NULL;
    }
+
+
    /* Free this one regardless. If we've left olc, we've either made a fresh
     * copy of it in the trig index, or we lost connection. Either way, we need
     * to get rid of this. */
@@ -188,6 +194,12 @@
      OLC_PREFS(d) = NULL;
    }
 
+   if(OLC_SPELL(d)) {
+     spedit_free_spell(OLC_SPELL(d));    
+     OLC_SPELL(d) = NULL;               
+   }
+     OLC_SEARCH(d) = NULL;
+
    /* OLC_SCRIPT is always set as trig_proto of OLC_OBJ/MOB/ROOM. Therefore it
     * should not be free'd here. */
 
@@ -205,6 +217,9 @@
     else if (STATE(d) == CON_HEDIT)
       mudlog(CMP, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)),
        TRUE, "OLC: %s stops editing help files.", GET_NAME(d->character));
+    else if (STATE(d) == CON_SPEDIT)
+      mudlog(CMP, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)),
+       TRUE, "OLC: %s stops editing spell files.", GET_NAME(d->character));
     else
       mudlog(CMP, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)),
         TRUE, "OLC: %s stops editing zone %d allowed zone %d", 
diff -uN ./orig/oasis.h ./oasis.h
--- ./orig/oasis.h	2020-02-25 19:18:51.522369247 -0500
+++ ./oasis.h	2020-02-25 19:19:09.945725507 -0500
@@ -96,6 +96,8 @@
   struct shop_data *shop;        /* used for 'sedit'         */
   struct config_data *config;    /* used for 'cedit'         */
   struct aq_data *quest;         /* used for 'qedit'         */
+  struct str_spells *spell;      /* used for 'spedit'        */
+  struct str_spells *search;     /* used by 'spedit'         */
   struct extra_descr_data *desc; /* used in '[r|o|m]edit'    */
   struct social_messg *action;   /* Aedit uses this one      */
   struct trig_data *trig;
@@ -111,7 +113,7 @@
 };
 
 /* Exported globals. */
-extern const char *nrm, *grn, *cyn, *yel;
+extern const char *nrm, *grn, *cyn, *yel, *YEL, *bln, *red;
 
 /* Descriptor access macros. */
 #define OLC(d)         ((d)->olc)
@@ -139,6 +141,8 @@
 /* Other macros. */
 #define OLC_EXIT(d)    (OLC_ROOM(d)->dir_option[OLC_VAL(d)])
 #define OLC_MSG(d)     (OLC(d)->m_type)
+#define OLC_SPELL(d)   (OLC(d)->spell)    /**< Spell structure. */ 
+#define OLC_SEARCH(d)  (OLC(d)->search) 
 
 /* Cleanup types. */
 #define CLEANUP_ALL		1	/* Free the whole lot.			*/
@@ -390,6 +394,48 @@
 #define HEDIT_KEYWORDS                  5
 #define HEDIT_MIN_LEVEL                 6
 
+/* Spedit Submodes of connectedness     */
+#define SPEDIT_MAIN_MENU                0 
+#define SPEDIT_CONFIRM_SAVESTRING       1
+#define SPEDIT_GET_NUMMANA              2
+#define SPEDIT_APPLY_MENU               3
+#define SPEDIT_SHOW_APPLY               4
+#define SPEDIT_GET_MODIF                5
+#define SPEDIT_GET_APPLDUR              6
+#define SPEDIT_SHOW_ASSIGNEMENT         7
+#define SPEDIT_GET_LEVEL                8
+#define SPEDIT_GET_NUMPRAC              9
+#define SPEDIT_GET_NAME                 10
+#define SPEDIT_ASSIGN_MENU              11
+#define SPEDIT_SHOW_TARG_FLAGS          12
+#define SPEDIT_SHOW_MAG_FLAGS           13
+#define SPEDIT_PROTECTION_MENU          14
+#define SPEDIT_GET_SPELL_NUM            15
+#define SPEDIT_GET_DAMAGES              16
+#define SPEDIT_GET_PROTDUR              17
+#define SPEDIT_GET_STATUS               18
+#define SPEDIT_CONFIRM_EDIT             19
+#define SPEDIT_GET_EFFECTIVENESS        20
+#define SPEDIT_GET_MINPOS               21
+#define SPEDIT_GET_MAXDAM               22
+#define SPEDIT_GET_RESIST               23
+#define SPEDIT_GET_DELAY                24
+#define SPEDIT_GET_SCRIPT               25
+#define SPEDIT_GET_TYPE                 26
+#define SPEDIT_SHOW_MESSAGES            27
+#define SPEDIT_GET_MSG_WEAR_OFF         28
+#define SPEDIT_GET_MSG_TO_SELF          29
+#define SPEDIT_GET_MSG_TO_VICT          30
+#define SPEDIT_GET_MSG_TO_ROOM          31
+#define SPEDIT_SHOW_OBJECTS             32
+#define SPEDIT_GET_OBJECT               33
+#define SPEDIT_SHOW_DISPEL              34
+#define SPEDIT_GET_DISPEL               35
+#define SPEDIT_SHOW_POINTS              36
+#define SPEDIT_GET_POINTS               37
+#define SPEDIT_SHOW_MOBILE              38
+#define SPEDIT_GET_MOBILE               39
+
 int  save_config( IDXTYPE nowhere );
 
 /* Prototypes to keep. */
@@ -477,4 +523,10 @@
 ACMD(do_oasis_links);
 ACMD(do_oasis_list);
 
+
+/* public functions from spedit.c */
+void spedit_parse(struct descriptor_data *d, char *arg);
+ACMD(do_spedit);
+ACMD(do_splist);
+
 #endif /* _OASIS_H_ */
diff -uN ./orig/oedit.c ./oedit.c
--- ./orig/oedit.c	2020-02-25 19:18:51.526369106 -0500
+++ ./oedit.c	2020-02-25 19:19:09.945725507 -0500
@@ -24,6 +24,7 @@
 #include "dg_olc.h"
 #include "fight.h"
 #include "modify.h"
+#include "spedit.h"
 
 /* local functions */
 static void oedit_setup_new(struct descriptor_data *d);
@@ -389,14 +390,17 @@
 /* Spell type. */
 static void oedit_disp_spells_menu(struct descriptor_data *d)
 {
+  struct str_spells *spell;
+
   int counter, columns = 0;
 
   get_char_colors(d->character);
   clear_screen(d);
 
-  for (counter = 1; counter <= NUM_SPELLS; counter++) {
-    write_to_output(d, "%s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
-		spell_info[counter].name, !(++columns % 3) ? "\r\n" : "");
+  for (counter = 1; counter <= MAX_SKILLS; counter++) {
+    if ((spell = get_spell_by_vnum(counter)))
+      write_to_output(d, "%s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
+                      spell->name, !(++columns % 3) ? "\r\n" : "");
   }
   write_to_output(d, "\r\n%sEnter spell choice (-1 for none) : ", nrm);
 }
@@ -974,11 +978,10 @@
     switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
     case ITEM_SCROLL:
     case ITEM_POTION:
-      if (number == 0 || number == -1)
+      if (number == 0 || number == -1 || !get_spell_by_vnum(number))
 	GET_OBJ_VAL(OLC_OBJ(d), 1) = -1;
-      else
-	GET_OBJ_VAL(OLC_OBJ(d), 1) = LIMIT(number, 1, NUM_SPELLS);
-
+      else 
+        GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
       oedit_disp_val3_menu(d);
       break;
     case ITEM_CONTAINER:
@@ -1009,14 +1012,12 @@
     switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
     case ITEM_SCROLL:
     case ITEM_POTION:
-      if (number == 0 || number == -1) {
+      if (number == 0 || number == -1 || !get_spell_by_vnum(number)) 
 	GET_OBJ_VAL(OLC_OBJ(d), 2) = -1;
-	oedit_disp_val4_menu(d);
-	return;
-      }
-      min_val = 1;
-      max_val = NUM_SPELLS;
-      break;
+      else
+        GET_OBJ_VAL(OLC_OBJ(d), 2) = number;
+      oedit_disp_val4_menu(d);
+      return; 
     case ITEM_WEAPON:
       min_val = 1;
       max_val = MAX_WEAPON_SDICE;
@@ -1047,21 +1048,16 @@
   case OEDIT_VALUE_4:
     number = atoi(arg);
     switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
+    case ITEM_STAFF:
     case ITEM_SCROLL:
     case ITEM_POTION:
-      if (number == 0 || number == -1) {
+      if (number == 0 || number == -1 || !get_spell_by_vnum(number)) 
 	GET_OBJ_VAL(OLC_OBJ(d), 3) = -1;
-        oedit_disp_menu(d);
-	return;
-      }
-      min_val = 1;
-      max_val = NUM_SPELLS;
-      break;
+      else
+	GET_OBJ_VAL(OLC_OBJ(d), 3) = number;
+      oedit_disp_menu(d);
+      return;
     case ITEM_WAND:
-    case ITEM_STAFF:
-      min_val = 1;
-      max_val = NUM_SPELLS;
-      break;
     case ITEM_WEAPON:
       min_val = 0;
       max_val = NUM_ATTACK_TYPES - 1;
Common subdirectories: ./orig/orig and ./orig
diff -uN ./orig/spec_procs.c ./spec_procs.c
--- ./orig/spec_procs.c	2020-02-25 19:18:51.526369106 -0500
+++ ./spec_procs.c	2020-02-25 19:24:16.903961650 -0500
@@ -26,37 +26,14 @@
 #include "class.h"
 #include "fight.h"
 #include "modify.h"
+#include "spedit.h"
+#include "formula.h"
 
 
 /* locally defined functions of local (file) scope */
-static int compare_spells(const void *x, const void *y);
 static const char *how_good(int percent);
 static void npc_steal(struct char_data *ch, struct char_data *victim);
 
-/* Special procedures for mobiles. */
-static int spell_sort_info[MAX_SKILLS + 1];
-
-
-
-static int compare_spells(const void *x, const void *y)
-{
-  int	a = *(const int *)x,
-	b = *(const int *)y;
-
-  return strcmp(spell_info[a].name, spell_info[b].name);
-}
-
-void sort_spells(void)
-{
-  int a;
-
-  /* initialize array, avoiding reserved. */
-  for (a = 1; a <= MAX_SKILLS; a++)
-    spell_sort_info[a] = a;
-
-  qsort(&spell_sort_info[1], MAX_SKILLS, sizeof(int), compare_spells);
-}
-
 static const char *how_good(int percent)
 {
   if (percent < 0)
@@ -81,11 +58,6 @@
   return " (superb)";
 }
 
-static const char *prac_types[] = {
-  "spell",
-  "skill"
-};
-
 #define LEARNED_LEVEL	0	/* % known which is considered "learned" */
 #define MAX_PER_PRAC	1	/* max percent gain in skill per practice */
 #define MIN_PER_PRAC	2	/* min percent gain in skill per practice */
@@ -94,37 +66,57 @@
 #define LEARNED(ch) (prac_params[LEARNED_LEVEL][(int)GET_CLASS(ch)])
 #define MINGAIN(ch) (prac_params[MIN_PER_PRAC][(int)GET_CLASS(ch)])
 #define MAXGAIN(ch) (prac_params[MAX_PER_PRAC][(int)GET_CLASS(ch)])
-#define SPLSKL(ch) (prac_types[prac_params[PRAC_TYPE][(int)GET_CLASS(ch)]])
 
 void list_skills(struct char_data *ch)
 {
   const char *overflow = "\r\n**OVERFLOW**\r\n";
-  int i, sortpos, ret;
   size_t len = 0;
-  char buf2[MAX_STRING_LENGTH];
-
-  len = snprintf(buf2, sizeof(buf2), "You have %d practice session%s remaining.\r\n"
-	"You know of the following %ss:\r\n", GET_PRACTICES(ch),
-	GET_PRACTICES(ch) == 1 ? "" : "s", SPLSKL(ch));
-
-  for (sortpos = 1; sortpos <= MAX_SKILLS; sortpos++) {
-    i = spell_sort_info[sortpos];
-    if (GET_LEVEL(ch) >= spell_info[i].min_level[(int) GET_CLASS(ch)]) {
-    ret = snprintf(buf2 + len, sizeof(buf2) - len, "%-20s %s\r\n", spell_info[i].name, how_good(GET_SKILL(ch, i)));
-      if (ret < 0 || len + ret >= sizeof(buf2))
-        break;
-      len += ret;
+  int vnum = 1;
+  int ret;
+  struct str_spells *spell;
+
+  char buf[MAX_STRING_LENGTH];
+
+  len = snprintf(buf, sizeof(buf), "You have %d practice session%s remaining.\r\n"
+                                   "You know the following:\r\n",
+        GET_PRACTICES(ch), GET_PRACTICES(ch) == 1 ? "" : "s");
+
+  spell = get_spell_by_vnum(vnum);
+  while (spell) {
+    int from_myclass = 0, i;
+
+    if (spell->status == available) {
+      // if LVL_IMMORT bypass class assignement check.
+      if (GET_LEVEL(ch) >= LVL_IMMORT)
+        from_myclass = 1;
+      else
+        for (i=0; i<NUM_CLASSES; i++)
+          if ((spell->assign[i].class_num == GET_CLASS(ch) &&
+              (GET_LEVEL(ch) >= spell->assign[i].level))) {
+            from_myclass = 1;
+            break;
+          }
+      if (from_myclass)  {
+        ret = snprintf(buf + len, sizeof(buf) - len, "%-20s %s\r\n", spell->name, how_good(GET_SKILL(ch, spell->vnum)));
+        if (ret < 0 || len + ret >= sizeof(buf))
+          break;
+        len += ret;
+      }
     }
+    spell = spell->next; 
   }
-  if (len >= sizeof(buf2))
-    strcpy(buf2 + sizeof(buf2) - strlen(overflow) - 1, overflow); /* strcpy: OK */
 
-  page_string(ch->desc, buf2, TRUE);
+  if (len >= sizeof(buf))
+    strcpy(buf + sizeof(buf) - strlen(overflow) - 1, overflow); // strcpy: OK 
+
+  page_string(ch->desc, buf, TRUE);
 }
 
 SPECIAL(guild)
 {
-  int skill_num, percent;
+  struct str_spells *spell = NULL;
+
+  int class, skill_num, percent, level, rts_code;
 
   if (IS_NPC(ch) || !CMD_IS("practice"))
     return (FALSE);
@@ -140,11 +132,18 @@
     return (TRUE);
   }
 
-  skill_num = find_skill_num(argument);
+  spell = get_spell_by_name(argument, SPSK);
+  if (!spell) {
+    log("SYSERR: spell not found '%s' at the guild.", argument);
+    send_to_char(ch, "'%s' doesn't exists.\r\n", argument);
+    return (TRUE);
+  }
 
-  if (skill_num < 1 ||
-      GET_LEVEL(ch) < spell_info[skill_num].min_level[(int) GET_CLASS(ch)]) {
-    send_to_char(ch, "You do not know of that %s.\r\n", SPLSKL(ch));
+  skill_num = spell->vnum;
+  level = get_spell_level(skill_num, GET_CLASS(ch));
+
+  if ((level == -1) || (GET_LEVEL(ch) < level)) {
+    send_to_char(ch, "You do not know of that %s.\r\n", spell->type == SPELL ? "spell" : "skill");
     return (TRUE);
   }
   if (GET_SKILL(ch, skill_num) >= LEARNED(ch)) {
@@ -154,8 +153,13 @@
   send_to_char(ch, "You practice for a while...\r\n");
   GET_PRACTICES(ch)--;
 
+  class = get_spell_class(spell, GET_CLASS(ch));
+
   percent = GET_SKILL(ch, skill_num);
-  percent += MIN(MAXGAIN(ch), MAX(MINGAIN(ch), int_app[GET_INT(ch)].learn));
+  if ((class == -1) || !spell->assign[class].prac_gain)
+    percent += MIN(MAXGAIN(ch), MAX(MINGAIN(ch), int_app[GET_INT(ch)].learn));
+  else
+    percent += MAX(5, formula_interpreter (ch, ch, skill_num, TRUE, spell->assign[class].prac_gain, GET_LEVEL(ch), &rts_code)); 
 
   SET_SKILL(ch, skill_num, MIN(LEARNED(ch), percent));
 
diff -uN ./orig/spedit.c ./spedit.c
--- ./orig/spedit.c	1969-12-31 19:00:00.000000000 -0500
+++ ./spedit.c	2020-02-25 19:19:09.949725369 -0500
@@ -0,0 +1,2038 @@
+/* Copyright (c) 2020 castillo7@hotmail.com
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE. */
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "comm.h"
+#include "utils.h"
+#include "spells.h"
+#include "db.h"
+#include "boards.h"
+#include "oasis.h"
+#include "interpreter.h"
+#include "modify.h"
+#include "screen.h"
+#include "spedit.h"
+#include "constants.h"
+#include "class.h"
+#include "improved-edit.h"
+#include "structs.h"
+#include "formula.h"
+
+#define BUFSIZE 2048
+
+#define EMPTY_STR(str) ((str) ? (str) : "<empty>")
+#define NULL_STR(str) ((str) ? (str) : "")
+#define STRDUP(str)  ((str && *str) ? (strdup(str)) : NULL)
+
+// SAFE_FREE is similar to DISPOSE from utils.h, but 
+// without log("SYSERR") if (str) is NULL. It's not an error here.
+#define SAFE_FREE(str) do		\
+			{		\
+			if (str)	\
+			free(str);	\
+			str = NULL;	\
+			} while(0)
+
+// global variable
+struct str_spells *list_spells = NULL;
+int last_spell_vnum = 0;
+char *UNDEF_SPELL = "Undefined";
+
+// return a pointer on the player's name that is editing the spell vnum, or NULL if not edited.
+// The name will be used to says: Spell is edited by: <name>.
+// but, it can also be used to check if a SPELL VNUM is edited.
+char *SPELL_OLCING_BY (int vnum) 
+{
+ struct descriptor_data *q;
+
+ for (q = descriptor_list; q; q = q->next)
+   if ((q->connected == CON_SPEDIT) && 
+       OLC_NUM(q) == vnum) 
+     return (GET_NAME(q->character));
+ return NULL;
+}
+
+int is_assign_set(struct str_spells *spell)
+{
+ int i;
+
+ for (i=0; i<NUM_CLASSES; i++) 
+   if (spell->assign[i].class_num != -1)
+     return 1;
+ return 0;
+}
+ 
+int is_prot_set(struct str_spells *spell)
+{
+ int i;
+
+ for (i=0; i<MAX_SPELL_PROTECTIONS; i++) 
+   if (spell->protfrom[i].prot_num != -1)
+     return 1;
+ return 0;
+}
+
+int is_apply_set(struct str_spells *spell)
+{
+ int i;
+
+ for (i=0; i<MAX_SPELL_AFFECTS; i++) 
+   if (spell->applies[i].appl_num != -1)
+     return 1;
+ return 0;
+}
+
+int is_summon_set(struct str_spells *spell)
+{
+ return spell->summon_mob ? 1 : 0;
+}
+
+int is_objects_set(struct str_spells *spell)
+{
+ int i;
+
+ for (i=0; i<MAX_SPELL_OBJECTS; i++)
+   if (spell->objects[i])
+     return 1;
+ return 0;
+}
+
+int is_dispel_set(struct str_spells *spell)
+{
+  int i;
+
+  for (i=0; i<MAX_SPELL_DISPEL; i++)
+    if (spell->dispel[i])
+      return 1;
+  return 0;
+}
+
+int is_points_set(struct str_spells *spell)
+{
+  if (spell->points.hp) return 1;
+  if (spell->points.mana) return 1;
+  if (spell->points.move) return 1;
+  if (spell->points.gold) return 1;
+
+  return 0;
+}
+
+int is_messages_set(struct str_spells *spell)
+{
+  if (spell->messages.wear_off) return 1;
+  if (spell->messages.to_self) return 1;
+  if (spell->messages.to_vict) return 1;
+  if (spell->messages.to_room) return 1;
+
+  return 0;
+}
+
+int get_spell_class(struct str_spells *spell, int class) {
+  int i;
+
+  for (i=0; i<NUM_CLASSES; i++)
+    if (spell->assign[i].class_num == class)
+      return i;
+  return -1;
+}
+
+int get_spell_mag_flags(int vnum)
+{
+ struct str_spells *Q;
+
+ for (Q = list_spells; Q; Q=Q->next)
+   if (Q->vnum == vnum)
+     return (Q->mag_flags);
+
+ log("SYSERR: Spell vnum %d not found at get_spell_mag_flags.", vnum);
+ return 0;
+}
+
+char *get_spell_name(int vnum)
+{
+ struct str_spells *ptr;
+
+ for (ptr = list_spells; ptr; ptr = ptr->next)
+   if (ptr->vnum == vnum)
+     return ptr->name;
+ return UNDEF_SPELL;
+}
+
+struct str_spells *get_spell_by_vnum(int vnum)
+{
+  struct str_spells *ptr;
+
+  for (ptr = list_spells; ptr; ptr = ptr->next)
+    if (ptr->vnum == vnum) 
+      return ptr;
+  return NULL;
+}
+
+// check all the assigned classes.
+int get_spell_level(int vnum, int class)
+{
+ int i;
+ struct str_spells *spell = get_spell_by_vnum(vnum);
+
+ if (spell) {
+   for (i=0; i<NUM_CLASSES; i++)
+     if (spell->assign[i].class_num == class)
+       return spell->assign[i].level;
+ }
+ return -1;
+}
+
+struct str_spells *get_spell_by_name(char *name, char type)
+{
+  struct str_spells *ptr, *first = NULL;
+  int cpt = 0; 
+
+  for (ptr = list_spells; ptr; ptr = ptr->next)
+    if (is_abbrev(name, ptr->name) && ((type == SPSK) || (ptr->type == type))) {
+      if (++cpt > 1)
+        return NULL;
+      first = ptr;
+    }
+  return first;
+}
+
+int olc_spell_by_name (struct descriptor_data *d, char *name) 
+{
+  struct str_spells *ptr;
+
+  int vnum = 0;
+
+  if (OLC_SEARCH(d))
+    ptr = OLC_SEARCH(d);
+  else
+    ptr = list_spells;
+
+  while (ptr) {
+    if (stristr3(ptr->name, name)) {
+      if (vnum == 0)
+        vnum = ptr->vnum;
+      else {
+        OLC_SEARCH(d) = ptr; 
+        return vnum;
+      }
+    }
+    ptr = ptr->next;
+  }
+  OLC_SEARCH(d) = NULL;
+  return vnum;
+}
+
+void spedit_assign_menu (struct descriptor_data *d) {
+  char buf[2048] = "\r\n";
+
+  int i;  
+  struct str_spells *Q;
+
+  Q = OLC_SPELL(d);
+  if (Q->type == SPELL) {
+    for (i=0; i<NUM_CLASSES; i++)
+      sprintf (buf, "%s%s%d%s) Class       : %s%s %s(%s%3d%s) \r\n   %sPrac gain %% : %s%s\r\n   "
+                    "%sMana        : %s%s\r\n",
+                    buf, 
+                    grn, i + 1, nrm, yel, 
+                    Q->assign[i].class_num != -1 ? pc_class_types [Q->assign[i].class_num] : "<empty>",
+                    nrm, cyn, Q->assign[i].level, nrm,
+                    nrm, cyn, EMPTY_STR(Q->assign[i].prac_gain),
+                    nrm, cyn, EMPTY_STR(Q->assign[i].num_mana));
+    } else {
+        for (i=0; i<NUM_CLASSES; i++) 
+          sprintf (buf, "%s%s%d%s) Class       : %s%s %s(%s%3d%s) \r\n   %sPrac gain %% : %s%s\r\n",
+                        buf, 
+                        grn, i + 1, nrm, yel, 
+                        Q->assign[i].class_num != -1 ? pc_class_types [Q->assign[i].class_num] : "<empty>",
+                        nrm, cyn, Q->assign[i].level, nrm,
+                        nrm, cyn, EMPTY_STR(Q->assign[i].prac_gain));
+      }
+
+  sprintf (buf, "%s\r\n%sEnter choice (0 to quit) : ", buf, nrm);
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_ASSIGN_MENU;
+}
+
+void spedit_apply_menu (struct descriptor_data *d) {
+  char buf[2048] = "\r\n";
+  char buf1[2048];
+
+  int i;
+  struct str_spells *Q;
+
+  Q = OLC_SPELL(d);
+  for (i=0; i<MAX_SPELL_AFFECTS; i++) {
+    buf1[0] = '\0';
+    if (Q->applies[i].appl_num < NUM_APPLIES)
+      sprintf (buf1, "   %sModifier : %s%s\r\n", nrm, cyn, EMPTY_STR(Q->applies[i].modifier));
+    sprintf (buf, "%s%s%d%s) Name     : %s%s\r\n%s   %sDuration : %s%s\r\n", 
+                buf, grn, i + 1, nrm, yel,
+                Q->applies[i].appl_num != -1 ? Q->applies[i].appl_num >= NUM_APPLIES ? 
+                                               affected_bits [Q->applies[i].appl_num - NUM_APPLIES] : 
+                                               apply_types [Q->applies[i].appl_num] : "<empty>", 
+                buf1,
+                nrm, cyn, EMPTY_STR(Q->applies[i].duration));
+  }
+  sprintf (buf, "%s\r\n%sEnter choice (0 to quit) : ", buf, nrm);
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_APPLY_MENU;
+}
+
+void spedit_protection_menu (struct descriptor_data *d) {
+  char buf[2048] = "\r\n";
+
+  int i;
+  char *name;
+  struct str_spells *Q;
+
+  Q = OLC_SPELL(d);
+  for (i=0; i<MAX_SPELL_PROTECTIONS; i++) {
+    name = get_spell_name (Q->protfrom[i].prot_num);
+    sprintf (buf, "%s%s%d%s) Name     : %s%s %s(%s%d%s)\r\n   %sDuration : %s%s\r\n%s   Resist %% : %s%s\r\n", 
+                buf, grn, i + 1, nrm, yel, name,
+                nrm, cyn, Q->protfrom[i].prot_num, nrm,
+                nrm, cyn, EMPTY_STR(Q->protfrom[i].duration),
+                nrm, cyn, EMPTY_STR(Q->protfrom[i].resist));
+  }
+  sprintf (buf, "%s\r\n%sEnter choice (0 to quit) : ", buf, nrm);
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_PROTECTION_MENU;
+}
+
+void spedit_minpos_menu (struct descriptor_data *d) {
+  char buf[2048];
+
+  int i;
+
+  sprintf (buf, "%s\r\n-- POSITION :    \r\n", nrm);
+  for (i=0; i < NUM_CHAR_POSITION; i++)
+    sprintf (buf, "%s%s%2d%s) %s%-16s%s", buf, grn, i + 1, nrm, yel, 
+                   position_types [i], (i + 1) % 4 ? "" : "\r\n" );
+  sprintf (buf, "%s%s\r\n\r\nEnter choice (0 to quit) : ", buf, nrm);
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_GET_MINPOS;
+}
+
+void spedit_targ_flags_menu (struct descriptor_data *d) {
+  char buf[2048];
+
+  int i;
+  char flags[SMALL_BUFSIZE]; 
+
+  sprintbit(OLC_SPELL(d)->targ_flags, targ_flags, (char *)&flags, SMALL_BUFSIZE);
+  sprintf (buf, "%s\r\n-- FLAGS :     %s%s\r\n", nrm, cyn, flags);
+  for (i=0; i < NUM_SPELL_FLAGS; i++)
+    sprintf (buf, "%s%s%2d%s) %s%-15s%s", buf, grn, i + 1, nrm, yel,
+                   targ_flags [i], (i + 1) % 4 ? "" : "\r\n" );
+  sprintf (buf, "%s%s\r\nEnter choice (0 to quit) : ", buf, nrm);
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_SHOW_TARG_FLAGS;
+}
+
+void spedit_mag_flags_menu (struct descriptor_data *d) {
+  char buf[2048];
+
+  int i;
+  char flags[SMALL_BUFSIZE];
+
+  sprintbit(OLC_SPELL(d)->mag_flags, mag_flags, (char *)&flags, SMALL_BUFSIZE);
+  sprintf (buf, "%s\r\n-- FLAGS :     %s%s\r\n", nrm, cyn, flags);
+  for (i=0; i < NUM_MAG; i++)
+    sprintf (buf, "%s%s%2d%s) %s%-15s%s", buf, grn, i + 1, nrm, yel,
+                   mag_flags [i], (i + 1) % 4 ? "" : "\r\n" );
+  sprintf (buf, "%s%s\r\nEnter choice (0 to quit) : ", buf, nrm);
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_SHOW_MAG_FLAGS;
+}
+
+void spedit_choose_apply (struct descriptor_data *d) {
+  char buf[2048];
+
+  int i, cpt;
+
+  sprintf (buf, "%s\r\n-- APPLIES : \r\n", nrm);
+  for (i=0; i < NUM_APPLIES; i++)
+    sprintf (buf, "%s%s%2d%s) %s%-15s%s", buf, grn, i + 1, nrm, yel, 
+                   apply_types [i], (i + 1) % 4 ? "" : "\r\n" );
+  sprintf (buf, "%s\r\n\r\n%s-- AFFECTS : \r\n", buf, nrm);
+  cpt = i + 1; 
+  for (i=cpt; i < cpt + NUM_AFF_FLAGS; i++)
+    sprintf (buf, "%s%s%2d%s) %s%-15s%s", buf, grn, i, nrm, yel, affected_bits [i - NUM_APPLIES],
+                  (i - cpt + 1) % 4 ? "" : "\r\n");
+  sprintf (buf, "%s%s\r\n\r\nEnter choice (0 to quit, 'r' to remove) : ", buf, nrm);
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_SHOW_APPLY;
+}
+
+void spedit_assignement_menu (struct descriptor_data *d) {
+  char buf[2048];
+
+  int i;
+  
+  sprintf (buf, "%s\r\n-- CLASSES : \r\n", nrm);
+  for (i=0; i < NUM_CLASSES; i++)
+    sprintf (buf, "%s%s%2d%s) %s%-13s%s", buf, grn, i + 1, nrm, yel, pc_class_types [i],
+                  (i + 1) % 5 ? "" : "\r\n");  
+  sprintf (buf, "%s%s\r\n\r\nEnter choice (0 to quit, 'r' to remove) : ", buf, nrm);
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_SHOW_ASSIGNEMENT;
+}
+
+void spedit_show_warnings (struct descriptor_data *d) {
+  char buf[BUFSIZE];
+  int len = 0;
+
+  buf[0] = '\0';
+  if (OLC_SPELL(d)->status != available)
+    len += snprintf(buf, BUFSIZE, "Spell status is unavailable.\r\n");
+
+  if ((len < BUFSIZE) && !is_assign_set(OLC_SPELL(d)))
+    len += snprintf(buf + len, BUFSIZE - len, "Spell is not assigned to any classes.\r\n");
+
+  if ((len < BUFSIZE) && !OLC_SPELL(d)->effectiveness)
+    len += snprintf(buf + len, BUFSIZE - len, "Spell effectiveness is not set.\r\n");
+
+  if ((len < BUFSIZE) && OLC_SPELL(d)->damages && !(OLC_SPELL(d)->mag_flags & MAG_DAMAGE))
+    len += snprintf(buf + len, BUFSIZE - len, "Magic flags: MAG_DAMAGE is required. (Damages is set).\r\n");
+
+  if ((len < BUFSIZE) && OLC_SPELL(d)->damages && !(OLC_SPELL(d)->mag_flags & MAG_VIOLENT))
+    len += snprintf(buf + len, BUFSIZE - len, "Magic flags: MAG_VIOLENT is required. (Damages is set).\r\n");
+
+  if ((len < BUFSIZE) && OLC_SPELL(d)->mag_flags & MAG_AREAS && !(OLC_SPELL(d)->mag_flags & MAG_VIOLENT))
+    len += snprintf(buf + len, BUFSIZE - len, "Magic flags: MAG_VIOLENT is required. (AREAS flas is set).\r\n");
+
+  if ((len < BUFSIZE) && is_apply_set(OLC_SPELL(d)) && !(OLC_SPELL(d)->mag_flags & MAG_AFFECTS))
+    len += snprintf(buf + len, BUFSIZE - len, "Magic flags: MAG_AFFECTS is required. (Affects and applies are set).\r\n");
+
+  if ((len < BUFSIZE) && (OLC_SPELL(d)->mag_flags & MAG_AFFECTS) && (OLC_SPELL(d)->mag_flags & MAG_UNAFFECTS))
+    len += snprintf(buf + len, BUFSIZE - len, "Magic flags: AFFECTS and UNAFFECTS are both set.\r\n");
+
+  if ((len < BUFSIZE) && is_objects_set(OLC_SPELL(d)) && !(OLC_SPELL(d)->mag_flags & MAG_CREATIONS))
+    len += snprintf(buf + len, BUFSIZE - len, "Magic flags: MAG_CREATIONS is required. (Create objects is set).\r\n");
+
+  if ((len < BUFSIZE) && is_dispel_set(OLC_SPELL(d)) && !(OLC_SPELL(d)->mag_flags & MAG_UNAFFECTS))
+    len += snprintf(buf + len, BUFSIZE - len, "Magic flags: MAG_UNAFFECTS is required. (Dispell is set).\r\n");
+  
+  if ((len < BUFSIZE) && is_points_set(OLC_SPELL(d)) && !(OLC_SPELL(d)->mag_flags & MAG_POINTS))
+    len += snprintf(buf + len, BUFSIZE - len, "Magic flags: MAG_POINTS is required. (Points is set).\r\n");
+
+  if ((len < BUFSIZE) && is_summon_set(OLC_SPELL(d)) && !(OLC_SPELL(d)->mag_flags & MAG_SUMMONS))
+    len += snprintf(buf + len, BUFSIZE - len, "Magic flags: MAG_SUMMON is required. (Summon mobile is set).\r\n");
+
+  if ((len < BUFSIZE) && OLC_SPELL(d)->damages && !OLC_SPELL(d)->max_dam)
+    len += snprintf(buf + len, BUFSIZE - len, "Damages is set, but max damages is set to 0.\r\n");
+
+  if ((len < BUFSIZE) && !OLC_SPELL(d)->targ_flags)
+    len += snprintf(buf + len, BUFSIZE - len, "No target flags set.\r\n");
+
+  if (*buf)
+    send_to_char (d->character, "\r\n%s", buf);
+
+  if (len >= BUFSIZE) {
+    send_to_char (d->character, " *** OVERFLOW ***\r\n");
+    log("SYSERR: buffer overflow from spedit_show_warnings.");
+  }
+}
+
+void spedit_show_messages(struct descriptor_data *d) {
+  char buf[BUFSIZE];
+
+  snprintf (buf, sizeof(buf), "\r\n%s1%s) Wear off  : %s%s\r\n"
+                              "%s2%s) To self   : %s%s\r\n"
+                              "%s3%s) To victim : %s%s\r\n"
+                              "%s4%s) To room   : %s%s\r\n" 
+                              "\r\n%sEnter choice (0 to quit) : ",
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->messages.wear_off),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->messages.to_self),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->messages.to_vict),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->messages.to_room),
+                              nrm);
+
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_SHOW_MESSAGES;
+}
+
+void spedit_show_objects(struct descriptor_data *d) {
+  char buf[BUFSIZE];
+
+  snprintf (buf, BUFSIZE, "\r\n%s1%s) Object : %s%s\r\n"
+                              "%s2%s) Object : %s%s\r\n"
+                              "%s3%s) Object : %s%s\r\n"
+                              "\r\n%sEnter choice (0 to quit) : ",
+                              grn, nrm, cyn,EMPTY_STR(OLC_SPELL(d)->objects[0]),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->objects[1]),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->objects[2]),
+                              nrm);
+
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_SHOW_OBJECTS;
+}
+
+void spedit_show_dispel(struct descriptor_data *d) {
+  char buf[BUFSIZE];
+
+  snprintf (buf, BUFSIZE, "\r\n%s1%s) Spell : %s%s\r\n"
+                              "%s2%s) Spell : %s%s\r\n"
+                              "%s3%s) Spell : %s%s\r\n"
+                              "\r\n%sEnter choice (0 to quit) : ",
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->dispel[0]),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->dispel[1]),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->dispel[2]),
+                              nrm);
+
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_SHOW_DISPEL;
+}
+
+void spedit_show_points(struct descriptor_data *d) {
+  char buf[BUFSIZE];
+  
+  snprintf (buf, BUFSIZE, "\r\n%s1%s) Hit points  : %s%s\r\n"
+                              "%s2%s) Mana points : %s%s\r\n"
+                              "%s3%s) Move points : %s%s\r\n"
+                              "%s4%s) Gold        : %s%s\r\n"
+                              "\r\n%sEnter choice (0 to quit) : ",
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->points.hp),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->points.mana),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->points.move),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->points.gold),
+                              nrm);
+
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_SHOW_POINTS;
+}
+
+void spedit_show_mobile(struct descriptor_data *d) {
+  char buf[BUFSIZE];
+
+  snprintf (buf, BUFSIZE, "\r\n%s1%s) Mobile        : %s%s\r\n"
+                              "%s2%s) Required item : %s%s\r\n"
+                              "\r\n%sEnter choice (0 to quit) : ",
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->summon_mob),
+                              grn, nrm, cyn, EMPTY_STR(OLC_SPELL(d)->summon_req),
+                              nrm);
+
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE(d) = SPEDIT_SHOW_MOBILE;
+}
+
+void spedit_main_menu (struct descriptor_data *d) {
+  char buf[BUFSIZE];
+  char tflags[SMALL_BUFSIZE];
+  char mflags[SMALL_BUFSIZE];
+  struct str_spells *Q;
+
+  Q = OLC_SPELL(d);
+
+  bool prog = Q->function != NULL;
+
+  sprintbit(OLC_SPELL(d)->mag_flags, mag_flags, (char *)&mflags, SMALL_BUFSIZE);
+  sprintbit(OLC_SPELL(d)->targ_flags, targ_flags, (char *)&tflags, SMALL_BUFSIZE);
+
+  get_char_colors (d->character);
+
+  clear_screen (d);
+  snprintf (buf, BUFSIZE, "%s-- %s Number      : [%s%5d%s] %s%s%s\r\n"
+                "%sT%s) Type              : [%s%-5s%s]\r\n"
+                "%s1%s) %sStatus            : %s%s\r\n"  
+                "%s2%s) Name              : %s%s\r\n"
+                "%s3%s) Min position      : %s%s\r\n"
+                "%s4%s) Target FLAGS      : %s%s\r\n"
+                "%s5%s) Magic FLAGS       : %s%s\r\n"
+                "%s6%s) Damages           : %s%s %s(%s%4d%s)\r\n"
+                "%s7%s) Pulse delay       : %s%s\r\n"
+                "%s8%s) %sEffectiveness %%   : %s%s\r\n"
+                "%s9%s) %sMenu -> Points\r\n"
+                "%sP%s) %sMenu -> Protection from\r\n"
+                "%sA%s) %sMenu -> Applies & Affects\r\n"
+                "%sD%s) %sMenu -> Dispells\r\n"
+                "%sO%s) %sMenu -> Create objects\r\n"
+                "%sX%s) %sMenu -> Summon mobiles\r\n"
+                "%sS%s) %sMenu -> Script\r\n" 
+                "%sC%s) %sMenu -> Classes\r\n"
+                "%sM%s) %sMenu -> Messages\r\n"
+                "%sW%s) Warnings\r\n"
+                "%sQ%s) Quit\r\n\r\n"
+                "%sEnter choice : ",
+                 nrm, (Q->type == SPELL) ? "Spell" : "Skill", cyn, OLC_NUM(d), nrm, yel, Q->function ? "Special" : "", nrm,
+                 prog ? red : grn, nrm, cyn, (Q->type == SPELL) ? "SPELL" : "SKILL", nrm,
+                 grn, nrm, (Q->status == available) ? nrm : YEL, yel, (Q->status == available) ? "Available" : "Unavailable",
+                 prog ? red : grn, nrm, yel, Q->name ? Q->name : UNDEF_SPELL, 
+                 prog ? red : grn, nrm, cyn, ((Q->min_pos >= 0) && (Q->min_pos < NUM_CHAR_POSITION)) ? 
+                              position_types [Q->min_pos] : "<ILLEGAL>",   
+                 prog ? red : grn, nrm, cyn, tflags,
+                 prog ? red : grn, nrm, cyn, mflags,
+                 prog ? red : grn, nrm, cyn, EMPTY_STR(Q->damages), nrm, cyn, Q->max_dam, nrm,  
+                 prog ? red : grn, nrm, cyn, EMPTY_STR(Q->delay),
+                 prog ? red : grn, nrm, Q->effectiveness ? nrm : YEL, cyn, EMPTY_STR(Q->effectiveness),
+                 prog ? red : grn, nrm, is_points_set(Q) ? bln : nrm,
+                 prog ? red : grn, nrm, is_prot_set(Q) ? bln : nrm,
+                 prog ? red : grn, nrm, is_apply_set(Q) ? bln : nrm, 
+                 prog ? red : grn, nrm, is_dispel_set(Q) ? bln : nrm,
+                 prog ? red : grn, nrm, is_objects_set(Q) ? bln : nrm,
+                 prog ? red : grn, nrm, is_summon_set(Q) ? bln :  nrm,
+                 prog ? red : grn, nrm, Q->script ? bln : nrm,
+                 prog ? red : grn, nrm, is_assign_set(Q) ? bln : YEL,
+                 prog ? red : grn, nrm, is_messages_set(Q) ? bln : nrm,
+                 prog ? red : grn, nrm,
+                 grn, nrm,
+                 nrm);
+  send_to_char (d->character, "%s", buf);
+  OLC_MODE (d) = SPEDIT_MAIN_MENU;
+}
+
+void spedit_string_cleanup (struct descriptor_data *d, int action) {
+  spedit_main_menu(d);
+}
+
+void spedit_empty_spell (struct str_spells *spell) {
+  int i;
+
+  SAFE_FREE(spell->name);
+  SAFE_FREE(spell->damages);
+  SAFE_FREE(spell->effectiveness);
+  SAFE_FREE(spell->delay);
+  SAFE_FREE(spell->script);
+
+  SAFE_FREE(spell->messages.wear_off);
+  SAFE_FREE(spell->messages.to_self);
+  SAFE_FREE(spell->messages.to_vict);
+  SAFE_FREE(spell->messages.to_room);
+
+  SAFE_FREE(spell->points.hp);
+  SAFE_FREE(spell->points.mana);
+  SAFE_FREE(spell->points.move);
+  SAFE_FREE(spell->points.gold);
+
+  SAFE_FREE(spell->summon_mob);
+  SAFE_FREE(spell->summon_req);
+
+  for (i=0; i<MAX_SPELL_PROTECTIONS; i++) {
+    SAFE_FREE(spell->protfrom[i].duration);
+    SAFE_FREE(spell->protfrom[i].resist);
+  }
+
+  for (i=0; i<MAX_SPELL_AFFECTS; i++) {
+    SAFE_FREE(spell->applies[i].modifier);
+    SAFE_FREE(spell->applies[i].duration);
+  }
+
+  for (i=0; i<MAX_SPELL_OBJECTS; i++)
+    SAFE_FREE(spell->objects[i]);
+
+  for (i=0; i<MAX_SPELL_DISPEL; i++)
+    SAFE_FREE(spell->dispel[i]);
+
+  for (i=0; i<NUM_CLASSES; i++) {
+    SAFE_FREE(spell->assign[i].prac_gain);
+    SAFE_FREE(spell->assign[i].num_mana);
+  }
+}
+
+void spedit_free_spell (struct str_spells *spell) {
+  if (!spell)
+    return;
+
+  spedit_empty_spell(spell);
+
+  free (spell);
+}
+
+void spedit_free_memory() {
+  struct str_spells *q = list_spells, *n;
+
+  while (q) {
+    n = q->next;
+    spedit_free_spell(q);
+    q = n;
+  }
+}
+
+void spedit_copyover_spell (struct str_spells *from, struct str_spells *to)
+{
+  int i;
+
+  spedit_empty_spell(to);
+
+  to->status = from->status;
+  to->type = from->type;
+  to->name = STRDUP(from->name);
+  to->targ_flags = from->targ_flags;
+  to->mag_flags = from->mag_flags;
+  to->min_pos = from->min_pos;
+  to->max_dam = from->max_dam;
+  to->effectiveness = STRDUP(from->effectiveness);
+  to->damages = STRDUP(from->damages);
+  to->delay = STRDUP(from->delay);
+  to->script = STRDUP(from->script);
+  to->summon_mob = STRDUP(from->summon_mob);
+  to->summon_req = STRDUP(from->summon_req);
+
+  to->messages.wear_off = STRDUP(from->messages.wear_off);
+  to->messages.to_self = STRDUP(from->messages.to_self);
+  to->messages.to_vict = STRDUP(from->messages.to_vict);
+  to->messages.to_room = STRDUP(from->messages.to_room);
+
+  to->points.hp = STRDUP(from->points.hp);
+  to->points.mana = STRDUP(from->points.mana);
+  to->points.move = STRDUP(from->points.move);
+  to->points.gold = STRDUP(from->points.gold);
+
+  for (i=0; i<MAX_SPELL_PROTECTIONS; i++) {
+    to->protfrom[i].prot_num = from->protfrom[i].prot_num;
+    to->protfrom[i].duration = STRDUP(from->protfrom[i].duration);
+    to->protfrom[i].resist = STRDUP(from->protfrom[i].resist);
+  }
+
+  for (i=0; i<MAX_SPELL_AFFECTS; i++) {
+    to->applies[i].appl_num = from->applies[i].appl_num;
+    to->applies[i].modifier = STRDUP(from->applies[i].modifier);
+    to->applies[i].duration = STRDUP(from->applies[i].duration);
+  }
+ 
+  for (i=0; i<MAX_SPELL_OBJECTS; i++)
+    to->objects[i] = STRDUP(from->objects[i]);
+
+  for (i=0; i<MAX_SPELL_DISPEL; i++)
+    to->dispel[i] = STRDUP(from->dispel[i]);
+
+  for (i=0; i<NUM_CLASSES; i++) {
+    to->assign[i].class_num = from->assign[i].class_num;
+    to->assign[i].level = from->assign[i].level;
+    to->assign[i].prac_gain = STRDUP(from->assign[i].prac_gain);
+    to->assign[i].num_mana = STRDUP(from->assign[i].num_mana);
+  }
+  to->function = from->function;
+}
+
+void spedit_save_internally (struct str_spells *spell) 
+{
+ struct str_spells *i, *p = NULL;
+
+ for (i = list_spells; i; p = i, i = i->next)
+   if (i->vnum >= spell->vnum)
+     break;
+
+ if (i && (i->vnum == spell->vnum)) {
+   if (!i->function)
+     spedit_copyover_spell(spell, i);
+   else
+     i->status = spell->status;
+
+   return;
+ }
+
+ if (spell->vnum > last_spell_vnum)
+   last_spell_vnum = spell->vnum;
+
+ if (p)
+   p->next = spell;
+ else
+   list_spells = spell;
+ 
+  spell->next = i;
+}
+
+void spedit_init_new_spell (struct str_spells *spell)
+{
+ int i;
+
+ spell->next     = NULL;
+ spell->status   = unavailable;
+ spell->type     = 'P';
+ spell->name     = NULL;
+ spell->targ_flags = 0;
+ spell->mag_flags = 0;
+ spell->min_pos  = 0;
+ spell->max_dam  = 0;
+ spell->violent  = FALSE;
+ spell->effectiveness = NULL;
+ spell->damages  = NULL;
+ spell->delay    = NULL;
+ spell->script   = NULL;
+ spell->summon_mob = NULL;
+ spell->summon_req = NULL;
+
+ spell->messages.wear_off = NULL;
+ spell->messages.to_self = NULL;
+ spell->messages.to_vict = NULL;
+ spell->messages.to_room = NULL;
+
+ spell->points.hp = NULL;
+ spell->points.mana = NULL;
+ spell->points.move = NULL;
+ spell->points.gold = NULL;
+
+ for (i=0; i<MAX_SPELL_PROTECTIONS; i++) {
+   spell->protfrom[i].prot_num = -1;
+   spell->protfrom[i].duration = NULL;
+   spell->protfrom[i].resist   = NULL;
+ }
+
+ for (i=0; i<MAX_SPELL_AFFECTS; i++) {
+   spell->applies[i].appl_num  = -1;
+   spell->applies[i].modifier  = NULL;
+   spell->applies[i].duration  = NULL;
+ }
+
+ for (i=0; i<MAX_SPELL_OBJECTS; i++)
+   spell->objects[i] = NULL;
+
+ for (i=0; i<MAX_SPELL_DISPEL; i++)
+   spell->dispel[i] = NULL;
+
+ for (i=0; i<NUM_CLASSES; i++) {
+   spell->assign[i].class_num  = -1;
+   spell->assign[i].level      = 0;
+   spell->assign[i].prac_gain   = NULL;
+   spell->assign[i].num_mana   = NULL;
+ }
+ spell->function               = NULL;
+}
+
+int spedit_create_spell (struct descriptor_data *d)
+{
+ struct str_spells *q = NULL;
+
+ int vnum = 0;
+
+ // if OLC_NUM(d) != 0 we search that vnum spell, 
+ // otherwise we search the end of the list to create a new spell there. at last VNUM + 1.
+ for (q = list_spells; q; q = q->next) {
+   vnum = q->vnum;
+
+   if (q->vnum && (q->vnum == OLC_NUM(d)))
+     break;
+ }
+
+ // if OLC_NUM(d) == 0 that means we want to create a new spell,
+ // if so we start from last VNUM + 1 and we search for the first
+ // free VNUM that isn't OLCING by someone else.
+ if (!OLC_NUM(d)) {
+   while (SPELL_OLCING_BY(++vnum));
+
+   if (vnum > MAX_SKILLS) {
+     mudlog (BRF, LVL_BUILDER, TRUE, "SYSERR: Spedit: Spells and skills limits reached.");
+     return 0;
+   }
+
+   OLC_NUM(d) = vnum;
+ }
+
+ CREATE (OLC_SPELL(d), struct str_spells, 1);
+ OLC_SPELL(d)->vnum = OLC_NUM(d);
+
+ if (q) 
+   spedit_copyover_spell(q, OLC_SPELL(d));
+ else {
+   spedit_init_new_spell(OLC_SPELL(d));
+   OLC_SPELL(d)->name = strdup(UNDEF_SPELL);
+ }
+
+ return 1;
+}
+
+int boot_spells (void)
+{
+ char buf[MAX_STRING_LENGTH + 1] = "";
+ char buf1[MAX_STRING_LENGTH + 1] = "";
+
+ FILE *fp;
+ int  x, ret, fct, d1, err = 0, save = 0;
+ struct str_spells *Q = NULL;
+
+ if ((fp=fopen(SPELL_FILE, "r")) == NULL) {
+    mudlog (BRF, LVL_BUILDER, TRUE, "SYSERR: BOOT: Can't boot spells.");
+    return 0;
+ }
+
+ while (!feof(fp)) {
+    ret = fscanf (fp, "%d ", &fct);
+    if (!save && (fct != DB_CODE_INIT_VARS)) {
+      mudlog (BRF, LVL_BUILDER, TRUE, "SYSERR: BOOT SPELLS: attemp to assign value to Q == (null)");
+      abort();
+    }
+    switch (fct) {
+      case DB_CODE_INIT_VARS : 
+               if (save == 1) 
+                 spedit_save_internally (Q); 
+               else  
+                 save = 1;
+               CREATE (Q, struct str_spells, 1);
+               spedit_init_new_spell (Q);
+               ret = fscanf (fp, "%c %d %d %d %d %d %d\n", &Q->type, &Q->vnum, &Q->status,
+                                 &Q->targ_flags, &Q->mag_flags, &Q->min_pos, &Q->max_dam);
+               if (Q->vnum > MAX_SKILLS) {
+                 mudlog (BRF, LVL_BUILDER, TRUE, "SYSERR: BOOT SPELLS: spell vnum > MAX_SKILLS");
+                 abort();
+               }
+               break;
+      case DB_CODE_NAME : 
+               if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 buf[strlen(buf)-1] = '\0'; 
+                 Q->name = strdup (buf);
+               }
+               break;
+      case DB_CODE_DAMAGES : 
+              if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 buf[strlen(buf)-1] = '\0'; 
+                 Q->damages = strdup (buf);
+               }
+               break;
+      case DB_CODE_MSG_WEAR_OFF : 
+              if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 buf[strlen(buf)-1] = '\0';
+                 Q->messages.wear_off = strdup (buf);
+               }
+               break;
+      case DB_CODE_MSG_TO_SELF : 
+              if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 buf[strlen(buf)-1] = '\0';
+                 Q->messages.to_self = strdup (buf);
+               }
+               break;
+      case DB_CODE_MSG_TO_VICT : 
+              if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 buf[strlen(buf)-1] = '\0';
+                 Q->messages.to_vict = strdup (buf);
+               }
+               break;
+      case DB_CODE_MSG_TO_ROOM : 
+              if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 buf[strlen(buf)-1] = '\0';
+                 Q->messages.to_room = strdup (buf);
+              }
+              break;
+      case DB_CODE_SUMMON_MOB:
+              if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 buf[strlen(buf)-1] = '\0';
+                 Q->summon_mob = strdup (buf);
+              }
+              break;
+      case DB_CODE_SUMMON_REQ:
+              if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 buf[strlen(buf)-1] = '\0';
+                 Q->summon_req = strdup (buf);
+              }
+              break;
+      case DB_CODE_DISPEL_1 : 
+      case DB_CODE_DISPEL_2 : 
+      case DB_CODE_DISPEL_3 : 
+               x = fct - DB_CODE_DISPEL_1;
+               if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 buf[strlen(buf)-1] = '\0';
+                 Q->dispel[x] = strdup(buf);
+               }
+               break;
+      case DB_CODE_OBJECTS_1 : 
+      case DB_CODE_OBJECTS_2 : 
+      case DB_CODE_OBJECTS_3 : 
+               x = fct - DB_CODE_OBJECTS_1;
+               if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  buf[strlen(buf)-1] = '\0';
+                  Q->objects[x] = strdup (buf);
+                }
+                break;
+      case DB_CODE_PTS_HP :
+               if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  buf[strlen(buf)-1] = '\0';
+                  Q->points.hp = strdup (buf);
+                }
+                break;
+      case DB_CODE_PTS_MANA :
+               if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  buf[strlen(buf)-1] = '\0';
+                  Q->points.mana = strdup (buf);
+                }
+                break;
+      case DB_CODE_PTS_MOVE :
+               if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  buf[strlen(buf)-1] = '\0';
+                  Q->points.move = strdup (buf);
+                }
+                break;
+      case DB_CODE_PTS_GOLD :
+               if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  buf[strlen(buf)-1] = '\0';
+                  Q->points.gold = strdup (buf);
+                }
+                break;
+      case DB_CODE_PROT_1 :
+      case DB_CODE_PROT_2 :
+      case DB_CODE_PROT_3 :
+      case DB_CODE_PROT_4 :
+      case DB_CODE_PROT_5 :
+      case DB_CODE_PROT_6 :
+               x = fct - DB_CODE_PROT_1;
+               if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  ret = sscanf (buf, "%d %[^\n]", &Q->protfrom [x].prot_num, buf1);
+                  if (ret == 2) Q->protfrom [x].duration = strdup(buf1);
+               }
+               if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                 ret = sscanf (buf, "%d %[^\n]", &d1, buf1);
+                 if (d1 != DB_CODE_MARKER)
+                   log("SYSERR: boot spells: Invalid marker in DB_CODE_PROT_%d", x + 1); 
+                 if (ret == 2) Q->protfrom [x].resist = strdup(buf1); 
+               } 
+               break;
+      case DB_CODE_AFFECTS_1 :
+      case DB_CODE_AFFECTS_2 :
+      case DB_CODE_AFFECTS_3 :
+      case DB_CODE_AFFECTS_4 :
+      case DB_CODE_AFFECTS_5 :
+      case DB_CODE_AFFECTS_6 :
+                x = fct - DB_CODE_AFFECTS_1;
+                if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  ret = sscanf (buf, "%d %[^\n]", &Q->applies[x].appl_num, buf1);
+                  if (ret == 2) Q->applies[x].modifier = strdup(buf1);
+                }
+                if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  ret = sscanf (buf, "%d %[^\n]", &d1, buf1);
+                  if (d1 != DB_CODE_MARKER)
+                    log("SYSERR: boot spells: Invalid marker in DB_CODE_AFFECTS_%d", x + 1); 
+                  if (ret == 2) Q->applies[x].duration = strdup (buf1);
+                } 
+                break;
+      case DB_CODE_CLASS_MU :
+      case DB_CODE_CLASS_CL :
+      case DB_CODE_CLASS_TH :
+      case DB_CODE_CLASS_WA :
+                x = fct - DB_CODE_CLASS_MU;
+                if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  ret = sscanf (buf, "%d %d %[^\n]", &Q->assign [x].class_num, &Q->assign [x].level, buf1);
+                  if (ret == 3) Q->assign [x].prac_gain = strdup (buf1);
+                  if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                    ret = sscanf (buf, "%d %[^\n]", &d1, buf1);
+                    if (d1 != DB_CODE_MARKER)
+                      log("SYSERR: boot spells: Invalid marker in DB_CODE_CLASS: %d", x + 1); 
+                    if (ret == 2) Q->assign[x].num_mana = strdup (buf1);
+                  }
+                }
+                break;
+      case DB_CODE_EFFECTIVENESS : 
+                if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  buf[strlen(buf)-1] = '\0'; 
+                  Q->effectiveness = strdup (buf);
+                }
+                break; 
+      case DB_CODE_DELAY : 
+                if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  buf[strlen(buf)-1] = '\0'; 
+                  Q->delay = strdup (buf);
+                }
+                break;
+      case DB_CODE_SCRIPT : 
+                if (fgets (buf, MAX_STRING_LENGTH, fp)) {
+                  if (!Q->script)
+                    Q->script = strdup (buf); 
+                  else {
+                    snprintf (buf1, BUFSIZE, "%s%s", Q->script, buf); 
+                    if (strlen(buf1) == BUFSIZE) 
+                      log("SYSERR: boot spells: spell script buffer overflow"); 
+                    free (Q->script);
+                    Q->script = strdup (buf1);
+                  } 
+                }   
+                break;
+      case DB_CODE_END : break;    
+      default : if (err++ > 9) {
+                  log ("SYSERR: BOOT SPELLS: program abort too much errors.");
+                  abort();
+                } else
+                    log ("SYSERR: BOOT SPELLS: invalide code in database.");
+    } 
+ }
+
+ if (save == 1)
+   spedit_save_internally (Q); 
+ else
+   mudlog (BRF, LVL_BUILDER, TRUE, "SYSERR: BOOT SPELLS: No spells available!");
+
+ return 1;
+}
+
+void spedit_save_to_disk (void)
+{
+ char buf[BUFSIZE] = "";  
+ char buf1[BUFSIZE] = "";
+ char outbuf[MAX_STRING_LENGTH] = "";
+
+ FILE *fp;
+ struct str_spells *r;
+ char *p;
+
+ sprintf (buf, "cp %s %s.bak", SPELL_FILE, SPELL_FILE);
+ if (system (buf) == -1) {
+   mudlog (BRF, LVL_BUILDER, TRUE, "SYSERR: SPEDIT: Failed to create spell file backup.");
+ }
+
+ if ((fp=fopen(SPELL_FILE, "w")) == NULL) {
+   mudlog (BRF, LVL_BUILDER, TRUE, "SYSERR: SPEDIT: Can't save spells to the database.");
+   return;
+ }
+
+ setbuf(fp, outbuf);
+
+ for (r = list_spells; r; r = r->next) {
+   snprintf (buf, BUFSIZE, "%2d %c %d %d %d %d %d %d\n", DB_CODE_INIT_VARS,
+                            r->type, r->vnum, r->status, r->targ_flags, r->mag_flags, r->min_pos, r->max_dam);
+   fprintf(fp, "%s", buf);
+ 
+   if (r->name) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_NAME, r->name);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->damages) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_DAMAGES, r->damages);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->messages.wear_off) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_MSG_WEAR_OFF, r->messages.wear_off);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->messages.to_self) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_MSG_TO_SELF, r->messages.to_self);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->messages.to_vict) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_MSG_TO_VICT, r->messages.to_vict);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->messages.to_room) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_MSG_TO_ROOM, r->messages.to_room);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->summon_mob) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_SUMMON_MOB, r->summon_mob);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->summon_req) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_SUMMON_REQ, r->summon_req);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->dispel[0]) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_DISPEL_1, r->dispel[0]);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->dispel[1]) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_DISPEL_2, r->dispel[1]);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->dispel[2]) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_DISPEL_3, r->dispel[2]);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->objects[0]) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_OBJECTS_1, r->objects[0]);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->objects[1]) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_OBJECTS_2, r->objects[1]);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->objects[2]) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_OBJECTS_3, r->objects[2]);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->points.hp) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_PTS_HP, r->points.hp);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->points.mana) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_PTS_MANA, r->points.mana);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->points.move) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_PTS_MOVE, r->points.move);
+     fprintf(fp, "%s", buf);
+   }
+   if (r->points.gold) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_PTS_GOLD, r->points.gold);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->protfrom[0].prot_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_PROT_1, 
+                              r->protfrom[0].prot_num, r->protfrom[0].duration, DB_CODE_MARKER, r->protfrom[0].resist);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->protfrom[1].prot_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_PROT_2, 
+                              r->protfrom[1].prot_num, r->protfrom[1].duration, DB_CODE_MARKER, r->protfrom[1].resist);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->protfrom[2].prot_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_PROT_3,
+                              r->protfrom[2].prot_num, r->protfrom[2].duration, DB_CODE_MARKER, r->protfrom[2].resist);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->protfrom[3].prot_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_PROT_4, 
+                              r->protfrom[3].prot_num, r->protfrom[3].duration, DB_CODE_MARKER, r->protfrom[3].resist);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->protfrom[4].prot_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_PROT_5, 
+                              r->protfrom[4].prot_num, r->protfrom[4].duration, DB_CODE_MARKER, r->protfrom[4].resist);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->protfrom[5].prot_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_PROT_6, 
+                              r->protfrom[5].prot_num, r->protfrom[5].duration, DB_CODE_MARKER, r->protfrom[5].resist);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->applies[0].appl_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_AFFECTS_1, 
+                              r->applies[0].appl_num, NULL_STR(r->applies[0].modifier), DB_CODE_MARKER, r->applies[0].duration);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->applies[1].appl_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_AFFECTS_2, 
+                              r->applies[1].appl_num, NULL_STR(r->applies[1].modifier), DB_CODE_MARKER, r->applies[1].duration);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->applies[2].appl_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_AFFECTS_3, 
+                              r->applies[2].appl_num, NULL_STR(r->applies[2].modifier), DB_CODE_MARKER, r->applies[2].duration);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->applies[3].appl_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_AFFECTS_4, 
+                              r->applies[3].appl_num, NULL_STR(r->applies[3].modifier), DB_CODE_MARKER, r->applies[3].duration);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->applies[4].appl_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_AFFECTS_5, 
+                              r->applies[4].appl_num, NULL_STR(r->applies[4].modifier), DB_CODE_MARKER, r->applies[4].duration);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->applies[5].appl_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %s\n%2d %s\n", DB_CODE_AFFECTS_6, 
+                              r->applies[5].appl_num, NULL_STR(r->applies[5].modifier), DB_CODE_MARKER, r->applies[5].duration);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->assign[0].class_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %d %s\n%2d %s\n", DB_CODE_CLASS_MU, 
+                              r->assign[0].class_num, r->assign[0].level, NULL_STR(r->assign[0].prac_gain), DB_CODE_MARKER, NULL_STR(r->assign[0].num_mana));
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->assign[1].class_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %d %s\n%2d %s\n", DB_CODE_CLASS_CL, 
+                              r->assign[1].class_num, r->assign[1].level, NULL_STR(r->assign[1].prac_gain), DB_CODE_MARKER, NULL_STR(r->assign[1].num_mana));
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->assign[2].class_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %d %s\n%2d %s\n", DB_CODE_CLASS_TH, 
+                              r->assign[2].class_num, r->assign[2].level, NULL_STR(r->assign[2].prac_gain), DB_CODE_MARKER, NULL_STR(r->assign[2].num_mana));
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->assign[3].class_num != -1) {
+     snprintf (buf, BUFSIZE, "%2d %d %d %s\n%2d %s\n", DB_CODE_CLASS_WA, 
+                              r->assign[3].class_num, r->assign[3].level, NULL_STR(r->assign[3].prac_gain), DB_CODE_MARKER, NULL_STR(r->assign[3].num_mana));
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->effectiveness) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_EFFECTIVENESS, r->effectiveness);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->delay) {
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_DELAY, r->delay);
+     fprintf(fp, "%s", buf);
+   }
+
+   if (r->script) {
+     strncpy (buf1, r->script, BUFSIZE); 
+     p = strtok (buf1, "\n");
+     snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_SCRIPT, p);
+     fprintf(fp, "%s", buf);
+     while ((p=strtok('\0', "\n"))) {
+       snprintf (buf, BUFSIZE, "%2d %s\n", DB_CODE_SCRIPT, p);
+       fprintf(fp, "%s", buf);
+     }
+   }
+ }
+ fprintf (fp, "%2d\n", DB_CODE_END);
+ fflush (fp);
+ fclose (fp);
+}
+
+int spedit_setup2 (struct descriptor_data *d)
+{
+ /* Send the OLC message to the players in the same room as the builder. */
+ act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
+ SET_BIT_AR(PLR_FLAGS(d->character), PLR_WRITING);
+
+ if (spedit_create_spell (d))
+   spedit_main_menu (d);
+ else {
+   send_to_char (d->character, "Failed the limits of spells and skills has been reached!\r\n");
+   cleanup_olc (d, CLEANUP_ALL);
+   return 0;
+ }
+
+ return 1;
+}
+
+int spedit_setup (struct descriptor_data *d)
+{
+ char buf[BUFSIZE];
+ char *str;
+ const char *name;
+ int vnum;
+ 
+ OLC_NUM(d) = 0;
+
+ if (OLC_STORAGE(d)) {
+   if (is_number(OLC_STORAGE(d)))
+     vnum = atoi(OLC_STORAGE(d));
+   else
+     vnum = olc_spell_by_name(d, OLC_STORAGE(d));
+
+   // we don't allow to edit spell vnum 0 anyway.
+   if (!vnum) {
+     send_to_char (d->character, "that spell could not be found!\r\n");
+     cleanup_olc (d, CLEANUP_ALL);
+     return 0;
+   } else {
+       if (vnum < 0) {
+         send_to_char (d->character, "The spell (vnum: %d) must be above 0.\r\n", vnum);
+         cleanup_olc (d, CLEANUP_ALL);
+         return 0;
+       }
+
+       if (vnum > last_spell_vnum) {
+         send_to_char (d->character, "This spell (vnum: %d) is out of bound. Try 'spedit' to create a new spell.\r\n", vnum);
+         cleanup_olc (d, CLEANUP_ALL);
+         return 0;
+       } 
+
+       name = get_spell_name(vnum);
+
+       if ((str = SPELL_OLCING_BY (vnum))) {
+         sprintf (buf, "This spell '%s' (vnum: %d) is already edited by %s.\r\n", name, vnum, str);
+         send_to_char (d->character, "%s", buf);  
+         cleanup_olc (d, CLEANUP_ALL);
+         return 0;
+       }
+
+       OLC_NUM(d) = vnum;
+
+       if (name != UNDEF_SPELL) {
+         sprintf (buf, "Do you want to edit '%s' (vnum: %d)? (y/n%s): ", name, vnum, 
+                       OLC_SEARCH(d) ? ", q" : "");
+         send_to_char (d->character, "%s", buf);  
+         OLC_MODE(d) = SPEDIT_CONFIRM_EDIT;
+         return 1;
+       }
+     }
+ }
+
+ spedit_setup2(d);
+ return 1;
+}
+
+void spedit_parse (struct descriptor_data *d, char *arg) {
+  const char *points[] = { "Hit points += ",
+                           "Mana points += ",
+                           "Move points += ",
+                           "Gold += " }; 
+  char buf[BUFSIZE];
+  char *oldtext;
+
+  int x = 0, value, rts_code = 0;
+  struct str_spells *to;
+
+  switch (OLC_MODE(d)) {
+    case SPEDIT_CONFIRM_SAVESTRING:
+        switch (*arg) {
+          case 'y' :
+          case 'Y' : to = get_spell_by_vnum(OLC_NUM(d));
+
+                     if (!to) {
+                       spedit_save_internally(OLC_SPELL(d));
+                       OLC_SPELL(d) = NULL;  // now, it's not a copy, it's saved in memory. 
+                                             // the pointer must be NULLed, to avoid cleanup_olc to free the structure.
+                     }
+                     else 
+                       spedit_copyover_spell(OLC_SPELL(d), to); 
+
+                     sprintf (buf, "OLC: %s edits spells %d.", GET_NAME(d->character), OLC_NUM(d));
+                     mudlog (CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE, "%s", buf);
+
+                     send_to_char (d->character, "Spell saved to disk.\r\n");
+                     spedit_save_to_disk();
+
+                     cleanup_olc (d, CLEANUP_ALL);
+                     break;
+          case 'n' :
+          case 'N' : cleanup_olc (d, CLEANUP_ALL); 
+                     break;
+          default  : send_to_char (d->character, "Invalid choice!\r\nDo you want to save this spell to disk? : ");
+                     break;
+        }
+        return;
+    case SPEDIT_GET_TYPE : OLC_SPELL(d)->type = (atoi(arg) == 1) ? SKILL : SPELL;
+                           // SKILL don't use mana
+                           if (OLC_SPELL(d)->type == SKILL) {
+                             SAFE_FREE(OLC_SPELL(d)->assign[0].num_mana);
+                             SAFE_FREE(OLC_SPELL(d)->assign[1].num_mana);
+                             SAFE_FREE(OLC_SPELL(d)->assign[2].num_mana);
+                             SAFE_FREE(OLC_SPELL(d)->assign[3].num_mana);
+                           }
+                           break;  
+    case SPEDIT_GET_NUMMANA : value = formula_interpreter (d->character,
+                                      d->character, OLC_NUM(d), FALSE,
+                                      arg, GET_LEVEL(d->character), &rts_code);
+                              if (!rts_code) {
+                               SAFE_FREE(OLC_SPELL(d)->assign[OLC_VAL(d)].num_mana);
+                               OLC_SPELL(d)->assign[OLC_VAL(d)].num_mana = STRDUP(arg);
+                               spedit_assign_menu(d);
+                             } else 
+                                 send_to_char (d->character, "Num mana : ");
+                             return;
+    case SPEDIT_GET_NAME   : SAFE_FREE(OLC_SPELL(d)->name);
+                             OLC_SPELL(d)->name = 
+                               (arg && *arg) ? strdup(arg) : strdup(UNDEF_SPELL);
+                             break;
+    case SPEDIT_GET_PROTDUR: value = formula_interpreter (d->character, 
+                                     d->character, OLC_NUM(d), FALSE,
+                                     arg, GET_LEVEL(d->character), &rts_code);
+                             if (!rts_code) { 
+                               SAFE_FREE(OLC_SPELL(d)->protfrom[OLC_VAL(d)].duration);
+                               OLC_SPELL(d)->protfrom[OLC_VAL(d)].duration = STRDUP(arg);
+                               send_to_char (d->character, "Resist %% : ");
+                               OLC_MODE(d) = SPEDIT_GET_RESIST;
+                             } else 
+                                 send_to_char (d->character, "Duration : ");
+                             return;
+    case SPEDIT_GET_SPELL_NUM : if ((*arg == 'r') || (*arg == 'R')) {
+                                  OLC_SPELL(d)->protfrom[OLC_VAL(d)].prot_num = -1;
+                                  SAFE_FREE(OLC_SPELL(d)->protfrom[OLC_VAL(d)].duration);
+                                  SAFE_FREE(OLC_SPELL(d)->protfrom[OLC_VAL(d)].resist);
+                                  spedit_protection_menu (d);
+                                  return; 
+                                }
+                                if (!atoi(arg)) 
+                                  spedit_protection_menu (d);
+                                else {
+                                  int vnum = atoi(arg);
+                                  if (!get_spell_by_vnum(vnum)) {
+                                    send_to_char (d->character, "Invalid: spell not found!\r\n"
+                                                                "\r\nSpell VNUM (0 to quit, 'r' to remove) : ");
+                                  } else {
+                                      OLC_SPELL(d)->protfrom[OLC_VAL(d)].prot_num = vnum;
+                                      send_to_char (d->character, "Duration : ");
+                                      OLC_MODE(d) = SPEDIT_GET_PROTDUR;
+                                    }
+                                }
+                                return; 
+    case SPEDIT_GET_NUMPRAC: value = formula_interpreter (d->character, 
+                                     d->character, OLC_NUM(d), FALSE,
+                                     arg, GET_LEVEL(d->character), &rts_code);
+                             if (!rts_code) {  
+                                SAFE_FREE(OLC_SPELL(d)->assign[OLC_VAL(d)].prac_gain);
+                                OLC_SPELL(d)->assign[OLC_VAL(d)].prac_gain = STRDUP(arg);
+                                if (OLC_SPELL(d)->type == SPELL) {
+                                  send_to_char (d->character, "Num mana : ");
+                                  OLC_MODE(d) = SPEDIT_GET_NUMMANA;
+                                } else {
+                                    spedit_assign_menu(d);
+                                    return;
+                                  }
+                             } else 
+                                 send_to_char (d->character, "Practice gain %% : ");
+                             return;
+    case SPEDIT_GET_LEVEL  : OLC_SPELL(d)->assign[OLC_VAL(d)].level = atoi(arg);
+                             send_to_char (d->character, "Practice gain %% : ");
+                             OLC_MODE (d) = SPEDIT_GET_NUMPRAC;
+                             return; 
+    case SPEDIT_GET_MODIF  : value = formula_interpreter (d->character,
+                                     d->character, OLC_NUM(d), FALSE,
+                                     arg, GET_LEVEL(d->character), &rts_code);
+                             if (!rts_code) {  
+                               SAFE_FREE(OLC_SPELL(d)->applies[OLC_VAL(d)].modifier);
+                               OLC_SPELL(d)->applies[OLC_VAL(d)].modifier = STRDUP(arg);
+                               send_to_char (d->character, "Duration : ");
+                               OLC_MODE (d) = SPEDIT_GET_APPLDUR;
+                              } else 
+                                  send_to_char (d->character, "Modifier : ");
+                              return;
+    case SPEDIT_GET_APPLDUR : value = formula_interpreter (d->character,
+                                      d->character, OLC_NUM(d), FALSE, 
+                                      arg, GET_LEVEL(d->character), &rts_code);
+                              if (!rts_code) {
+                                SAFE_FREE(OLC_SPELL(d)->applies[OLC_VAL(d)].duration);
+                                OLC_SPELL(d)->applies[OLC_VAL(d)].duration = STRDUP(arg);
+                                spedit_apply_menu (d);
+                              } else 
+                                  send_to_char (d->character, "Duration : ");
+                              return;
+    case SPEDIT_GET_MAXDAM  : OLC_SPELL(d)->max_dam = atoi(arg);
+                              break;
+    case SPEDIT_GET_DAMAGES : value = formula_interpreter (d->character,
+                                      d->character, OLC_NUM(d), FALSE,
+                                      arg, GET_LEVEL(d->character), &rts_code);
+                              if (!rts_code) {
+                                SAFE_FREE(OLC_SPELL(d)->damages);
+                                OLC_SPELL(d)->damages = STRDUP(arg);
+                                send_to_char (d->character, "Max damages : ");
+                                OLC_MODE(d) = SPEDIT_GET_MAXDAM;
+                              } else 
+                                  send_to_char (d->character, "Damages : ");
+                              return; 
+    case SPEDIT_GET_EFFECTIVENESS : 
+                              value = formula_interpreter (d->character,
+                                      d->character, OLC_NUM(d), FALSE,
+                                      arg, GET_LEVEL(d->character), &rts_code);
+                              if (!rts_code) {
+                                SAFE_FREE(OLC_SPELL(d)->effectiveness);
+                                OLC_SPELL(d)->effectiveness = STRDUP(arg);
+                                break;
+                              } else 
+                                  send_to_char (d->character, "%% of effectiveness : ");
+                              return;
+    case SPEDIT_GET_RESIST  : value = formula_interpreter (d->character,
+                                      d->character, OLC_NUM(d), FALSE,
+                                      arg, GET_LEVEL(d->character), &rts_code);
+                              if (!rts_code) {
+                                SAFE_FREE(OLC_SPELL(d)->protfrom[OLC_VAL(d)].resist);
+                                OLC_SPELL(d)->protfrom[OLC_VAL(d)].resist = STRDUP(arg);
+                                spedit_protection_menu(d);
+                              } else  
+                                  send_to_char (d->character, "Resist %% : ");
+                              return;
+    case SPEDIT_GET_DELAY   : value = formula_interpreter (d->character,
+                                      d->character, OLC_NUM(d), FALSE,
+                                      arg, GET_LEVEL(d->character), &rts_code);
+                              if (!rts_code) {
+                                SAFE_FREE(OLC_SPELL(d)->delay);
+                                OLC_SPELL(d)->delay = STRDUP(arg);
+                                break;
+                              } else 
+                                  send_to_char (d->character, "Passes (10 passes = 1 sec) : ");
+                              return;  
+    case SPEDIT_GET_STATUS  : if ((x = atoi(arg)) == available)
+                                OLC_SPELL(d)->status = x;
+                              else
+                                OLC_SPELL(d)->status = unavailable;
+                              break;  
+    case SPEDIT_ASSIGN_MENU :
+           if (!(x = atoi(arg))) break;
+           if ((x > 0) && (x < 5)) {
+             OLC_VAL (d) = x - 1;
+             spedit_assignement_menu (d);
+           } else {
+               send_to_char (d->character, "Invalid choice!\r\n");
+               spedit_assign_menu (d);
+             }
+           return;
+    case SPEDIT_APPLY_MENU : 
+           if (!(x = atoi(arg))) break;
+           if ((x > 0) && (x < MAX_SPELL_AFFECTS)) {
+             OLC_VAL(d) = x - 1;  
+             spedit_choose_apply (d);
+           } else {
+               send_to_char (d->character, "Invalid choice!\r\n");
+               spedit_apply_menu (d);
+             } 
+           return; 
+    case SPEDIT_SHOW_APPLY : 
+           if ((*arg == 'r') || (*arg == 'R')) {
+             OLC_SPELL(d)->applies[OLC_VAL(d)].appl_num = - 1;
+             SAFE_FREE(OLC_SPELL(d)->applies[OLC_VAL(d)].modifier);
+             SAFE_FREE(OLC_SPELL(d)->applies[OLC_VAL(d)].duration);
+             spedit_apply_menu (d);
+             return; 
+           }
+
+           if (!(x = atoi(arg))) 
+             spedit_apply_menu (d);
+           else
+             if ((x < 0) || (x > NUM_APPLIES + NUM_AFF_FLAGS)) {
+               send_to_char (d->character, "Invalid choice!\r\n");
+               spedit_choose_apply (d);
+             } else {
+                  if (x <= NUM_APPLIES) {
+                    OLC_SPELL(d)->applies[OLC_VAL(d)].appl_num = x - 1;
+                    send_to_char (d->character, "Modifier : ");
+                    OLC_MODE(d) = SPEDIT_GET_MODIF;
+                  } else {
+                      OLC_SPELL(d)->applies[OLC_VAL(d)].appl_num = x;
+                      SAFE_FREE(OLC_SPELL(d)->applies[OLC_VAL(d)].modifier);
+                      send_to_char (d->character, "Duration : ");
+                      OLC_MODE (d) = SPEDIT_GET_APPLDUR;
+                    }
+               }
+           return; 
+    case SPEDIT_SHOW_ASSIGNEMENT :
+           if ((*arg == 'r') || (*arg == 'R')) {
+             OLC_SPELL(d)->assign[OLC_VAL(d)].class_num = -1;
+             OLC_SPELL(d)->assign[OLC_VAL(d)].level = 0;
+             SAFE_FREE(OLC_SPELL(d)->assign[OLC_VAL(d)].prac_gain);
+             SAFE_FREE(OLC_SPELL(d)->assign[OLC_VAL(d)].num_mana);
+             spedit_assign_menu(d);
+             return;
+           }
+           if (!(x = atoi (arg))) 
+             spedit_assign_menu (d);
+           else 
+           if ((x < 1) || (x > NUM_CLASSES)) {
+             send_to_char (d->character, "Invalid choice!\r\n");
+             spedit_assignement_menu (d);
+           } else {
+               OLC_SPELL(d)->assign[OLC_VAL(d)].class_num = x - 1;
+               send_to_char (d->character, "Level : ");
+               OLC_MODE(d) = SPEDIT_GET_LEVEL;
+             }
+           return;
+    case SPEDIT_GET_MSG_WEAR_OFF :
+         delete_doubledollar(arg);
+         SAFE_FREE(OLC_SPELL(d)->messages.wear_off);
+         OLC_SPELL(d)->messages.wear_off = STRDUP(arg);
+         spedit_show_messages (d);
+         return;
+    case SPEDIT_GET_MSG_TO_SELF :
+         delete_doubledollar(arg);
+         SAFE_FREE(OLC_SPELL(d)->messages.to_self);
+         OLC_SPELL(d)->messages.to_self = STRDUP(arg);
+         spedit_show_messages (d);
+         return;
+    case SPEDIT_GET_MSG_TO_VICT :
+         delete_doubledollar(arg);
+         SAFE_FREE(OLC_SPELL(d)->messages.to_vict);
+         OLC_SPELL(d)->messages.to_vict = STRDUP(arg);
+         spedit_show_messages (d);
+         return;
+    case SPEDIT_GET_MSG_TO_ROOM :
+         delete_doubledollar(arg);
+         SAFE_FREE(OLC_SPELL(d)->messages.to_room);
+         OLC_SPELL(d)->messages.to_room = STRDUP(arg);
+         spedit_show_messages (d);
+         return;
+    case SPEDIT_SHOW_MESSAGES :
+         x = atoi(arg); 
+         switch (x) {
+           case 0 : break;
+           case 1 : send_to_char(d->character, "Wear off : ");
+                    OLC_MODE(d) = SPEDIT_GET_MSG_WEAR_OFF; return;
+           case 2 : send_to_char(d->character, "To self: ");
+                    OLC_MODE(d) = SPEDIT_GET_MSG_TO_SELF; return;
+           case 3 : send_to_char(d->character, "To victim: ");  
+                    OLC_MODE(d) = SPEDIT_GET_MSG_TO_VICT; return;
+           case 4 : send_to_char(d->character, "To room: "); 
+                    OLC_MODE(d) = SPEDIT_GET_MSG_TO_ROOM; return;
+           default : send_to_char (d->character, "Invalid choice!\r\n");
+                     spedit_show_messages (d);
+                     return;
+           }
+    case SPEDIT_GET_MINPOS :
+         if (!(x = atoi(arg))) break;
+         if ((x < 0) || (x > NUM_CHAR_POSITION)) {
+           send_to_char (d->character, "Invalid choice!\r\n");
+           spedit_minpos_menu (d);
+           return;
+         }   
+         else
+           OLC_SPELL(d)->min_pos = x - 1;
+         break;   
+    case SPEDIT_SHOW_TARG_FLAGS : 
+         if (!(x = atoi (arg))) break;
+         if ((x < 0) || (x > NUM_SPELL_FLAGS)) 
+           send_to_char (d->character, "Invalid choice!\r\n");
+         else
+           OLC_SPELL(d)->targ_flags ^= (1 << (x - 1));
+         spedit_targ_flags_menu (d);
+         return;
+    case SPEDIT_SHOW_MAG_FLAGS:
+         if (!(x = atoi (arg))) break;
+         if ((x < 0) || (x > NUM_MAG)) 
+           send_to_char (d->character, "Invalid choice!\r\n");
+         else
+           OLC_SPELL(d)->mag_flags ^= (1 << (x - 1));
+         spedit_mag_flags_menu (d);
+         return;
+    case SPEDIT_PROTECTION_MENU :
+         if (!(x = atoi (arg))) break;
+         if ((x < 0) || (x > MAX_SPELL_PROTECTIONS)) {
+           send_to_char (d->character, "Invalid choice!\r\n");
+           spedit_protection_menu (d);
+           return;
+         }
+         OLC_VAL(d) = x - 1;
+         send_to_char (d->character, "Spell VNUM (0 to quit, 'r' to remove) : ");
+         OLC_MODE(d) = SPEDIT_GET_SPELL_NUM;
+         return;   
+    case SPEDIT_GET_OBJECT : value = formula_interpreter (d->character,
+                                          d->character, OLC_NUM(d), FALSE,
+                                          arg, GET_LEVEL(d->character), &rts_code);
+                             if (!rts_code) {
+                               SAFE_FREE(OLC_SPELL(d)->objects[OLC_VAL(d)]); 
+                               OLC_SPELL(d)->objects[OLC_VAL(d)] = STRDUP(arg);
+                             }
+                             spedit_show_objects(d);
+                             return;
+    case SPEDIT_GET_DISPEL : value = formula_interpreter (d->character,
+                                          d->character, OLC_NUM(d), FALSE,
+                                          arg, GET_LEVEL(d->character), &rts_code);
+                             if (!rts_code) {
+                               SAFE_FREE(OLC_SPELL(d)->dispel[OLC_VAL(d)]); 
+                               OLC_SPELL(d)->dispel[OLC_VAL(d)] = STRDUP(arg);
+                             }
+                             spedit_show_dispel(d);
+                             return;
+    case SPEDIT_GET_POINTS : value = formula_interpreter (d->character,
+                                          d->character, OLC_NUM(d), FALSE,
+                                          arg, GET_LEVEL(d->character), &rts_code);
+                             if (!rts_code) {
+		               switch (OLC_VAL(d)) {
+                                  case 0 : SAFE_FREE(OLC_SPELL(d)->points.hp);
+                                           OLC_SPELL(d)->points.hp = STRDUP(arg);
+                                           break;
+                                  case 1 : SAFE_FREE(OLC_SPELL(d)->points.mana);
+                                           OLC_SPELL(d)->points.mana = STRDUP(arg);
+                                           break;
+                                  case 2 : SAFE_FREE(OLC_SPELL(d)->points.move);
+                                           OLC_SPELL(d)->points.move = STRDUP(arg);
+                                           break;
+                                  case 3 : SAFE_FREE(OLC_SPELL(d)->points.gold);
+                                           OLC_SPELL(d)->points.gold = STRDUP(arg);
+                               } 
+                             } 
+                             spedit_show_points (d);
+                             return;
+    case SPEDIT_GET_MOBILE : value = formula_interpreter (d->character,
+                                          d->character, OLC_NUM(d), FALSE,
+                                          arg, GET_LEVEL(d->character), &rts_code);
+                             if (!rts_code) {
+                               switch (OLC_VAL(d)) {
+                                 case 0 : SAFE_FREE(OLC_SPELL(d)->summon_mob);
+                                          OLC_SPELL(d)->summon_mob = STRDUP(arg);
+                                          break;
+                                 case 1 : SAFE_FREE(OLC_SPELL(d)->summon_req);
+                                          OLC_SPELL(d)->summon_req = STRDUP(arg);
+                               }
+                             }
+                             spedit_show_mobile (d);
+                             return;
+    case SPEDIT_SHOW_MOBILE :
+         if (!(x = atoi(arg))) break;
+         if ((x < 0) || (x > 2)) {
+           send_to_char (d->character, "Invalid choice!\r\n");
+           spedit_show_mobile(d);
+           return;
+         }
+         if (x == 1) send_to_char(d->character, "Mobile : ");
+         else        send_to_char(d->character, "Item   : ");
+         OLC_VAL(d) = x - 1;
+         OLC_MODE(d) = SPEDIT_GET_MOBILE;
+         return;
+    case SPEDIT_SHOW_OBJECTS :
+         if (!(x = atoi(arg))) break;
+         if ((x < 0) || (x > MAX_SPELL_OBJECTS)) {
+           send_to_char (d->character, "Invalid choice!\r\n");
+           spedit_show_objects(d);
+           return;
+         }
+         send_to_char(d->character, "Object #%d : ", x);
+         OLC_VAL(d) = x - 1;
+         OLC_MODE(d) = SPEDIT_GET_OBJECT; 
+         return;
+    case SPEDIT_SHOW_DISPEL :
+         if (!(x = atoi(arg))) break;
+         if ((x < 0) || (x > MAX_SPELL_DISPEL)) {
+           send_to_char (d->character, "Invalid choice!\r\n");
+           spedit_show_dispel(d);
+           return;
+         }
+         send_to_char(d->character, "Dispel #%d : ", x);
+         OLC_VAL(d) = x - 1;
+         OLC_MODE(d) = SPEDIT_GET_DISPEL; 
+         return;
+    case SPEDIT_SHOW_POINTS :
+         if (!(x = atoi(arg))) break;
+         if ((x < 0) || (x > 4)) {
+           send_to_char (d->character, "Invalid choice!\r\n");
+           spedit_show_points (d);
+           return;
+         }
+         send_to_char(d->character, "%s", points[x-1]);
+         OLC_VAL(d) = x - 1;
+         OLC_MODE(d) = SPEDIT_GET_POINTS;
+         return;
+    case SPEDIT_CONFIRM_EDIT : 
+         if ((*arg == 'y') || (*arg == 'Y')) { 
+           send_to_char (d->character, "\r\n");
+           spedit_setup2 (d);
+         } else
+           if (OLC_SEARCH(d) && (*arg != 'q') && (*arg != 'Q')) {
+             spedit_setup (d);
+           } else
+               cleanup_olc (d, CLEANUP_ALL); 
+         return; 
+    case SPEDIT_MAIN_MENU :
+        if (OLC_SPELL(d)->function && *arg != 'q' && *arg != 'Q' && *arg != '1') {
+          send_to_char (d->character, "Invalid option!\r\n");
+          break;
+        }
+        switch (*arg) {
+          case 'q' :
+          case 'Q' : if (OLC_VAL(d)) {
+                       send_to_char (d->character, "Do you want to save this spell to disk? : ");
+                       OLC_MODE(d) = SPEDIT_CONFIRM_SAVESTRING;
+                     } else
+                         cleanup_olc (d, CLEANUP_ALL); 
+                     return;
+          case '1' : /* if (GET_LEVEL(d->character) < LVL_IMPL) { 
+                       send_to_char (d->character, "Only the implentors can set that!\r\n");
+                       break;
+                     } 
+                     else { */
+                       send_to_char (d->character, "0-Unavailable, 1-Available\r\n\r\n"
+                                                   "Enter choice : ");
+                       OLC_MODE(d) = SPEDIT_GET_STATUS;
+                       return; 
+                   /*  } */
+          case '2' : send_to_char (d->character, "Spell name : ");
+                     OLC_MODE(d) = SPEDIT_GET_NAME;
+                     return;
+          case '3' : spedit_minpos_menu (d);
+                     return;
+          case '4' : spedit_targ_flags_menu (d);
+                     return;
+          case '5' : spedit_mag_flags_menu (d);
+                     return;
+          case '6' : send_to_char (d->character, "Damages : ");
+                     OLC_MODE(d) = SPEDIT_GET_DAMAGES;
+                     return; 
+          case '7' : send_to_char (d->character, "Passes (10 passes = 1 sec) : ");
+                     OLC_MODE(d) = SPEDIT_GET_DELAY;
+                     return;
+          case '8' : send_to_char (d->character, "%% of effectiveness : ");
+                     OLC_MODE(d) = SPEDIT_GET_EFFECTIVENESS;
+                     return;
+          case '9' : spedit_show_points (d);
+                     return;
+          case 'p' :
+          case 'P' : spedit_protection_menu (d);
+                     return; 
+          case 'a' :
+          case 'A' : spedit_apply_menu (d);
+                     return;
+          case 'd' :
+          case 'D' : spedit_show_dispel (d);
+                     return;
+          case 'o' :
+          case 'O' : spedit_show_objects (d);
+                     return;
+          case 'x' :
+          case 'X' : spedit_show_mobile (d);
+                     return;
+          case 's' :
+          case 'S' : page_string (d, OLC_SPELL(d)->script, 1);
+                     send_to_char (d->character, "\r\n");
+                     send_editor_help(d);
+                     oldtext = STRDUP(OLC_SPELL(d)->script);
+                     string_write(d, &OLC_SPELL(d)->script, MAX_MESSAGE_LENGTH, 0, oldtext);
+                     OLC_VAL(d) = 1;
+                     return;
+          case 'c' :
+          case 'C' : spedit_assign_menu (d);
+                     return;
+          case 'm' :
+          case 'M' : spedit_show_messages (d);
+                     return;
+          case 't' : 
+          case 'T' : send_to_char (d->character, "\r\n0-Spell     1-Skill\r\n");
+                     send_to_char (d->character, "Enter choice : ");
+                     OLC_MODE(d) = SPEDIT_GET_TYPE;
+                     return;
+          case 'w' :
+          case 'W' : spedit_show_warnings (d);
+                     break;
+          default  : send_to_char (d->character, "Invalid option!\r\n"); 
+        }
+        break;
+     default : return; 
+  }
+  OLC_VAL(d) = 1; 
+  send_to_char (d->character, "\r\n");
+  spedit_main_menu (d);
+}
+
+ACMD(do_spedit) {
+  struct descriptor_data *d = ch->desc;
+
+/* No building as a mob or while being forced. */
+  if (IS_NPC(ch) || !ch->desc || STATE(ch->desc) != CON_PLAYING)
+    return;
+
+  if (FIGHTING(ch)) {
+    send_to_char(ch, "You should focus on your fight!\r\n");
+    return;
+  }
+
+/* Give the descriptor an OLC structure. */
+  if (d->olc) {
+    mudlog(BRF, LVL_IMMORT, TRUE, "SYSERR: do_spedit: Player already had olc structure.");
+    free(d->olc);
+  }
+
+  CREATE(d->olc, struct oasis_olc_data, 1);
+
+  skip_spaces(&argument);
+  if (*argument)
+    OLC_STORAGE(d) = strdup(argument);
+  else
+    OLC_STORAGE(d) = NULL;
+ 
+  STATE(d) = CON_SPEDIT;
+
+  spedit_setup(ch->desc);
+}
+
+ACMD(do_splist) {
+{
+ char buf[MAX_STRING_LENGTH];
+ int cpt = 0;
+ int search_by_class = CLASS_UNDEFINED;
+ int search_by_part_name = 0;
+ int search_disabled = 0;
+ int search_not_assigned = 0;
+ int search_by_skill = 0;
+ int search_by_function = 0;
+ size_t len = 0, tmp_len = 0;
+
+ struct str_spells *ptr;
+ 
+ skip_spaces(&argument);
+
+ if (!*argument) {
+   send_to_char(ch, "splist all - list all spells\r\n"
+                    "splist sk  - list all skills\r\n"
+                    "splist mu  - list all in class magical user\r\n" 
+                    "splist cl  - list all in class cleric\r\n" 
+                    "splist th  - list all in class thief\r\n" 
+                    "splist wa  - list all in class warrior\r\n" 
+                    "splist not - list all not assigned\r\n"
+                    "splist off - list all disabled\r\n"
+                    "splist spec - list all with a special function\r\n"
+                    "splist <word> - list all containing the <word>\r\n");
+   return;
+ }
+ 
+ if(!strcmp(argument, "mu")) 
+   search_by_class = CLASS_MAGIC_USER;
+ else
+ if(!strcmp(argument, "cl"))
+   search_by_class = CLASS_CLERIC;
+ else
+ if(!strcmp(argument, "th"))
+   search_by_class = CLASS_THIEF;
+ else
+ if(!strcmp(argument, "wa"))
+   search_by_class = CLASS_WARRIOR;
+ else
+ if(!strcmp(argument, "sk"))
+   search_by_skill = 1;
+ else
+ if(!strcmp(argument, "off")) 
+   search_disabled = 1;
+ else
+ if(!strcmp(argument, "not"))
+   search_not_assigned = 1;
+ else
+ if(!strcmp(argument, "spec"))
+   search_by_function = 1;
+ else
+ if(strcmp(argument, "all"))
+   search_by_part_name = 1;
+
+
+ len = snprintf(buf, MAX_STRING_LENGTH, 
+ "Index VNum    Name                 Type     Spec_Prog    Available   Classe(s)\r\n"
+ "----- ------- ----                 ----     ---------    ---------   -----------\r\n");
+ 
+ for (ptr = list_spells; ptr; ptr = ptr->next) {
+   char classes[80] = "";
+   int mu, cl, th, wa;
+
+   if ((mu = (get_spell_class(ptr, CLASS_MAGIC_USER) != -1))) strcat(classes, "Mu ");
+   if ((search_by_class == CLASS_MAGIC_USER) && !mu) continue;
+
+   if ((cl = (get_spell_class(ptr, CLASS_CLERIC) != -1))) strcat(classes, "Cl ");
+   if ((search_by_class == CLASS_CLERIC) && !cl) continue;
+
+   if ((th = (get_spell_class(ptr, CLASS_THIEF) != -1))) strcat(classes, "Th ");
+   if ((search_by_class == CLASS_THIEF) && !th) continue;
+
+   if ((wa = (get_spell_class(ptr, CLASS_WARRIOR) != -1))) strcat(classes, "Wa");
+   if ((search_by_class == CLASS_WARRIOR) && !wa) continue;
+
+   if (search_disabled && (ptr->status == available)) continue;
+
+   if ((mu || cl || th || wa) && search_not_assigned) continue;
+
+   if (search_by_skill && (ptr->type == SPELL)) continue;
+
+   if (search_by_function && !ptr->function) continue;
+
+   if (search_by_part_name && !stristr3(ptr->name, argument)) continue;
+
+   tmp_len = snprintf(buf+len, sizeof(buf)-len, "%s%4d%s) [%s%5d%s]%s %-20s%s %-5s    %s%-3s          %s%-3s         %s%s%s\r\n",
+             QGRN, ++cpt, QNRM, QGRN, ptr->vnum, QNRM, 
+             QCYN, ptr->name, QYEL, ptr->type == SPELL ? "SPELL" : "SKILL", 
+             QNRM, ptr->function ? "Yes" : "No", 
+             ptr->status == available ? QGRN : QRED, ptr->status == available ? "Yes" : "No", 
+             QCYN, classes, QNRM); 
+   len += tmp_len;
+   if (len > sizeof(buf))
+     break;
+  }
+
+  page_string(ch->desc, buf, TRUE);
+ }
+}
+
diff -uN ./orig/spedit.h ./spedit.h
--- ./orig/spedit.h	1969-12-31 19:00:00.000000000 -0500
+++ ./spedit.h	2020-02-25 19:19:09.949725369 -0500
@@ -0,0 +1,146 @@
+/* Copyright (c) 2020 castillo7@hotmail.com
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE. */
+
+#ifndef SPEDIT
+#define SPEDIT
+
+/* all by castillo */
+#define unavailable             0
+#define available               1
+#define NUM_CHAR_POSITION       9
+#define NUM_SPELL_FLAGS         13
+#define MAX_SPELL_DELAY         50   /* this equal to 5 sec */
+#define SPELL                   'P'
+#define SKILL                   'K'
+#define SPSK                    'Z'
+#define MAX_SPELL_AFFECTS       6    /* modifying thos MAX_SPELL would require a FULL spells database upgrade. */
+#define MAX_SPELL_PROTECTIONS   6    /* for e.g: spedit_save_to_disk */
+#define MAX_SPELL_OBJECTS       3
+#define MAX_SPELL_DISPEL        3
+
+#define DB_CODE_INIT_VARS       1
+#define DB_CODE_NAME            2
+#define DB_CODE_DAMAGES         3 
+#define DB_CODE_EFFECTIVENESS   4
+#define DB_CODE_DELAY           5
+#define DB_CODE_SCRIPT          6
+#define DB_CODE_END             7
+#define DB_CODE_SUMMON_MOB      8
+#define DB_CODE_SUMMON_REQ      9
+#define DB_CODE_MSG_WEAR_OFF    10 
+#define DB_CODE_MSG_TO_SELF     11
+#define DB_CODE_MSG_TO_VICT     12
+#define DB_CODE_MSG_TO_ROOM     13 /* 14 to 24 are free */
+#define DB_CODE_DISPEL_1        25
+#define DB_CODE_DISPEL_2        26
+#define DB_CODE_DISPEL_3        27 /* 28 to 39 are free */
+#define DB_CODE_OBJECTS_1       40
+#define DB_CODE_OBJECTS_2       41
+#define DB_CODE_OBJECTS_3       42 /* 43 to 49 are free */
+#define DB_CODE_PTS_HP          50
+#define DB_CODE_PTS_MANA        51
+#define DB_CODE_PTS_MOVE        52
+#define DB_CODE_PTS_GOLD        53 /* 54 to 59 are free */
+#define DB_CODE_PROT_1          60
+#define DB_CODE_PROT_2          61
+#define DB_CODE_PROT_3          62
+#define DB_CODE_PROT_4          63
+#define DB_CODE_PROT_5          64
+#define DB_CODE_PROT_6          65 /* 66 to 79 are free */
+#define DB_CODE_AFFECTS_1       80
+#define DB_CODE_AFFECTS_2       81
+#define DB_CODE_AFFECTS_3       82
+#define DB_CODE_AFFECTS_4       83
+#define DB_CODE_AFFECTS_5       84
+#define DB_CODE_AFFECTS_6       85 /* 86 to 89 are free */
+#define DB_CODE_CLASS_MU        90
+#define DB_CODE_CLASS_CL        91
+#define DB_CODE_CLASS_TH        92
+#define DB_CODE_CLASS_WA        93 /* 94 tp 98 are free */
+#define DB_CODE_MARKER          99
+
+extern char *UNDEF_SPELL;
+
+struct str_spells *get_spell_by_vnum(int vnum);
+struct str_spells *get_spell_by_name (char *name, char type);
+int get_spell_level(int vnum, int class);
+int get_spell_class(struct str_spells *spell, int class);
+int get_spell_mag_flags(int vnum);
+
+void spedit_init_new_spell (struct str_spells *spell);
+void spedit_save_internally (struct str_spells *spell);
+void spedit_save_to_disk(void);
+
+char *get_spell_name(int vnum);
+
+struct str_prot {
+   int  prot_num;
+   char *duration;
+   char *resist;
+};
+
+struct str_appl {
+   int  appl_num;
+   char *modifier;
+   char *duration;  
+};
+
+struct str_assign {
+   int  class_num;
+   int  level;
+   char *prac_gain;
+   char *num_mana;
+};
+
+struct str_mesg {
+   char *wear_off;
+   char *to_self;
+   char *to_vict;
+   char *to_room;
+};
+
+struct str_pts {
+   char *hp;
+   char *mana;
+   char *move;
+   char *gold;
+};
+
+struct str_spells {
+   char type;
+   int  vnum;
+   int  status;
+   int  min_pos;
+   int  max_dam;
+   int  violent;
+   char *name;
+   char *delay;
+   int  targ_flags;
+   int  mag_flags;
+   char *damages;
+   char *effectiveness;
+   char *script;
+   char *objects[MAX_SPELL_OBJECTS];
+   char *dispel[MAX_SPELL_DISPEL];
+   char *summon_mob;
+   char *summon_req;
+   struct str_prot protfrom [MAX_SPELL_PROTECTIONS];
+   struct str_appl applies [MAX_SPELL_AFFECTS];
+   struct str_assign assign [NUM_CLASSES]; 
+   struct str_mesg messages;
+   struct str_pts points;
+   void *function;
+   struct str_spells *next;
+};
+
+void spedit_free_spell (struct str_spells *spell);
+void spedit_main_menu (struct descriptor_data *d);
+void spedit_string_cleanup (struct descriptor_data *d, int action);
+#endif
diff -uN ./orig/spell_parser.c ./spell_parser.c
--- ./orig/spell_parser.c	2020-02-25 19:18:51.526369106 -0500
+++ ./spell_parser.c	2020-02-25 19:19:09.949725369 -0500
@@ -12,6 +12,7 @@
 #include "sysdep.h"
 #include "structs.h"
 #include "utils.h"
+#include "config.h"
 #include "interpreter.h"
 #include "spells.h"
 #include "handler.h"
@@ -19,18 +20,15 @@
 #include "db.h"
 #include "dg_scripts.h"
 #include "fight.h"  /* for hit() */
-
-#define SINFO spell_info[spellnum]
+#include "spedit.h"
+#include "spells_script.h"
+#include "formula.h"
 
 /* Global Variables definitions, used elsewhere */
-struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];
 char cast_arg2[MAX_INPUT_LENGTH];
-const char *unused_spellname = "!UNUSED!"; /* So we can get &unused_spellname */
 
 /* Local (File Scope) Function Prototypes */
 static void say_spell(struct char_data *ch, int spellnum, struct char_data *tch, struct obj_data *tobj);
-static void spello(int spl, const char *name, int max_mana, int min_mana, int mana_change, int minpos, int targets, int violent, int routines, const char *wearoff);
-static int mag_manacost(struct char_data *ch, int spellnum);
 
 /* Local (File Scope) Variables */
 struct syllable {
@@ -73,12 +71,44 @@
 };
 
 
+void call_ASPELL (void (*function) (), int level, struct char_data *ch,
+                  struct char_data *vict, struct obj_data *obj)
+{
+ (*function)(level, ch, vict, obj);
+}
 
-static int mag_manacost(struct char_data *ch, int spellnum)
+void call_ACMD (void (*function) (), struct char_data *ch, 
+                char *argument, int cmd, int subcmd)
 {
-  return MAX(SINFO.mana_max - (SINFO.mana_change *
-		    (GET_LEVEL(ch) - SINFO.min_level[(int) GET_CLASS(ch)])),
-	     SINFO.mana_min);
+ (*function)(ch, argument, cmd, subcmd);
+}
+
+int mag_manacost(struct char_data *ch, struct char_data *tch, int spellnum)
+{
+  struct str_spells *spell;
+  int mana, num, rts_code;
+
+  spell = get_spell_by_vnum(spellnum);
+
+  if (!spell) {
+    log("SYSERR: spell not found vnum %d passed to mag_manacost.", spellnum);
+    return 100; 
+  }
+
+  num = get_spell_class(spell, GET_CLASS(ch));
+  if (num == -1) {
+    if (GET_LEVEL(ch) < LVL_IMMORT) {
+      log("SYSERR: spell vnum %d not assigned to class: %d"
+           ", passed to mag_manacost.", spellnum, GET_CLASS(ch));
+      return 100; 
+    } 
+    else
+      return 0;
+  }
+  
+  mana = MAX(5, formula_interpreter (ch, tch, spellnum, TRUE, spell->assign[num].num_mana, GET_LEVEL(ch), &rts_code));
+
+  return mana;
 }
 
 static void say_spell(struct char_data *ch, int spellnum, struct char_data *tch,
@@ -91,7 +121,8 @@
   int j, ofs = 0;
 
   *buf = '\0';
-  strlcpy(lbuf, skill_name(spellnum), sizeof(lbuf));
+  
+  strlcpy(lbuf, get_spell_name(spellnum), sizeof(lbuf));
 
   while (lbuf[ofs]) {
     for (j = 0; *(syls[j].org); j++) {
@@ -143,40 +174,7 @@
  * this because you can guarantee > 0 and <= TOP_SPELL_DEFINE. */
 const char *skill_name(int num)
 {
-  if (num > 0 && num <= TOP_SPELL_DEFINE)
-    return (spell_info[num].name);
-  else if (num == -1)
-    return ("UNUSED");
-  else
-    return ("UNDEFINED");
-}
-
-int find_skill_num(char *name)
-{
-  int skindex, ok;
-  char *temp, *temp2;
-  char first[256], first2[256], tempbuf[256];
-
-  for (skindex = 1; skindex <= TOP_SPELL_DEFINE; skindex++) {
-    if (is_abbrev(name, spell_info[skindex].name))
-      return (skindex);
-
-    ok = TRUE;
-    strlcpy(tempbuf, spell_info[skindex].name, sizeof(tempbuf));	/* strlcpy: OK */
-    temp = any_one_arg(tempbuf, first);
-    temp2 = any_one_arg(name, first2);
-    while (*first && *first2 && ok) {
-      if (!is_abbrev(first2, first))
-	ok = FALSE;
-      temp = any_one_arg(temp, first);
-      temp2 = any_one_arg(temp2, first2);
-    }
-
-    if (ok && !*first2)
-      return (skindex);
-  }
-
-  return (-1);
+  return get_spell_name(num);
 }
 
 /* This function is the very heart of the entire magic system.  All invocations
@@ -188,6 +186,10 @@
 	     struct obj_data *ovict, int spellnum, int level, int casttype)
 {
   int savetype;
+  int i, dur, res, rts_code; 
+  int damages, flags = 0;
+  struct str_spells *spell;
+  struct affected_type *af;
 
   if (spellnum < 1 || spellnum > TOP_SPELL_DEFINE)
     return (0);
@@ -204,16 +206,42 @@
     act("$n's magic fizzles out and dies.", FALSE, caster, 0, 0, TO_ROOM);
     return (0);
   }
+
+  spell = get_spell_by_vnum(spellnum); 
+  
+  if (!spell) {
+    log("SYSERR: spell not found vnum %d passed to call_magic.", spellnum);
+    return 0;
+  }
+
+  if (spell->status == unavailable) {
+    send_to_char (caster, "%s", CONFIG_NOEFFECT);
+    return 0;
+  }
+
   if (ROOM_FLAGGED(IN_ROOM(caster), ROOM_PEACEFUL) &&
-      (SINFO.violent || IS_SET(SINFO.routines, MAG_DAMAGE))) {
+     ((spell->mag_flags & MAG_DAMAGE) || (spell->mag_flags & MAG_VIOLENT))) {
     send_to_char(caster, "A flash of white light fills the room, dispelling your violent magic!\r\n");
     act("White light from no particular source suddenly fills the room, then vanishes.", FALSE, caster, 0, 0, TO_ROOM);
     return (0);
   }
-  if (cvict && MOB_FLAGGED(cvict, MOB_NOKILL)) {
-    send_to_char(caster, "This mob is protected.\r\n");
-    return (0);
+
+  if (cvict) {
+    if (MOB_FLAGGED(cvict, MOB_NOKILL)) {
+      send_to_char(caster, "This mob is protected.\r\n");
+      return (0);
+    }
+
+    for (af = cvict->affected; af; af = af->next)
+      if (IS_SET_AR(AFF_FLAGS(cvict), AFF_PROTECT) && (af->location == spellnum)) {
+    
+        if (af->modifier >= rand_number(0, 99)) {
+          send_to_char(caster, "%s is protected and resits your magic.\r\n", GET_NAME(cvict));
+          return 0; 
+        }
+      }
   }
+
   /* determine the type of saving throw */
   switch (casttype) {
   case CAST_STAFF:
@@ -230,52 +258,71 @@
     break;
   }
 
-  if (IS_SET(SINFO.routines, MAG_DAMAGE))
-    if (mag_damage(level, caster, cvict, spellnum, savetype) == -1)
+  if (spell->mag_flags & MAG_DAMAGE) {
+    if ((damages = mag_damage(level, caster, cvict, spellnum, savetype)) == -1)
       return (-1);	/* Successful and target died, don't cast again. */
+    if (damages)
+      flags = MAGIC_SUCCESS;
+  }
+
+  if (spell->mag_flags & MAG_PROTECTION) {
+    for (i=0; i<MAX_SPELL_PROTECTIONS; i++) {
+      dur = MAX(1, formula_interpreter (caster, cvict, spellnum, TRUE, spell->protfrom[i].duration, level, &rts_code));
+      res = MAX(0, formula_interpreter (caster, cvict, spellnum, TRUE, spell->protfrom[i].resist, level, &rts_code));
+      flags |= mag_protections(level, caster, cvict, spell->vnum, spell->protfrom[i].prot_num, dur, res);
+    }
+  }
 
-  if (IS_SET(SINFO.routines, MAG_AFFECTS))
-    mag_affects(level, caster, cvict, spellnum, savetype);
+  if (spell->mag_flags & MAG_AFFECTS) 
+    flags |= mag_affects(level, caster, cvict, spellnum, savetype);
 
-  if (IS_SET(SINFO.routines, MAG_UNAFFECTS))
-    mag_unaffects(level, caster, cvict, spellnum, savetype);
+  if (spell->mag_flags & MAG_UNAFFECTS)
+    flags |= mag_unaffects(level, caster, cvict, spellnum, savetype);
 
-  if (IS_SET(SINFO.routines, MAG_POINTS))
-    mag_points(level, caster, cvict, spellnum, savetype);
+  if (spell->mag_flags & MAG_POINTS)
+    flags |= mag_points(level, caster, cvict, spellnum, savetype);
 
-  if (IS_SET(SINFO.routines, MAG_ALTER_OBJS))
-    mag_alter_objs(level, caster, ovict, spellnum, savetype);
-
-  if (IS_SET(SINFO.routines, MAG_GROUPS))
-    mag_groups(level, caster, spellnum, savetype);
-
-  if (IS_SET(SINFO.routines, MAG_MASSES))
-    mag_masses(level, caster, spellnum, savetype);
-
-  if (IS_SET(SINFO.routines, MAG_AREAS))
-    mag_areas(level, caster, spellnum, savetype);
-
-  if (IS_SET(SINFO.routines, MAG_SUMMONS))
-    mag_summons(level, caster, ovict, spellnum, savetype);
-
-  if (IS_SET(SINFO.routines, MAG_CREATIONS))
-    mag_creations(level, caster, spellnum);
-
-  if (IS_SET(SINFO.routines, MAG_ROOMS))
-    mag_rooms(level, caster, spellnum);
-
-  if (IS_SET(SINFO.routines, MAG_MANUAL))
-    switch (spellnum) {
-    case SPELL_CHARM:		MANUAL_SPELL(spell_charm); break;
-    case SPELL_CREATE_WATER:	MANUAL_SPELL(spell_create_water); break;
-    case SPELL_DETECT_POISON:	MANUAL_SPELL(spell_detect_poison); break;
-    case SPELL_ENCHANT_WEAPON:  MANUAL_SPELL(spell_enchant_weapon); break;
-    case SPELL_IDENTIFY:	MANUAL_SPELL(spell_identify); break;
-    case SPELL_LOCATE_OBJECT:   MANUAL_SPELL(spell_locate_object); break;
-    case SPELL_SUMMON:		MANUAL_SPELL(spell_summon); break;
-    case SPELL_WORD_OF_RECALL:  MANUAL_SPELL(spell_recall); break;
-    case SPELL_TELEPORT:	MANUAL_SPELL(spell_teleport); break;
-    }
+  if (spell->mag_flags & MAG_ALTER_OBJS)
+    flags |= mag_alter_objs(level, caster, ovict, spellnum, savetype);
+
+  if (spell->mag_flags & MAG_GROUPS)
+    flags |= mag_groups(level, caster, spellnum, savetype);
+
+  if (spell->mag_flags & MAG_MASSES)
+    flags |= mag_masses(level, caster, spellnum, savetype);
+
+  if (spell->mag_flags & MAG_AREAS)
+    flags |= mag_areas(level, caster, spellnum, savetype);
+
+  if (spell->mag_flags & MAG_SUMMONS)
+    flags |= mag_summons(level, caster, ovict, spellnum, savetype);
+
+  if (spell->mag_flags & MAG_CREATIONS)
+    flags |= mag_creations(level, caster, spellnum);
+
+  if (spell->mag_flags & MAG_ROOMS)
+    flags |= mag_rooms(level, caster, spellnum);
+
+  if ((spell->mag_flags & MAG_MANUAL) && spell->function) 
+    call_ASPELL (spell->function, GET_LEVEL(caster), caster, cvict, ovict);
+
+  if (spell->script)
+    flags |= perform_script (spell->script, caster, cvict, ovict, spell->vnum, 0);
+
+  if (flags & MAGIC_SUCCESS) {
+    if (spell->messages.to_self != NULL && (caster != cvict))
+      act(spell->messages.to_self, FALSE, caster, ovict, cvict, TO_CHAR);
+    if (spell->messages.to_vict != NULL && cvict)
+      act(spell->messages.to_vict, FALSE, cvict, ovict, 0, TO_CHAR);
+    if (spell->messages.to_room != NULL && cvict)
+      act(spell->messages.to_room, TRUE, caster, ovict, cvict, TO_ROOM);
+  }
+  else
+  if (flags & MAGIC_NOEFFECT)
+    send_to_char (caster, "%s", CONFIG_NOEFFECT);
+  else
+  if (flags & MAGIC_FAILED)
+    send_to_char (caster, "You failed!\r\n");
 
   return (1);
 }
@@ -321,7 +368,7 @@
 
       /* Area/mass spells on staves can cause crashes. So we use special cases
        * for those spells spells here. */
-      if (HAS_SPELL_ROUTINE(GET_OBJ_VAL(obj, 3), MAG_MASSES | MAG_AREAS)) {
+      if (IS_SET(get_spell_mag_flags(GET_OBJ_VAL(obj, 3)), MAG_MASSES | MAG_AREAS)) {
         for (i = 0, tch = world[IN_ROOM(ch)].people; tch; tch = tch->next_in_room)
 	  i++;
 	while (i-- > 0)
@@ -353,7 +400,7 @@
 	act(obj->action_description, FALSE, ch, obj, tobj, TO_ROOM);
       else
 	act("$n points $p at $P.", TRUE, ch, obj, tobj, TO_ROOM);
-    } else if (IS_SET(spell_info[GET_OBJ_VAL(obj, 3)].routines, MAG_AREAS | MAG_MASSES)) {
+    } else if (IS_SET(get_spell_mag_flags(GET_OBJ_VAL(obj, 3)), MAG_AREAS | MAG_MASSES)) {
       /* Wands with area spells don't need to be pointed. */
       act("You point $p outward.", FALSE, ch, obj, NULL, TO_CHAR);
       act("$n points $p outward.", TRUE, ch, obj, NULL, TO_ROOM);
@@ -436,13 +483,16 @@
 int cast_spell(struct char_data *ch, struct char_data *tch,
 	           struct obj_data *tobj, int spellnum)
 {
+  struct str_spells *spell;
+
   if (spellnum < 0 || spellnum > TOP_SPELL_DEFINE) {
     log("SYSERR: cast_spell trying to call spellnum %d/%d.", spellnum,
 	TOP_SPELL_DEFINE);
     return (0);
   }
 
-  if (GET_POS(ch) < SINFO.min_position) {
+  spell = get_spell_by_vnum(spellnum);
+  if (GET_POS(ch) < spell->min_pos) {
     switch (GET_POS(ch)) {
       case POS_SLEEPING:
       send_to_char(ch, "You dream about great magical powers.\r\n");
@@ -466,496 +516,205 @@
     send_to_char(ch, "You are afraid you might hurt your master!\r\n");
     return (0);
   }
-  if ((tch != ch) && IS_SET(SINFO.targets, TAR_SELF_ONLY)) {
-    send_to_char(ch, "You can only cast this spell upon yourself!\r\n");
+  if ((tch != ch) && (spell->targ_flags & TAR_SELF_ONLY)) {
+    send_to_char(ch, "You can only %s yourself!\r\n", 
+                      spell->type == SPELL ? "cast this spell upon" : "do this to");
     return (0);
   }
-  if ((tch == ch) && IS_SET(SINFO.targets, TAR_NOT_SELF)) {
-    send_to_char(ch, "You cannot cast this spell upon yourself!\r\n");
+  if ((tch == ch) && (spell->targ_flags & TAR_NOT_SELF)) {
+    send_to_char(ch, "You cannot %s yourself!\r\n",
+                      spell->type == SPELL ? "cast this spell upon" : "do this to");
     return (0);
   }
-  if (IS_SET(SINFO.routines, MAG_GROUPS) && !GROUP(ch)) {
-    send_to_char(ch, "You can't cast this spell if you're not in a group!\r\n");
+  if ((spell->mag_flags & MAG_GROUPS) && !GROUP(ch)) {
+    send_to_char(ch, "You can't %s if you're not in a group!\r\n",
+                      spell->type == SPELL ? "cast this spell" : "do this");
     return (0);
   }
   send_to_char(ch, "%s", CONFIG_OK);
-  say_spell(ch, spellnum, tch, tobj);
+
+  if (spell->type == SPELL)
+    say_spell(ch, spellnum, tch, tobj);
 
   return (call_magic(ch, tch, tobj, spellnum, GET_LEVEL(ch), CAST_SPELL));
 }
 
-/* do_cast is the entry point for PC-casted spells.  It parses the arguments,
- * determines the spell number and finds a target, throws the die to see if
- * the spell can be cast, checks for sufficient mana and subtracts it, and
- * passes control to cast_spell(). */
 ACMD(do_cast)
 {
-  struct char_data *tch = NULL;
-  struct obj_data *tobj = NULL;
-  char *s, *t;
-  int number, mana, spellnum, i, target = 0;
-
-  if (IS_NPC(ch))
-    return;
+ char *s, *targ = NULL;
+ struct char_data *tch = NULL;
+ struct obj_data *tobj = NULL;
+ struct str_spells *spell = NULL;
+ int i, delay, rts_code = TRUE;
+ int effectiveness = 0;
+ int number;
+ int level, target = 0;
+ int mana = 5;
+
+ if (IS_NPC(ch))
+   return;
+
+ // for spell check that is is enclosed in ''
+ if (subcmd == SCMD_SPELL) {
+   s = strtok(argument, "'");
+   if (s == NULL) {
+     send_to_char (ch, "Cast what where?\r\n");
+     return;
+   }
+   if (!(s = strtok(NULL, "'"))) {
+     send_to_char (ch, "Spell names must be enclosed in the Holy Magic Symbols: '\r\n");
+     return;
+   }
+   targ = strtok (NULL, "\0");
+ }
+ else // skill
+   targ = argument;
+
+ if (subcmd == SCMD_SPELL)
+   spell = get_spell_by_name(s, SPELL); 
+ else
+   spell = get_spell_by_vnum(subcmd);
+
+ if (!spell || (spell->status != available)) {
+   if (subcmd == SCMD_SPELL)
+     send_to_char(ch, "Cast what?!?\r\n");
+   else
+     send_to_char(ch, "%s", HUH);  
+   return;
+ }
+
+ // for skills with a function, we only check if status == available, and
+ // we return the control to it function.
+ if (spell->function && (spell->type == SKILL)) {
+   call_ACMD (spell->function, ch, argument, 0, 0);
+   return;
+ }
+
+ if (GET_LEVEL(ch) < LVL_IMMORT) {
+   level = get_spell_level(spell->vnum, GET_CLASS(ch));
+   if ((level == -1) || (GET_LEVEL(ch) < level)) {
+     send_to_char(ch, "You do not know that %s!\r\n", (spell->type == SPELL) ? "spell" : "skill");
+     return;
+   }
+   if (GET_SKILL(ch, spell->vnum) == 0) {
+     send_to_char (ch, "You are unfamilliar with that %s.\r\n", (spell->type == SPELL) ? "spell" : "skill");
+     return;
+   }
+ }
 
-  /* get: blank, spell name, target name */
-  s = strtok(argument, "'");
-
-  if (s == NULL) {
-    send_to_char(ch, "Cast what where?\r\n");
-    return;
-  }
-  s = strtok(NULL, "'");
-  if (s == NULL) {
-    send_to_char(ch, "Spell names must be enclosed in the Holy Magic Symbols: '\r\n");
-    return;
-  }
-  t = strtok(NULL, "\0");
-
-  skip_spaces(&s);
-
-  /* spellnum = search_block(s, spells, 0); */
-  spellnum = find_skill_num(s);
-
-  if ((spellnum < 1) || (spellnum > MAX_SPELLS) || !*s) {
-    send_to_char(ch, "Cast what?!?\r\n");
-    return;
-  }
-  if (GET_LEVEL(ch) < SINFO.min_level[(int) GET_CLASS(ch)]) {
-    send_to_char(ch, "You do not know that spell!\r\n");
-    return;
-  }
-  if (GET_SKILL(ch, spellnum) == 0) {
-    send_to_char(ch, "You are unfamiliar with that spell.\r\n");
-    return;
-  }
-  /* Find the target */
-  if (t != NULL) {
+/* Find the target */
+  if (targ != NULL) {
     char arg[MAX_INPUT_LENGTH];
 
-    strlcpy(arg, t, sizeof(arg));
-    one_argument(arg, t);
-    skip_spaces(&t);
+    strlcpy(arg, targ, sizeof(arg));
+    one_argument(arg, targ);
+    skip_spaces(&targ);
 
     /* Copy target to global cast_arg2, for use in spells like locate object */
-    strcpy(cast_arg2, t);
+    strcpy(cast_arg2, targ);
   }
-  if (IS_SET(SINFO.targets, TAR_IGNORE)) {
+
+  if (spell->targ_flags & TAR_IGNORE) {
     target = TRUE;
-  } else if (t != NULL && *t) {
-    number = get_number(&t);
-    if (!target && (IS_SET(SINFO.targets, TAR_CHAR_ROOM))) {
-      if ((tch = get_char_vis(ch, t, &number, FIND_CHAR_ROOM)) != NULL)
-	target = TRUE;
-    }
-    if (!target && IS_SET(SINFO.targets, TAR_CHAR_WORLD))
-      if ((tch = get_char_vis(ch, t, &number, FIND_CHAR_WORLD)) != NULL)
-	target = TRUE;
-
-    if (!target && IS_SET(SINFO.targets, TAR_OBJ_INV))
-      if ((tobj = get_obj_in_list_vis(ch, t, &number, ch->carrying)) != NULL)
-	target = TRUE;
+  } else if (targ != NULL && *targ) {
+    number = get_number(&targ);
+    if (!target && (spell->targ_flags & TAR_CHAR_ROOM)) {
+      if ((tch = get_char_vis(ch, targ, &number, FIND_CHAR_ROOM)) != NULL)
+        target = TRUE;
+    }
+    if (!target && (spell->targ_flags & TAR_CHAR_WORLD))
+      if ((tch = get_char_vis(ch, targ, &number, FIND_CHAR_WORLD)) != NULL)
+        target = TRUE;
+
+    if (!target && (spell->targ_flags & TAR_OBJ_INV))
+      if ((tobj = get_obj_in_list_vis(ch, targ, &number, ch->carrying)) != NULL)
+        target = TRUE;
 
-    if (!target && IS_SET(SINFO.targets, TAR_OBJ_EQUIP)) {
+    if (!target && (spell->targ_flags & TAR_OBJ_EQUIP)) {
       for (i = 0; !target && i < NUM_WEARS; i++)
-	if (GET_EQ(ch, i) && isname(t, GET_EQ(ch, i)->name)) {
-	  tobj = GET_EQ(ch, i);
-	  target = TRUE;
-	}
-    }
-    if (!target && IS_SET(SINFO.targets, TAR_OBJ_ROOM))
-      if ((tobj = get_obj_in_list_vis(ch, t, &number, world[IN_ROOM(ch)].contents)) != NULL)
-	target = TRUE;
-
-    if (!target && IS_SET(SINFO.targets, TAR_OBJ_WORLD))
-      if ((tobj = get_obj_vis(ch, t, &number)) != NULL)
-	target = TRUE;
+        if (GET_EQ(ch, i) && isname(targ, GET_EQ(ch, i)->name)) {
+          tobj = GET_EQ(ch, i);
+          target = TRUE;
+        }
+    }
+    if (!target && (spell->targ_flags & TAR_OBJ_ROOM))
+      if ((tobj = get_obj_in_list_vis(ch, targ, &number, world[IN_ROOM(ch)].contents)) != NULL)
+        target = TRUE;
+
+    if (!target && (spell->targ_flags & TAR_OBJ_WORLD))
+      if ((tobj = get_obj_vis(ch, targ, &number)) != NULL)
+        target = TRUE;
 
-  } else {			/* if target string is empty */
-    if (!target && IS_SET(SINFO.targets, TAR_FIGHT_SELF))
+  } else {                      /* if target string is empty */
+ if (!target && (spell->targ_flags & TAR_FIGHT_SELF))
       if (FIGHTING(ch) != NULL) {
-	tch = ch;
-	target = TRUE;
+        tch = ch;
+        target = TRUE;
       }
-    if (!target && IS_SET(SINFO.targets, TAR_FIGHT_VICT))
+    if (!target && (spell->targ_flags & TAR_FIGHT_VICT))
       if (FIGHTING(ch) != NULL) {
-	tch = FIGHTING(ch);
-	target = TRUE;
+        tch = FIGHTING(ch);
+        target = TRUE;
       }
     /* if no target specified, and the spell isn't violent, default to self */
-    if (!target && IS_SET(SINFO.targets, TAR_CHAR_ROOM) &&
-	!SINFO.violent) {
+    if (!target && ((spell->targ_flags & TAR_CHAR_ROOM) || (spell->targ_flags & TAR_SELF_ONLY)) &&
+        !(spell->mag_flags & MAG_VIOLENT)) {
       tch = ch;
       target = TRUE;
     }
     if (!target) {
       send_to_char(ch, "Upon %s should the spell be cast?\r\n",
-		IS_SET(SINFO.targets, TAR_OBJ_ROOM | TAR_OBJ_INV | TAR_OBJ_WORLD | TAR_OBJ_EQUIP) ? "what" : "who");
+                (spell->targ_flags & (TAR_OBJ_ROOM | TAR_OBJ_INV | TAR_OBJ_WORLD | TAR_OBJ_EQUIP)) ? "what" : "who");
       return;
     }
   }
 
-  if (target && (tch == ch) && SINFO.violent) {
+  if (target && (tch == ch) && (spell->damages) && (spell->mag_flags & MAG_VIOLENT)) {
     send_to_char(ch, "You shouldn't cast that on yourself -- could be bad for your health!\r\n");
     return;
   }
   if (!target) {
-    send_to_char(ch, "Cannot find the target of your spell!\r\n");
-    return;
-  }
-  mana = mag_manacost(ch, spellnum);
-  if ((mana > 0) && (GET_MANA(ch) < mana) && (GET_LEVEL(ch) < LVL_IMMORT)) {
-    send_to_char(ch, "You haven't the energy to cast that spell!\r\n");
+    send_to_char(ch, "Cannot find the target of your %s!\r\n", (spell->type == SPELL) ? "spell" : "skill");
     return;
   }
-
-  /* You throws the dice and you takes your chances.. 101% is total failure */
-  if (rand_number(0, 101) > GET_SKILL(ch, spellnum)) {
-    WAIT_STATE(ch, PULSE_VIOLENCE);
-    if (!tch || !skill_message(0, ch, tch, spellnum))
-      send_to_char(ch, "You lost your concentration!\r\n");
-    if (mana > 0)
-      GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - (mana / 2)));
-    if (SINFO.violent && tch && IS_NPC(tch))
-      hit(tch, ch, TYPE_UNDEFINED);
-  } else { /* cast spell returns 1 on success; subtract mana & set waitstate */
-    if (cast_spell(ch, tch, tobj, spellnum)) {
-      WAIT_STATE(ch, PULSE_VIOLENCE);
-      if (mana > 0)
-	GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - mana));
+  
+  // only spell cost mana
+  if ((spell->type == SPELL) && (GET_LEVEL(ch) < LVL_IMMORT)) {
+    mana = mag_manacost(ch, tch, spell->vnum);
+    if (GET_MANA(ch) < mana) {
+      send_to_char(ch, "You haven't the energy to cast that spell!\r\n");
+      return;
     }
-  }
-}
-
-void spell_level(int spell, int chclass, int level)
-{
-  int bad = 0;
-
-  if (spell < 0 || spell > TOP_SPELL_DEFINE) {
-    log("SYSERR: attempting assign to illegal spellnum %d/%d", spell, TOP_SPELL_DEFINE);
-    return;
-  }
-
-  if (chclass < 0 || chclass >= NUM_CLASSES) {
-    log("SYSERR: assigning '%s' to illegal class %d/%d.", skill_name(spell),
-		chclass, NUM_CLASSES - 1);
-    bad = 1;
-  }
-
-  if (level < 1 || level > LVL_IMPL) {
-    log("SYSERR: assigning '%s' to illegal level %d/%d.", skill_name(spell),
-		level, LVL_IMPL);
-    bad = 1;
-  }
-
-  if (!bad)
-    spell_info[spell].min_level[chclass] = level;
-}
-
-
-/* Assign the spells on boot up */
-static void spello(int spl, const char *name, int max_mana, int min_mana,
-	int mana_change, int minpos, int targets, int violent, int routines, const char *wearoff)
-{
-  int i;
+ }
 
-  for (i = 0; i < NUM_CLASSES; i++)
-    spell_info[spl].min_level[i] = LVL_IMMORT;
-  spell_info[spl].mana_max = max_mana;
-  spell_info[spl].mana_min = min_mana;
-  spell_info[spl].mana_change = mana_change;
-  spell_info[spl].min_position = minpos;
-  spell_info[spl].targets = targets;
-  spell_info[spl].violent = violent;
-  spell_info[spl].routines = routines;
-  spell_info[spl].name = name;
-  spell_info[spl].wear_off_msg = wearoff;
+ if (spell->effectiveness)
+   effectiveness = GET_SKILL(ch, spell->vnum) * 
+                   MAX(0, formula_interpreter (ch, tch, spell->vnum, TRUE, spell->effectiveness, GET_LEVEL(ch), &rts_code)) / 100;
+
+ if (rand_number (0, 101) > effectiveness) {
+   WAIT_STATE(ch, PULSE_VIOLENCE);
+   if (!tch || !skill_message(0, ch, tch, spell->vnum))
+     send_to_char (ch, "You lost your concentration!\r\n");
+
+   if ((spell->type == SPELL) && (mana > 0))
+     GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - (mana / 2)));
+
+   // if you lost your concentration and the spell is MAG_VIOLENT, you still hit a mobile to start the fight.
+   if ((spell->mag_flags & MAG_VIOLENT) && tch && IS_NPC(tch))
+     hit(tch, ch, TYPE_UNDEFINED);
+
+   return;
+ }
+
+ if (cast_spell(ch, tch, tobj, spell->vnum)) {
+   if (spell->delay) {
+     delay = MAX(0, formula_interpreter (ch, tch, spell->vnum, TRUE, spell->delay, GET_LEVEL(ch), &rts_code));
+     WAIT_STATE (ch, MIN(delay, MAX_SPELL_DELAY));
+   }
+   else
+     WAIT_STATE(ch, PULSE_VIOLENCE);
+
+   if (spell->type == SPELL)
+     GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - mana));
+ }
 }
-
-void unused_spell(int spl)
-{
-  int i;
-
-  for (i = 0; i < NUM_CLASSES; i++)
-    spell_info[spl].min_level[i] = LVL_IMPL + 1;
-  spell_info[spl].mana_max = 0;
-  spell_info[spl].mana_min = 0;
-  spell_info[spl].mana_change = 0;
-  spell_info[spl].min_position = 0;
-  spell_info[spl].targets = 0;
-  spell_info[spl].violent = 0;
-  spell_info[spl].routines = 0;
-  spell_info[spl].name = unused_spellname;
-}
-
-#define skillo(skill, name) spello(skill, name, 0, 0, 0, 0, 0, 0, 0, NULL);
-/* Arguments for spello calls:
- * spellnum, maxmana, minmana, manachng, minpos, targets, violent?, routines.
- * spellnum:  Number of the spell.  Usually the symbolic name as defined in
- *  spells.h (such as SPELL_HEAL).
- * spellname: The name of the spell.
- * maxmana :  The maximum mana this spell will take (i.e., the mana it
- *  will take when the player first gets the spell).
- * minmana :  The minimum mana this spell will take, no matter how high
- *  level the caster is.
- * manachng:  The change in mana for the spell from level to level.  This
- *  number should be positive, but represents the reduction in mana cost as
- *  the caster's level increases.
- * minpos  :  Minimum position the caster must be in for the spell to work
- *  (usually fighting or standing). targets :  A "list" of the valid targets
- *  for the spell, joined with bitwise OR ('|').
- * violent :  TRUE or FALSE, depending on if this is considered a violent
- *  spell and should not be cast in PEACEFUL rooms or on yourself.  Should be
- *  set on any spell that inflicts damage, is considered aggressive (i.e.
- *  charm, curse), or is otherwise nasty.
- * routines:  A list of magic routines which are associated with this spell
- *  if the spell uses spell templates.  Also joined with bitwise OR ('|').
- * See the documentation for a more detailed description of these fields. You
- * only need a spello() call to define a new spell; to decide who gets to use
- * a spell or skill, look in class.c.  -JE */
-void mag_assign_spells(void)
-{
-  int i;
-
-  /* Do not change the loop below. */
-  for (i = 0; i <= TOP_SPELL_DEFINE; i++)
-    unused_spell(i);
-  /* Do not change the loop above. */
-
-  spello(SPELL_ANIMATE_DEAD, "animate dead", 35, 10, 3, POS_STANDING,
-	TAR_OBJ_ROOM, FALSE, MAG_SUMMONS,
-	NULL);
-
-  spello(SPELL_ARMOR, "armor", 30, 15, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM, FALSE, MAG_AFFECTS,
-	"You feel less protected.");
-
-  spello(SPELL_BLESS, "bless", 35, 5, 3, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_OBJ_INV, FALSE, MAG_AFFECTS | MAG_ALTER_OBJS,
-	"You feel less righteous.");
-
-  spello(SPELL_BLINDNESS, "blindness", 35, 25, 1, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_NOT_SELF, FALSE, MAG_AFFECTS,
-	"You feel a cloak of blindness dissolve.");
-
-  spello(SPELL_BURNING_HANDS, "burning hands", 30, 10, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_CALL_LIGHTNING, "call lightning", 40, 25, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_CHARM, "charm person", 75, 50, 2, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_MANUAL,
-	"You feel more self-confident.");
-
-  spello(SPELL_CHILL_TOUCH, "chill touch", 30, 10, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE | MAG_AFFECTS,
-	"You feel your strength return.");
-
-  spello(SPELL_CLONE, "clone", 80, 65, 5, POS_STANDING,
-	TAR_IGNORE, FALSE, MAG_SUMMONS,
-	NULL);
-
-  spello(SPELL_COLOR_SPRAY, "color spray", 30, 15, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_CONTROL_WEATHER, "control weather", 75, 25, 5, POS_STANDING,
-	TAR_IGNORE, FALSE, MAG_MANUAL,
-	NULL);
-
-  spello(SPELL_CREATE_FOOD, "create food", 30, 5, 4, POS_STANDING,
-	TAR_IGNORE, FALSE, MAG_CREATIONS,
-	NULL);
-
-  spello(SPELL_CREATE_WATER, "create water", 30, 5, 4, POS_STANDING,
-	TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE, MAG_MANUAL,
-	NULL);
-
-  spello(SPELL_CURE_BLIND, "cure blind", 30, 5, 2, POS_STANDING,
-	TAR_CHAR_ROOM, FALSE, MAG_UNAFFECTS,
-	NULL);
-
-  spello(SPELL_CURE_CRITIC, "cure critic", 30, 10, 2, POS_FIGHTING,
-	TAR_CHAR_ROOM, FALSE, MAG_POINTS,
-	NULL);
-
-  spello(SPELL_CURE_LIGHT, "cure light", 30, 10, 2, POS_FIGHTING,
-	TAR_CHAR_ROOM, FALSE, MAG_POINTS,
-	NULL);
-
-  spello(SPELL_CURSE, "curse", 80, 50, 2, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_OBJ_INV, TRUE, MAG_AFFECTS | MAG_ALTER_OBJS,
-	"You feel more optimistic.");
-
-  spello(SPELL_DARKNESS, "darkness", 30, 5, 4, POS_STANDING,
-	TAR_IGNORE, FALSE, MAG_ROOMS,
-	NULL);
-
-  spello(SPELL_DETECT_ALIGN, "detect alignment", 20, 10, 2, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS,
-	"You feel less aware.");
-
-  spello(SPELL_DETECT_INVIS, "detect invisibility", 20, 10, 2, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS,
-	"Your eyes stop tingling.");
-
-  spello(SPELL_DETECT_MAGIC, "detect magic", 20, 10, 2, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS,
-	"The detect magic wears off.");
-
-  spello(SPELL_DETECT_POISON, "detect poison", 15, 5, 1, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL,
-	"The detect poison wears off.");
-
-  spello(SPELL_DISPEL_EVIL, "dispel evil", 40, 25, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_DISPEL_GOOD, "dispel good", 40, 25, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_EARTHQUAKE, "earthquake", 40, 25, 3, POS_FIGHTING,
-	TAR_IGNORE, TRUE, MAG_AREAS,
-	NULL);
-
-  spello(SPELL_ENCHANT_WEAPON, "enchant weapon", 150, 100, 10, POS_STANDING,
-	TAR_OBJ_INV, FALSE, MAG_MANUAL,
-	NULL);
-
-  spello(SPELL_ENERGY_DRAIN, "energy drain", 40, 25, 1, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE | MAG_MANUAL,
-	NULL);
-
-  spello(SPELL_GROUP_ARMOR, "group armor", 50, 30, 2, POS_STANDING,
-	TAR_IGNORE, FALSE, MAG_GROUPS,
-	NULL);
-
-  spello(SPELL_FIREBALL, "fireball", 40, 30, 2, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_FLY, "fly", 40, 20, 2, POS_FIGHTING,
-	TAR_CHAR_ROOM, FALSE, MAG_AFFECTS,
-	"You drift slowly to the ground.");
-
-  spello(SPELL_GROUP_HEAL, "group heal", 80, 60, 5, POS_STANDING,
-	TAR_IGNORE, FALSE, MAG_GROUPS,
-	NULL);
-
-  spello(SPELL_HARM, "harm", 75, 45, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_HEAL, "heal", 60, 40, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM, FALSE, MAG_POINTS | MAG_UNAFFECTS,
-	NULL);
-
-  spello(SPELL_INFRAVISION, "infravision", 25, 10, 1, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS,
-	"Your night vision seems to fade.");
-
-  spello(SPELL_INVISIBLE, "invisibility", 35, 25, 1, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_AFFECTS | MAG_ALTER_OBJS,
-	"You feel yourself exposed.");
-
-  spello(SPELL_LIGHTNING_BOLT, "lightning bolt", 30, 15, 1, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_LOCATE_OBJECT, "locate object", 25, 20, 1, POS_STANDING,
-	TAR_OBJ_WORLD, FALSE, MAG_MANUAL,
-	NULL);
-
-  spello(SPELL_MAGIC_MISSILE, "magic missile", 25, 10, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_POISON, "poison", 50, 20, 3, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_NOT_SELF | TAR_OBJ_INV, TRUE,
-	MAG_AFFECTS | MAG_ALTER_OBJS,
-	"You feel less sick.");
-
-  spello(SPELL_PROT_FROM_EVIL, "protection from evil", 40, 10, 3, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS,
-	"You feel less protected.");
-
-  spello(SPELL_REMOVE_CURSE, "remove curse", 45, 25, 5, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE,
-	MAG_UNAFFECTS | MAG_ALTER_OBJS,
-	NULL);
-
-  spello(SPELL_REMOVE_POISON, "remove poison", 40, 8, 4, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_UNAFFECTS | MAG_ALTER_OBJS,
-	NULL);
-
-  spello(SPELL_SANCTUARY, "sanctuary", 110, 85, 5, POS_STANDING,
-	TAR_CHAR_ROOM, FALSE, MAG_AFFECTS,
-	"The white aura around your body fades.");
-
-  spello(SPELL_SENSE_LIFE, "sense life", 20, 10, 2, POS_STANDING,
-	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS,
-	"You feel less aware of your surroundings.");
-
-  spello(SPELL_SHOCKING_GRASP, "shocking grasp", 30, 15, 3, POS_FIGHTING,
-	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE,
-	NULL);
-
-  spello(SPELL_SLEEP, "sleep", 40, 25, 5, POS_STANDING,
-	TAR_CHAR_ROOM, TRUE, MAG_AFFECTS,
-	"You feel less tired.");
-
-  spello(SPELL_STRENGTH, "strength", 35, 30, 1, POS_STANDING,
-	TAR_CHAR_ROOM, FALSE, MAG_AFFECTS,
-	"You feel weaker.");
-
-  spello(SPELL_SUMMON, "summon", 75, 50, 3, POS_STANDING,
-	TAR_CHAR_WORLD | TAR_NOT_SELF, FALSE, MAG_MANUAL,
-	NULL);
-
-  spello(SPELL_TELEPORT, "teleport", 75, 50, 3, POS_STANDING,
-	TAR_CHAR_ROOM, FALSE, MAG_MANUAL,
-	NULL);
-
-  spello(SPELL_WATERWALK, "waterwalk", 40, 20, 2, POS_STANDING,
-	TAR_CHAR_ROOM, FALSE, MAG_AFFECTS,
-	"Your feet seem less buoyant.");
-
-  spello(SPELL_WORD_OF_RECALL, "word of recall", 20, 10, 2, POS_FIGHTING,
-	TAR_CHAR_ROOM, FALSE, MAG_MANUAL,
-	NULL);
-
-  spello(SPELL_IDENTIFY, "identify", 50, 25, 5, POS_STANDING,
-        TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL,
-        NULL);
-
-
-  /* NON-castable spells should appear below here. */
-  spello(SPELL_IDENTIFY, "identify", 0, 0, 0, 0,
-	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL,
-	NULL);
-
-  /* you might want to name this one something more fitting to your theme -Welcor*/
-  spello(SPELL_DG_AFFECT, "Script-inflicted", 0, 0, 0, POS_SITTING,
-	TAR_IGNORE, TRUE, 0,
-	NULL);
-
-  /* Declaration of skills - this actually doesn't do anything except set it up
-   * so that immortals can use these skills by default.  The min level to use
-   * the skill for other classes is set up in class.c. */
-  skillo(SKILL_BACKSTAB, "backstab");
-  skillo(SKILL_BASH, "bash");
-  skillo(SKILL_HIDE, "hide");
-  skillo(SKILL_KICK, "kick");
-  skillo(SKILL_PICK_LOCK, "pick lock");
-  skillo(SKILL_RESCUE, "rescue");
-  skillo(SKILL_SNEAK, "sneak");
-  skillo(SKILL_STEAL, "steal");
-  skillo(SKILL_TRACK, "track");
-  skillo(SKILL_WHIRLWIND, "whirlwind");
-  skillo(SKILL_BANDAGE, "bandage");
-}
-
diff -uN ./orig/spells_assign.c ./spells_assign.c
--- ./orig/spells_assign.c	1969-12-31 19:00:00.000000000 -0500
+++ ./spells_assign.c	2020-02-25 19:19:09.949725369 -0500
@@ -0,0 +1,1487 @@
+/* Copyright (c) 2020 castillo7@hotmail.com
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE. */
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "utils.h"
+#include "spells.h"
+#include "spedit.h"
+
+ACMD(do_backstab);
+ACMD(do_bash);
+ACMD(do_rescue);
+ACMD(do_kick);
+ACMD(do_sneak);
+ACMD(do_track);
+ACMD(do_steal);
+ACMD(do_hide);
+ACMD(do_pick_lock);
+ACMD(do_whirlwind);
+ACMD(do_bandage);
+
+void set_spells_function()
+{
+ struct str_spells *spell;
+
+ log("Assigning spells's function.");
+
+ if ((spell = get_spell_by_vnum(SPELL_TELEPORT)))
+   spell->function = spell_teleport;
+
+ if ((spell = get_spell_by_vnum(SPELL_CHARM)))
+   spell->function = spell_charm;
+
+ if ((spell = get_spell_by_vnum(SPELL_CREATE_WATER)))
+   spell->function = spell_create_water;
+
+ if ((spell = get_spell_by_vnum(SPELL_DETECT_POISON)))
+   spell->function = spell_detect_poison;
+
+ if ((spell = get_spell_by_vnum(SPELL_ENCHANT_WEAPON)))
+   spell->function = spell_enchant_weapon;
+
+ if ((spell = get_spell_by_vnum(SPELL_LOCATE_OBJECT)))
+   spell->function = spell_locate_object;
+
+ if ((spell = get_spell_by_vnum(SPELL_SUMMON)))
+   spell->function = spell_summon;
+
+ if ((spell = get_spell_by_vnum(SPELL_WORD_OF_RECALL)))
+   spell->function = spell_recall;
+
+ if ((spell = get_spell_by_vnum(SPELL_IDENTIFY)))
+   spell->function = spell_identify;
+
+ if ((spell = get_spell_by_vnum(SKILL_BACKSTAB)))
+   spell->function = do_backstab;
+
+ if ((spell = get_spell_by_vnum(SKILL_BASH)))
+   spell->function = do_bash;
+
+ if ((spell = get_spell_by_vnum(SKILL_HIDE)))
+   spell->function = do_hide;
+
+ if ((spell = get_spell_by_vnum(SKILL_KICK)))
+   spell->function = do_kick;
+
+ if ((spell = get_spell_by_vnum(SKILL_WHIRLWIND)))
+   spell->function = do_whirlwind;
+
+ if ((spell = get_spell_by_vnum(SKILL_RESCUE)))
+   spell->function = do_rescue;
+
+ if ((spell = get_spell_by_vnum(SKILL_SNEAK)))
+   spell->function = do_sneak;
+
+ if ((spell = get_spell_by_vnum(SKILL_STEAL)))
+   spell->function = do_steal;
+
+ if ((spell = get_spell_by_vnum(SKILL_TRACK)))
+   spell->function = do_track;
+
+ if ((spell = get_spell_by_vnum(SKILL_BANDAGE)))
+   spell->function = do_bandage;
+}
+
+// This function create the database of all the spells and skills,
+// that exist in TBA MUD and respect the original VNUMs.
+// for compatibility reasons.
+//
+// This function could be remove eventually. ?!
+// It's there to create the original spells/skills DB, or recreate it.
+// If a spells/skills DB exists, set_spells_function() will be called instead.
+void create_spells_db() 
+{
+ struct str_spells *new_spell = NULL;
+ char buf[MAX_STRING_LENGTH];
+
+ log("Creating spells Database.");
+
+ // SPELL_ARMOR #1
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_ARMOR;
+ new_spell->status = available;
+ new_spell->name = strdup("armor");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (3 * self.level)) > 15 ? (30 - (3 * self.level)) : 15");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 4;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->assign[1].class_num = CLASS_CLERIC;
+ new_spell->assign[1].level = 1;
+ new_spell->assign[1].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = APPLY_AC;
+ new_spell->applies[0].modifier = strdup("-20");
+ new_spell->applies[0].duration = strdup("24");
+ new_spell->messages.to_vict = strdup("You feel someone protecting you.");
+ new_spell->messages.wear_off = strdup("You feel less protected.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_TELEPORT #2
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_TELEPORT;
+ new_spell->status = available;
+ new_spell->name = strdup("teleport");
+ new_spell->function = spell_teleport;
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(75 - (3 * self.level)) > 50 ? (75 - (3 * self.level)) : 50");
+ new_spell->assign[0].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_BLESS #3
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_BLESS;
+ new_spell->status = available;
+ new_spell->name = strdup("bless");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_OBJ_INV;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ALTER_OBJS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(35 - (3 * self.level)) > 5 ? (35 - (3 * self.level)) : 5");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 5;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = APPLY_HITROLL;
+ new_spell->applies[0].modifier = strdup("2");
+ new_spell->applies[0].duration = strdup("6");
+ new_spell->applies[1].appl_num = APPLY_SAVING_SPELL;
+ new_spell->applies[1].modifier = strdup("-1");
+ new_spell->applies[1].duration = strdup("6");
+ new_spell->messages.to_self = strdup("$b glows briefly.");
+ new_spell->messages.to_vict = strdup("You feel righteous.");
+ new_spell->messages.wear_off = strdup("You feel less righteous.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_BLINDNESS #4
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_BLINDNESS;
+ new_spell->status = available;
+ new_spell->name = strdup("blindness");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_NOT_SELF;
+ new_spell->mag_flags = MAG_AFFECTS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(35 - (1 * self.level)) > 25 ? (35 - (1 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 9;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->assign[1].class_num = CLASS_CLERIC;
+ new_spell->assign[1].level = 6;
+ new_spell->assign[1].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = APPLY_HITROLL;
+ new_spell->applies[0].modifier = strdup("-4");
+ new_spell->applies[0].duration = strdup("2");
+ new_spell->applies[1].appl_num = APPLY_AC;
+ new_spell->applies[1].modifier = strdup("40");
+ new_spell->applies[1].duration = strdup("2");
+ new_spell->applies[2].appl_num = AFF_BLIND + NUM_APPLIES;
+ new_spell->applies[2].duration = strdup("2");
+ new_spell->messages.to_vict = strdup("You have been blinded!");
+ new_spell->messages.to_room = strdup("$N seems to be blinded!");
+ new_spell->messages.wear_off = strdup("You feel a cloak of blindness dissolve.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_BURNING_HANDS #5
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_BURNING_HANDS;
+ new_spell->status = available;
+ new_spell->name = strdup("burning hands");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (3 * self.level)) > 10 ? (30 - (3 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 5;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup ("dice(3, self.class == 0 ? 8 : 6) + 3");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_CALL_LIGHTNING #6
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CALL_LIGHTNING;
+ new_spell->status = available;
+ new_spell->name = strdup("call lightning");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (3 * self.level)) > 25 ? (40 - (3 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 15;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(7, 8) + 7");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_CHARM_PERSON #7
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CHARM;
+ new_spell->status = available;
+ new_spell->name = strdup("charm person");
+ new_spell->function = spell_charm;
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_NOT_SELF;
+ new_spell->mag_flags = MAG_MANUAL | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(75 - (2 * self.level)) > 50 ? (75 - (2 * self.level)) : 50");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 16;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->messages.wear_off = strdup("You feel more self-confident.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_CHILL_TOUCH #8
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CHILL_TOUCH;
+ new_spell->status = available;
+ new_spell->name = strdup("chill touch");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT | MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (3 * self.level)) > 10 ? (30 - (3 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 3;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = APPLY_STR;
+ new_spell->applies[0].modifier = strdup("-1");
+ new_spell->applies[0].duration = strdup("4");
+ new_spell->damages = strdup("dice(1, self.class == 0 ? 8 : 6) + 1");
+ new_spell->max_dam = 100;
+ new_spell->messages.to_vict = strdup("You feel your strength wither!");
+ new_spell->messages.wear_off = strdup("You feel your strength return.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_CLONE #9
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CLONE;
+ new_spell->status = available;
+ new_spell->name = strdup("clone");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_IGNORE;
+ new_spell->mag_flags = MAG_SUMMONS;
+ new_spell->effectiveness = strdup("100");
+ new_spell->summon_mob = strdup("10");
+ new_spell->summon_req = strdup("161");
+ sprintf(buf, "(80 - (5 * self.level)) > 65 ? (80 - (5 * self.level)) : 65");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 30;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->messages.to_room = strdup("$N magically divides!");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_COLOR_SPRAY #10
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_COLOR_SPRAY;
+ new_spell->status = available;
+ new_spell->name = strdup("color spray");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (3 * self.level)) > 15 ? (30 - (3 * self.level)) : 15");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 11;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(9, self.class == 0 ? 8 : 6) + 9");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_CONTROL_WEATHER #11
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CONTROL_WEATHER;
+ new_spell->status = available;
+ new_spell->name = strdup("control weather");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_IGNORE;
+ new_spell->mag_flags = MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(75 - (5 * self.level)) > 25 ? (75 - (5 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 17;
+ new_spell->assign[0].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_CREATE_FOOD #12
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CREATE_FOOD;
+ new_spell->status = available;
+ new_spell->name = strdup("create food");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_IGNORE;
+ new_spell->mag_flags = MAG_CREATIONS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (4 * self.level)) > 5 ? (30 - (4 * self.level)) : 5");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 2;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->objects[0] = strdup("10");  // object VNUM 10 = waybread
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_CREATE_WATER #13
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CREATE_WATER;
+ new_spell->status = available;
+ new_spell->name = strdup("create water");
+ new_spell->function = spell_create_water;
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_OBJ_INV | TAR_OBJ_EQUIP;
+ new_spell->mag_flags = MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (4 * self.level)) > 5 ? (30 - (4 * self.level)) : 5");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 2;
+ new_spell->assign[0].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_CURE_BLIND # 14
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CURE_BLIND;
+ new_spell->status = available;
+ new_spell->name = strdup("cure blind");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_UNAFFECTS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (2 * self.level)) > 5 ? (30 - (2 * self.level)) : 5");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 4;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->messages.to_vict = strdup("Your vision returns!");
+ new_spell->messages.to_room = strdup("There's a momentary gleam in $N's eyes.");
+ new_spell->dispel[0] = strdup("4");  // spell VNUM 4 = Blindness
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_CURE_CRITIC # 15
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CURE_CRITIC;
+ new_spell->status = available;
+ new_spell->name = strdup("cure critic");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_POINTS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (2 * self.level)) > 10 ? (30 - (2 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 9;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->messages.to_vict = strdup("You feel a lot better!");
+ new_spell->points.hp = strdup("dice(3, 8) + 3 + (param / 4)");
+ spedit_save_internally(new_spell);
+ 
+ // SPELL_CURE_LIGHT # 16
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CURE_LIGHT;
+ new_spell->status = available;
+ new_spell->name = strdup("cure light");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_POINTS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (2 * self.level)) > 10 ? (30 - (2 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 1;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->messages.to_vict = strdup("You feel better.");
+ new_spell->points.hp = strdup("dice(1, 8) + 1 + (param / 4)");
+ spedit_save_internally(new_spell);
+
+ // SPELL_CURSE # 17
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_CURSE;
+ new_spell->status = available;
+ new_spell->name = strdup("curse");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_OBJ_INV;
+ new_spell->mag_flags = MAG_VIOLENT | MAG_AFFECTS | MAG_ACCDUR | MAG_ACCMOD | MAG_ALTER_OBJS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(80 - (2 * self.level)) > 50 ? (80 - (2 * self.level)) : 50");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 14;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = APPLY_HITROLL;
+ new_spell->applies[0].modifier = strdup("-1");
+ new_spell->applies[0].duration = strdup("1 + (self.level / 2)");
+ new_spell->applies[1].appl_num = APPLY_DAMROLL;
+ new_spell->applies[1].modifier = strdup("-1");
+ new_spell->applies[1].duration = strdup("1 + (self.level / 2)");
+ new_spell->applies[2].appl_num = AFF_CURSE + NUM_APPLIES;
+ new_spell->applies[2].duration = strdup("1 + (self.level / 2)");
+ new_spell->messages.to_self = strdup("$b briefly glows red.");
+ new_spell->messages.to_vict = strdup("You feel very uncomfortable.");
+ new_spell->messages.to_room = strdup("$N briefly glows red!");
+ new_spell->messages.wear_off = strdup("You feel more optimistic.");
+
+ spedit_save_internally(new_spell);
+ 
+ // SPELL_DETECT_ALIGNMENT # 18
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_DETECT_ALIGN;
+ new_spell->status = available;
+ new_spell->name = strdup("detect alignment");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_SELF_ONLY;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(20 - (2 * self.level)) > 10 ? (20 - (2 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 4;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = AFF_DETECT_ALIGN + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("12 + param");
+ new_spell->messages.to_vict = strdup("Your eyes tingle.");
+ new_spell->messages.wear_off = strdup("You feel less aware.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_DETECT_INVIS # 19
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_DETECT_INVIS;
+ new_spell->status = available;
+ new_spell->name = strdup("detect invisibility");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_SELF_ONLY;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(20 - (2 * self.level)) > 10 ? (20 - (2 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 2;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->assign[1].class_num = CLASS_CLERIC;
+ new_spell->assign[1].level = 6;
+ new_spell->assign[1].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = AFF_DETECT_INVIS + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("12 + param");
+ new_spell->messages.to_vict = strdup("Your eyes tingle.");
+ new_spell->messages.wear_off = strdup("Your eyes stop tingling.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_DETECT_MAGIC # 20
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_DETECT_MAGIC;
+ new_spell->status = available;
+ new_spell->name = strdup("detect magic");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_SELF_ONLY;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(20 - (2 * self.level)) > 10 ? (20 - (2 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 2;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = AFF_DETECT_MAGIC + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("12 + param");
+ new_spell->messages.to_vict = strdup("Your eyes tingle.");
+ new_spell->messages.wear_off = strdup("The detect magic wears off.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_DETECT_POISON # 21
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_DETECT_POISON;
+ new_spell->status = available;
+ new_spell->name = strdup("detect poison");
+ new_spell->function = spell_detect_poison;
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM;
+ new_spell->mag_flags = MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(15 - (1 * self.level)) > 5 ? (15 - (1 * self.level)) : 5");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 10;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->assign[1].class_num = CLASS_CLERIC;
+ new_spell->assign[1].level = 3;
+ new_spell->assign[1].num_mana = strdup(buf);
+ new_spell->messages.wear_off = strdup("The detect poison wears off.");	
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_DISPEL_EVIL # 22
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_DISPEL_EVIL;
+ new_spell->status = available;
+ new_spell->name = strdup("dispel evil");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (3 * self.level)) > 25 ? (40 - (3 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 14;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(6, 8) + 6");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_EARTHQUAKE # 23
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_EARTHQUAKE;
+ new_spell->status = available;
+ new_spell->name = strdup("earthquake");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_IGNORE;
+ new_spell->mag_flags = MAG_AREAS | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (3 * self.level)) > 25 ? (40 - (3 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 12;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(2, 8) + param");
+ new_spell->max_dam = 100;
+ new_spell->messages.to_self = strdup("You gesture and the earth begins to shake all around you!");
+ new_spell->messages.to_room = strdup("$N gracefully gestures and the earth begins to shake violently!");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_ENCHANT_WEAPON # 24
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_ENCHANT_WEAPON;
+ new_spell->status = available;
+ new_spell->name = strdup("enchant weapon");
+ new_spell->function = spell_enchant_weapon;
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_OBJ_INV;
+ new_spell->mag_flags = MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(150 - (10 * self.level)) > 100 ? (150 - (10 * self.level)) : 100");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 26;
+ new_spell->assign[0].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_ENERGY_DRAIN # 25
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_ENERGY_DRAIN;
+ new_spell->status = available;
+ new_spell->name = strdup("energy drain");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT | MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (1 * self.level)) > 25 ? (40 - (1 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 13;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("vict.level <= 2 ? 100 : dice(1, 10)");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_FIREBALL # 26
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_FIREBALL;
+ new_spell->status = available;
+ new_spell->name = strdup("fireball");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (2 * self.level)) > 30 ? (40 - (2 * self.level)) : 30");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 15;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(11, self.class == 0 ? 8 : 6) + 11");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_HARM # 27
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_HARM;
+ new_spell->status = available;
+ new_spell->name = strdup("harm");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(75 - (3 * self.level)) > 45 ? (75 - (3 * self.level)) : 45");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 19;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(8, 8) + 8");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_HEAL # 28
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_HEAL;
+ new_spell->status = available;
+ new_spell->name = strdup("heal");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_POINTS | MAG_UNAFFECTS;
+ new_spell->effectiveness = strdup("100");
+ new_spell->points.hp = strdup("100 + dice(3, 8)");
+ sprintf(buf, "(60 - (3 * self.level)) > 40 ? (60 - (3 * self.level)) : 40");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 16;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->dispel[0] = strdup("4");
+ new_spell->messages.to_vict = strdup("A warm feeling floods your body.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_INVISIBILITY # 29
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_INVISIBLE;
+ new_spell->status = available;
+ new_spell->name = strdup("invisibility");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ALTER_OBJS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(35 - (1 * self.level)) > 25 ? (35 - (1 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 4;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = APPLY_AC;
+ new_spell->applies[0].modifier = strdup("-40");
+ new_spell->applies[0].duration = strdup("12 + (self.level / 4)");
+ new_spell->applies[1].appl_num = AFF_INVISIBLE + NUM_APPLIES;
+ new_spell->applies[1].duration = strdup("12 + (self.level / 4)");
+ new_spell->messages.to_self = strdup("$b vanishes.");
+ new_spell->messages.to_vict = strdup("You vanish.");
+ new_spell->messages.to_room = strdup("$N slowly fades out of existence.");
+ new_spell->messages.wear_off = strdup("You feel yourself exposed.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_LIGHTNING_BOLT # 30
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_LIGHTNING_BOLT;
+ new_spell->status = available;
+ new_spell->name = strdup("lightning bolt");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (1 * self.level)) > 15 ? (30 - (1 * self.level)) : 15");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 9;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(7, self.class == 0 ? 8 : 6) + 7");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_LOCATE_OBJECT # 31
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_LOCATE_OBJECT;
+ new_spell->status = available;
+ new_spell->name = strdup("locate object");
+ new_spell->function = spell_locate_object;
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_OBJ_WORLD;
+ new_spell->mag_flags = MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(25 - (1 * self.level)) > 20 ? (25 - (1 * self.level)) : 20");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 6;
+ new_spell->assign[0].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_MAGIC_MISSILE # 32
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_MAGIC_MISSILE;
+ new_spell->status = available;
+ new_spell->name = strdup("magic missile");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(25 - (3 * self.level)) > 10 ? (25 - (3 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 1;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(1, self.class == 0 ? 8 : 6) + 1");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_POISON # 33
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_POISON;
+ new_spell->status = available;
+ new_spell->name = strdup("poison");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_NOT_SELF | TAR_OBJ_INV;
+ new_spell->mag_flags = MAG_VIOLENT | MAG_AFFECTS | MAG_ALTER_OBJS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(50 - (3 * self.level)) > 20 ? (50 - (3 * self.level)) : 20");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 14;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->assign[1].class_num = CLASS_CLERIC;
+ new_spell->assign[1].level = 8;
+ new_spell->assign[1].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = APPLY_STR;
+ new_spell->applies[0].modifier = strdup("-2");
+ new_spell->applies[0].duration = strdup("self.level");
+ new_spell->applies[1].appl_num = AFF_POISON + NUM_APPLIES;
+ new_spell->applies[1].duration = strdup("self.level");
+ new_spell->messages.to_self = strdup("$b steams briefly.");
+ new_spell->messages.to_vict = strdup("You feel very sick.");
+ new_spell->messages.to_room = strdup("$N gets violently ill!");
+ new_spell->messages.wear_off = strdup("You feel less sick.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_PROTECTION_FROM_EVIL # 34
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_PROT_FROM_EVIL;
+ new_spell->status = available;
+ new_spell->name = strdup("protection from evil");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_SELF_ONLY;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (3 * self.level)) > 10 ? (40 - (3 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 8;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = AFF_PROTECT_EVIL + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("24");
+ new_spell->messages.to_vict = strdup("You feel invulnerable!");
+ new_spell->messages.wear_off = strdup("You feel less protected.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_REMOVE_CURSE # 35
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_REMOVE_CURSE;
+ new_spell->status = available;
+ new_spell->name = strdup("remove curse");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_EQUIP;
+ new_spell->mag_flags = MAG_UNAFFECTS | MAG_ALTER_OBJS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(45 - (5 * self.level)) > 25 ? (45 - (5 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 26;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->dispel[0] = strdup("17"); // dispel curse
+ new_spell->messages.to_self = strdup("$b briefly glows blue.");
+ new_spell->messages.to_vict = strdup("You don't feel so unlucky.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_SANCTUARY # 36
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_SANCTUARY;
+ new_spell->status = available;
+ new_spell->name = strdup("sanctuary");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(110 - (5 * self.level)) > 85 ? (110 - (5 * self.level)) : 85");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 15;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = AFF_SANCTUARY + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("4");
+ new_spell->messages.to_vict = strdup("A white aura momentarily surrounds you.");
+ new_spell->messages.to_room = strdup("$N is surrounded by a white aura.");
+ new_spell->messages.wear_off = strdup("The white aura around your body fades.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_SHOCKING_GRASP # 37
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_SHOCKING_GRASP;
+ new_spell->status = available;
+ new_spell->name = strdup("shocking grasp");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (3 * self.level)) > 15 ? (30 - (3 * self.level)) : 15");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 7;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(5, self.class == 0 ? 8 : 6) + 5");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_SLEEP # 38
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_SLEEP;
+ new_spell->status = available;
+ new_spell->name = strdup("sleep");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (5 * self.level)) > 25 ? (40 - (5 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 8;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = AFF_SLEEP + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("self.level / 4 + 4");
+ new_spell->messages.wear_off = strdup("You feel less tired.");
+ new_spell->messages.to_vict = strdup("You feel very sleepy...  Zzzz......");
+ new_spell->messages.to_room = strdup("$N goes to sleep.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_STRENGTH # 39
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_STRENGTH;
+ new_spell->status = available;
+ new_spell->name = strdup("strength");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR | MAG_ACCMOD;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(35 - (1 * self.level)) > 30 ? (35 - (1 * self.level)) : 30");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 6;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = APPLY_STR;
+ new_spell->applies[0].modifier = strdup("1 + (param > 18)");
+ new_spell->applies[0].duration = strdup("(self.level / 2) + 4");
+ new_spell->messages.to_vict = strdup("You feel stronger!");
+ new_spell->messages.wear_off = strdup("You feel weaker.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_SUMMON # 40
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_SUMMON;
+ new_spell->status = available;
+ new_spell->name = strdup("summon");
+ new_spell->function = spell_summon;
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_NOT_SELF;
+ new_spell->mag_flags = MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(75 - (3 * self.level)) > 50 ? (75 - (3 * self.level)) : 50");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 10;
+ new_spell->assign[0].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_VENTRILOQUATE # 41
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_VENTRILOQUATE;
+ new_spell->status = available;
+ new_spell->name = strdup("ventriloquate");
+ new_spell->type = SPELL;
+ new_spell->effectiveness = strdup("100");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_WORD_OF_RECALL # 42
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_WORD_OF_RECALL;
+ new_spell->status = available;
+ new_spell->name = strdup("word of recall");
+ new_spell->function = spell_recall;
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(20 - (2 * self.level)) > 10 ? (20 - (2 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 12;
+ new_spell->assign[0].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_REMOVE_POISON # 43
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_REMOVE_POISON;
+ new_spell->status = available;
+ new_spell->name = strdup("remove poison");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM;
+ new_spell->mag_flags = MAG_UNAFFECTS | MAG_ALTER_OBJS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (4 * self.level)) > 8 ? (40 - (4 * self.level)) : 8");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 10;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->dispel[0] = strdup("33");  // remove poison
+ new_spell->messages.to_self = strdup("$b steams briefly.");
+ new_spell->messages.to_vict = strdup("A warm feeling runs through your body!");
+ new_spell->messages.to_room = strdup("$N looks better."); 
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_SENSE_LIFE # 44
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_SENSE_LIFE;
+ new_spell->status = available;
+ new_spell->name = strdup("sense life");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_SELF_ONLY;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(20 - (2 * self.level)) > 10 ? (20 - (2 * self.level)) : 10");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 18;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = AFF_SENSE_LIFE + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("self.level");
+ new_spell->messages.to_vict = strdup("Your feel your awareness improve.");
+ new_spell->messages.wear_off = strdup("You feel less aware of your surroundings.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_ANIMATE_DEAD # 45
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_ANIMATE_DEAD;
+ new_spell->status = available;
+ new_spell->name = strdup("animate dead");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_OBJ_ROOM;
+ new_spell->mag_flags = MAG_SUMMONS;
+ new_spell->effectiveness = strdup("100");
+ new_spell->summon_mob = strdup("11");
+ sprintf(buf, "(35 - (3 * self.level)) > 10 ? (35 - (3 * self.level)) : 10");
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->messages.to_room = strdup("$N animates a corpse!");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_DISPEL_GOOD # 46
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_DISPEL_GOOD;
+ new_spell->status = available;
+ new_spell->name = strdup("dispel good");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_FIGHT_VICT;
+ new_spell->mag_flags = MAG_DAMAGE | MAG_VIOLENT;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (3 * self.level)) > 25 ? (40 - (3 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 14;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->damages = strdup("dice(6, 8) + 6");
+ new_spell->max_dam = 100;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_GROUP_ARMOR # 47
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_GROUP_ARMOR;
+ new_spell->status = available;
+ new_spell->name = strdup("group armor");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_IGNORE;
+ new_spell->mag_flags = MAG_GROUPS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(50 - (2 * self.level)) > 30 ? (50 - (2 * self.level)) : 30");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 9;
+ new_spell->assign[0].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_GROUP_HEAL # 48
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_GROUP_HEAL;
+ new_spell->status = available;
+ new_spell->name = strdup("group heal");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_IGNORE;
+ new_spell->mag_flags = MAG_GROUPS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(80 - (5 * self.level)) > 60 ? (80 - (5 * self.level)) : 60");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 22;
+ new_spell->assign[0].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_GROUP_RECALL # 49
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_GROUP_RECALL;
+ new_spell->status = available;
+ new_spell->name = strdup("group recall");
+ new_spell->type = SPELL;
+ new_spell->effectiveness = strdup("100");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_INFRAVISION # 50
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_INFRAVISION;
+ new_spell->status = available;
+ new_spell->name = strdup("infravision");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_SELF_ONLY;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ sprintf(buf, "(25 - (1 * self.level)) > 10 ? (25 - (1 * self.level)) : 10");
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 3;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->assign[1].class_num = CLASS_CLERIC;
+ new_spell->assign[1].level = 7;
+ new_spell->assign[1].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = AFF_INFRAVISION + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("12 + param");
+ new_spell->messages.to_vict = strdup("Your eyes glow red.");
+ new_spell->messages.to_room = strdup("$N's eyes glow red.");
+ new_spell->messages.wear_off = strdup("Your night vision seems to fade.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_WATERWALK # 51
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_WATERWALK;
+ new_spell->status = available;
+ new_spell->name = strdup("waterwalk");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (2 * self.level)) > 20 ? (40 - (2 * self.level)) : 20");
+ new_spell->applies[0].appl_num = AFF_WATERWALK + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("24");
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->messages.to_vict = strdup("You feel webbing between your toes.");
+ new_spell->messages.wear_off = strdup("Your feet seem less buoyant.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_IDENTIFY # 52
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_IDENTIFY;
+ new_spell->status = available;
+ new_spell->name = strdup("identify");
+ new_spell->function = spell_identify;
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM;
+ new_spell->mag_flags = MAG_MANUAL;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(50 - (5 * self.level)) > 25 ? (50 - (5 * self.level)) : 25");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 20;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->assign[1].class_num = CLASS_CLERIC;
+ new_spell->assign[1].level = 11;
+ new_spell->assign[1].num_mana = strdup(buf);
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_FLY # 53
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_FLY;
+ new_spell->status = available;
+ new_spell->name = strdup("fly");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_FIGHTING;
+ new_spell->targ_flags = TAR_CHAR_ROOM;
+ new_spell->mag_flags = MAG_AFFECTS | MAG_ACCDUR;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(40 - (2 * self.level)) > 20 ? (40 - (2 * self.level)) : 20");
+ new_spell->assign[0].class_num = CLASS_MAGIC_USER;
+ new_spell->assign[0].level = 22;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->applies[0].appl_num = AFF_FLYING + NUM_APPLIES;
+ new_spell->applies[0].duration = strdup("24");
+ new_spell->messages.to_vict = strdup("You float above the ground.");
+ new_spell->messages.wear_off = strdup("You drift slowly to the ground.");
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_DARKNESS # 54
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_DARKNESS;
+ new_spell->status = available;
+ new_spell->name = strdup("darkness");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_STANDING;
+ new_spell->targ_flags = TAR_IGNORE;
+ new_spell->mag_flags = MAG_ROOMS;
+ new_spell->effectiveness = strdup("100");
+ sprintf(buf, "(30 - (4 * self.level)) > 5 ? (30 - (4 * self.level)) : 5");
+ new_spell->assign[0].class_num = CLASS_CLERIC;
+ new_spell->assign[0].level = 12;
+ new_spell->assign[0].num_mana = strdup(buf);
+ new_spell->messages.to_self = strdup("You cast a shroud of darkness upon the area.");
+ new_spell->messages.to_room = strdup("$N casts a shroud of darkness upon this area.");
+
+ spedit_save_internally(new_spell);
+
+
+ // SKILL_BACKSTAB # 131 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_BACKSTAB;
+ new_spell->status = available;
+ new_spell->name = strdup("backstab");
+ new_spell->function = do_backstab;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_THIEF;
+ new_spell->assign[0].level = 3;
+
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_BASH # 132 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_BASH;
+ new_spell->status = available;
+ new_spell->name = strdup("bash");
+ new_spell->function = do_bash;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_WARRIOR;
+ new_spell->assign[0].level = 12;
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_HIDE # 133 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_HIDE;
+ new_spell->status = available;
+ new_spell->name = strdup("hide");
+ new_spell->function = do_hide;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_THIEF;
+ new_spell->assign[0].level = 5;
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_KICK # 134 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_KICK;
+ new_spell->status = available;
+ new_spell->name = strdup("kick");
+ new_spell->function = do_kick;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_WARRIOR;
+ new_spell->assign[0].level = 1;
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_PICK_LOCK # 135 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_PICK_LOCK;
+ new_spell->status = available;
+ new_spell->name = strdup("pick lock");
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_THIEF;
+ new_spell->assign[0].level = 2;
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_WHIRLWIND # 136 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_WHIRLWIND;
+ new_spell->status = available;
+ new_spell->name = strdup("whirlwind");
+ new_spell->function = do_whirlwind;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_WARRIOR;
+ new_spell->assign[0].level = 16;
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_RESCUE # 137 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_RESCUE;
+ new_spell->status = available;
+ new_spell->name = strdup("rescue");
+ new_spell->function = do_rescue;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_WARRIOR;
+ new_spell->assign[0].level = 3;
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_SNEAK # 138 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_SNEAK;
+ new_spell->status = available;
+ new_spell->name = strdup("sneak");
+ new_spell->function = do_sneak;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_THIEF;
+ new_spell->assign[0].level = 1;
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_STEAL # 139 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_STEAL;
+ new_spell->status = available;
+ new_spell->name = strdup("steal");
+ new_spell->function = do_steal;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_THIEF;
+ new_spell->assign[0].level = 4;
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_TRACK # 140 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_TRACK;
+ new_spell->status = available;
+ new_spell->name = strdup("track");
+ new_spell->function = do_track;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_THIEF;
+ new_spell->assign[0].level = 6;
+ new_spell->assign[1].class_num = CLASS_WARRIOR;
+ new_spell->assign[1].level = 9;
+
+ spedit_save_internally(new_spell);
+
+ // SKILL_BANDAGE # 141 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SKILL_BANDAGE;
+ new_spell->status = available;
+ new_spell->name = strdup("bandage");
+ new_spell->function = do_bandage;
+ new_spell->type = SKILL;
+ new_spell->effectiveness = strdup("100");
+ new_spell->assign[0].class_num = CLASS_WARRIOR;
+ new_spell->assign[0].level = 7;
+
+ spedit_save_internally(new_spell);
+
+ // SPELL_DG_AFFECT # 298 
+ CREATE(new_spell, struct str_spells, 1);
+ spedit_init_new_spell (new_spell);
+
+ new_spell->vnum = SPELL_DG_AFFECT;
+ new_spell->status = available;
+ new_spell->name = strdup("script-inflicted");
+ new_spell->type = SPELL;
+ new_spell->min_pos = POS_SITTING;
+ new_spell->targ_flags = TAR_IGNORE;
+ new_spell->effectiveness = strdup("100");
+
+ spedit_save_internally(new_spell);
+
+ spedit_save_to_disk();
+}
diff -uN ./orig/spells.c ./spells.c
--- ./orig/spells.c	2020-02-25 19:18:51.526369106 -0500
+++ ./spells.c	2020-02-25 19:19:09.949725369 -0500
@@ -22,9 +22,6 @@
 #include "act.h"
 #include "fight.h"
 
-
-
-
 /* Special spells appear below. */
 ASPELL(spell_create_water)
 {
diff -uN ./orig/spells.h ./spells.h
--- ./orig/spells.h	2020-02-25 19:18:51.526369106 -0500
+++ ./spells.h	2020-02-25 19:19:09.949725369 -0500
@@ -12,6 +12,10 @@
 #ifndef _SPELLS_H_
 #define _SPELLS_H_
 
+#define MAGIC_NOEFFECT  (1 << 0)
+#define MAGIC_FAILED    (1 << 1)
+#define MAGIC_SUCCESS   (1 << 2)
+
 #define DEFAULT_STAFF_LVL	12
 #define DEFAULT_WAND_LVL	12
 
@@ -33,7 +37,12 @@
 #define MAG_SUMMONS	(1 << 8)
 #define MAG_CREATIONS	(1 << 9)
 #define MAG_MANUAL	(1 << 10)
-#define MAG_ROOMS   (1 << 11)
+#define MAG_ROOMS	(1 << 11)
+#define MAG_VIOLENT     (1 << 12)
+#define MAG_ACCDUR      (1 << 13)
+#define MAG_ACCMOD      (1 << 14)
+#define MAG_PROTECTION  (1 << 15)
+#define NUM_MAG         16
 
 #define TYPE_UNDEFINED               (-1)
 #define SPELL_RESERVED_DBC            0  /* SKILL NUMBER ZERO -- RESERVED */
@@ -93,8 +102,12 @@
 #define SPELL_IDENTIFY               52 /* Reserved Skill[] DO NOT CHANGE */
 #define SPELL_FLY                    53 /* Reserved Skill[] DO NOT CHANGE */
 #define SPELL_DARKNESS               54
+/* To make an affect induced by dg_affect look correct on 'stat' we need to
+ * define it with a 'spellname'. */
+#define SPELL_DG_AFFECT              55
+
 /** Total Number of defined spells */
-#define NUM_SPELLS                   54
+#define NUM_SPELLS                   55
 
 /* Insert new spells here, up to MAX_SPELLS */
 #define MAX_SPELLS		    130
@@ -112,7 +125,7 @@
 #define SKILL_TRACK                 140 /* Reserved Skill[] DO NOT CHANGE */
 #define SKILL_BANDAGE               141 /* Reserved Skill[] DO NOT CHANGE */
 
-/* New skills may be added here up to MAX_SKILLS (200) */
+/* New skills may be added here up to MAX_SKILLS (297) */
 
 /* NON-PLAYER AND OBJECT SPELLS AND SKILLS: The practice levels for the spells
  * and skills below are _not_ recorded in the players file; therefore, the
@@ -120,10 +133,6 @@
  * SPELL_IDENTIFY used with scrolls of identify) or non-players (such as NPC
  * only spells). */
 
-/* To make an affect induced by dg_affect look correct on 'stat' we need to
- * define it with a 'spellname'. */
-#define SPELL_DG_AFFECT              298
-
 #define TOP_SPELL_DEFINE	     299
 /* NEW NPC/OBJECT SPELLS can be inserted here up to 299 */
 
@@ -140,14 +149,14 @@
 #define TYPE_MAUL       309
 #define TYPE_THRASH     310
 #define TYPE_PIERCE     311
-#define TYPE_BLAST		  312
-#define TYPE_PUNCH		  313
-#define TYPE_STAB		    314
+#define TYPE_BLAST	312
+#define TYPE_PUNCH	313
+#define TYPE_STAB	314
 /** The total number of attack types */
 #define NUM_ATTACK_TYPES  15
 
 /* new attack types can be added here - up to TYPE_SUFFERING */
-#define TYPE_SUFFERING		     399
+#define TYPE_SUFFERING  399
 
 #define SAVING_PARA   0
 #define SAVING_ROD    1
@@ -168,6 +177,8 @@
  **  TAR_OBJ_ROOM  : Object in room.
  **  TAR_OBJ_WORLD : Object in world.
  **  TAR_OBJ_EQUIP : Object held.
+ **  TAR_GROUP     : PC in group.
+ **  TAR_GROUP_VICT: Pc in victim's group.
  ***/
 #define TAR_IGNORE      (1 << 0)
 #define TAR_CHAR_ROOM   (1 << 1)
@@ -179,21 +190,9 @@
 #define TAR_OBJ_INV     (1 << 7)
 #define TAR_OBJ_ROOM    (1 << 8)
 #define TAR_OBJ_WORLD   (1 << 9)
-#define TAR_OBJ_EQUIP	  (1 << 10)
-
-struct spell_info_type {
-   byte min_position;	/* Position for caster	 */
-   int mana_min;	/* Min amount of mana used by a spell (highest lev) */
-   int mana_max;	/* Max amount of mana used by a spell (lowest lev) */
-   int mana_change;	/* Change in mana used by spell from lev to lev */
-
-   int min_level[NUM_CLASSES];
-   int routines;
-   byte violent;
-   int targets;         /* See below for use with TAR_XXX  */
-   const char *name;	/* Input size not limited. Originates from string constants. */
-   const char *wear_off_msg;	/* Input size not limited. Originates from string constants. */
-};
+#define TAR_OBJ_EQUIP	(1 << 10)
+#define TAR_GROUP       (1 << 11)
+#define TAR_GROUP_VICT  (1 << 12)
 
 /* Possible Targets:
    bit 0 : IGNORE TARGET
@@ -231,35 +230,36 @@
 
 /* basic magic calling functions */
 
-int find_skill_num(char *name);
+int mag_protections(int level, struct char_data *ch, struct char_data *tch,
+                    int spellnum, int spellprot, int dur, int res);
 
 int mag_damage(int level, struct char_data *ch, struct char_data *victim,
   int spellnum, int savetype);
 
-void mag_affects(int level, struct char_data *ch, struct char_data *victim,
-  int spellnum, int savetype);
+int mag_affects(int level, struct char_data *ch, struct char_data *victim,
+                int spellnum, int savetype);
 
-void mag_groups(int level, struct char_data *ch, int spellnum, int savetype);
+int mag_groups(int level, struct char_data *ch, int spellnum, int savetype);
 
-void mag_masses(int level, struct char_data *ch, int spellnum, int savetype);
+int mag_masses(int level, struct char_data *ch, int spellnum, int savetype);
 
-void mag_areas(int level, struct char_data *ch, int spellnum, int savetype);
+int mag_areas(int level, struct char_data *ch, int spellnum, int savetype);
 
-void mag_rooms(int level, struct char_data *ch, int spellnum);
+int mag_rooms(int level, struct char_data *ch, int spellnum);
 
-void mag_summons(int level, struct char_data *ch, struct obj_data *obj,
- int spellnum, int savetype);
+int mag_summons(int level, struct char_data *ch, struct obj_data *obj,
+                int spellnum, int savetype);
 
-void mag_points(int level, struct char_data *ch, struct char_data *victim,
- int spellnum, int savetype);
+int mag_points(int level, struct char_data *ch, struct char_data *victim,
+               int spellnum, int savetype);
 
-void mag_unaffects(int level, struct char_data *ch, struct char_data *victim,
-  int spellnum, int type);
+int mag_unaffects(int level, struct char_data *ch, struct char_data *victim,
+                  int spellnum, int type);
 
-void mag_alter_objs(int level, struct char_data *ch, struct obj_data *obj,
-  int spellnum, int type);
+int mag_alter_objs(int level, struct char_data *ch, struct obj_data *obj,
+                   int spellnum, int type);
 
-void mag_creations(int level, struct char_data *ch, int spellnum);
+int mag_creations(int level, struct char_data *ch, int spellnum);
 
 int	call_magic(struct char_data *caster, struct char_data *cvict,
   struct obj_data *ovict, int spellnum, int level, int casttype);
@@ -272,7 +272,6 @@
 
 /* other prototypes */
 void spell_level(int spell, int chclass, int level);
-void init_spell_levels(void);
 const char *skill_name(int num);
 
 /* From magic.c */
@@ -281,12 +280,8 @@
 
 /* from spell_parser.c */
 ACMD(do_cast);
-void unused_spell(int spl);
-void mag_assign_spells(void);
 
 /* Global variables */
-extern struct spell_info_type spell_info[];
 extern char cast_arg2[];
-extern const char *unused_spellname;
 
 #endif /* _SPELLS_H_ */
diff -uN ./orig/spells_script.c ./spells_script.c
--- ./orig/spells_script.c	1969-12-31 19:00:00.000000000 -0500
+++ ./spells_script.c	2020-02-25 19:19:09.953725230 -0500
@@ -0,0 +1,201 @@
+/* Copyright (c) 2018 castillo7@hotmail.com
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE. */
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "utils.h" 
+#include "db.h"
+#include "comm.h"
+#include "handler.h"
+#include "act.h"
+#include "formula.h"
+#include "spells_script.h"
+#include "spells.h"
+#include "string.h"
+
+int call_ASCRIPT (int (*function)(), char *str, struct char_data *self,
+                                                struct char_data *vict,
+                                                struct obj_data  *ovict,
+                                                int    from, 
+                                                int    param) 
+{
+ return ((*function) (str, self, vict, ovict, from, param));
+}  
+
+/* let's declare our scripts functions */
+ASCRIPT (scr_act_to);
+ASCRIPT (scr_teleport);
+ASCRIPT (scr_load_mobile);
+
+struct str_script list_script[] = {
+  {"SAY_TO_ROOM", scr_act_to,      TO_ROOM},
+  {"SAY_TO_SELF", scr_act_to,      TO_CHAR},
+  {"SAY_TO_CHAR", scr_act_to,      TO_CHAR},
+  {"SAY_TO_VICT", scr_act_to,      TO_VICT},
+  {"TELEPORT",    scr_teleport,    0},
+  {"LOAD_MOBILE", scr_load_mobile, 0},
+  {"\n", NULL, 0}
+};
+
+/* this functions is similar to strstr, but will ignore space in str1 and
+   it will move the pointer of str1 */
+char *strlstr (char **str1, char *str2)
+{
+ int cpt = 0;
+ int len = strlen(str2);
+ char *p = *str1;
+
+ if ((!*str1) || (!str2))
+   return NULL;
+
+ do {
+   if (*p == ' ') continue;
+   if ((*p == '\r') || (*p == '\n')) return NULL;
+   if (*p == str2[cpt]) {
+     if (++cpt >= len) {
+       p++;
+       *str1 = p;
+       return p;
+     }
+   }
+   else
+     cpt = 0; 
+ } while (*++p);
+ return NULL;
+}
+
+/* This function extract from *str into the buffer buf, until it found the 
+   character c and it will move the pointer of *str */
+char *strext (char *buf, char **str, char c)
+{
+ int i, len;
+ char *p = *str;
+
+ len = MIN(strlen(*str), MAX_STRING_LENGTH-1);
+
+ if (len <= 0)
+   return NULL;
+
+ for (i=0; i<len; i++) {
+   if ((*p == '\r') || (*p == '\n')) return NULL;
+   if (*p == c)
+     break;
+   else {
+     buf[i] = *p++;
+   }
+ }
+ *str = ++p;
+ buf[i] = '\0';
+ return p;
+}
+
+// SAY_TO_ROOM {"message"};
+// SAY_TO_SELF {"message"};
+// SAY_TO_CHAR {"message"};
+// SAY_TO_VICT {"message"};
+ASCRIPT(scr_act_to)
+{
+ char message[MAX_STRING_LENGTH] = "";
+
+ strlstr (str, "{\"");
+ if (!strext ((char *)&message, str, '\"')) return FALSE;
+ strlstr (str, "};");
+
+ act (message, TRUE, self, NULL, vict, param); 
+ return TRUE;
+}  
+
+// TELEPORT {"where"};
+// where = vnum or mobile name
+ASCRIPT(scr_teleport)
+{
+ int effect = TRUE;
+ char where[MAX_STRING_LENGTH] = "";
+ room_vnum location;
+
+ strlstr (str, "{\"");
+ if (!strext ((char *)&where, str, '\"')) return FALSE;
+ strlstr (str, "};");
+
+ if (((location = find_target_room (vict, where)) != NOWHERE) && vict) {
+   char_from_room (vict);
+   char_to_room (vict, location);
+   if (!IS_NPC (vict))
+     look_at_room (vict, 1);
+ } else
+     effect = FALSE;
+ return (effect);
+}
+
+// LOAD_MOBILE {"mob, where"};
+// mob = mobile r_num
+// where = vnum or mobile name
+ASCRIPT(scr_load_mobile)
+{
+ struct char_data *mob;
+ int value, effect = TRUE, rts_code;
+ char who[MAX_STRING_LENGTH] = "";
+ char where[MAX_STRING_LENGTH] = "";
+
+ room_vnum location;
+ mob_rnum r_num;
+
+ strlstr (str, "{\"");
+ if (!strext ((char *)&who, str, ',')) return FALSE;
+ if (!strext ((char *)&where, str, '\"')) return FALSE;
+ strlstr (str, "};");
+
+ value = formula_interpreter (self, vict, from, TRUE, who, GET_LEVEL(self), &rts_code);
+ if (((r_num = real_mobile (value)) != NOBODY) &&
+     ((location = find_target_room (vict, where)) != NOWHERE)) {
+   mob = read_mobile (r_num, REAL);
+   char_to_room (mob, location);
+ } else
+     effect = FALSE;
+
+ return (effect);
+}
+
+int perform_script (char *str, struct char_data *self, 
+                               struct char_data *vict, 
+                               struct obj_data  *ovict, 
+                    int   from,
+                    int   param)
+{
+ int str_len, fct_len, cpt = 0, ptr = 0, effect = FALSE;
+ char *p, *b;
+
+ p = str;
+ b = (char *) &p;
+
+ if (!vict)
+   vict = self;
+
+ str_len = strlen(p);
+ for (ptr=0; ptr<str_len; ptr++) {
+   cpt = 0;
+   while (list_script[cpt].function) {
+     fct_len = strlen(list_script[cpt].name);
+     if (!(strncmp (list_script[cpt].name, p, fct_len))) {
+       p += fct_len;
+       ptr += fct_len;
+       if (call_ASCRIPT (list_script[cpt].function, b, self, vict, ovict, from, list_script[cpt].param))
+         effect = TRUE;
+       break;
+     }
+     else
+       cpt++;
+   }
+   while (*++p && ((*p == ' ') || (*p == '\r') || (*p == '\n'))) 
+     ptr++;
+ }
+ return effect ? MAGIC_SUCCESS : MAGIC_NOEFFECT;
+}
diff -uN ./orig/spells_script.h ./spells_script.h
--- ./orig/spells_script.h	1969-12-31 19:00:00.000000000 -0500
+++ ./spells_script.h	2020-02-25 19:19:09.953725230 -0500
@@ -0,0 +1,26 @@
+/* Copyright (c) 2018 castillo7@hotmail.com
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE. */
+
+#define ASCRIPT(name) int name(char **str, struct char_data *self, \
+                                           struct char_data *vict, \
+                                           struct obj_data  *ovict, \
+                                           int    from, \
+                                           int    param)
+struct str_script {
+   char *name;
+   void *function;   
+   int  param;
+};
+
+int perform_script (char *str, struct char_data *self,
+                               struct char_data *vict,
+                               struct obj_data  *ovict,
+                    int   from,
+                    int   param);
diff -uN ./orig/structs.h ./structs.h
--- ./orig/structs.h	2020-02-25 19:18:51.526369106 -0500
+++ ./structs.h	2020-02-25 19:21:40.232742590 -0500
@@ -291,8 +291,9 @@
 #define AFF_HIDE           20   /**< Char is hidden */
 #define AFF_FREE           21   /**< Room for future expansion */
 #define AFF_CHARM          22   /**< Char is charmed */
+#define AFF_PROTECT        23   /**< Char protected from spell */
 /** Total number of affect flags */
-#define NUM_AFF_FLAGS   23
+#define NUM_AFF_FLAGS   24
 
 /* Modes of connectedness: used by descriptor_data.state 		*/
 #define CON_PLAYING       0 /**< Playing - Nominal state 		*/
@@ -327,11 +328,12 @@
 #define CON_PREFEDIT     29 /**< OLC mode - preference edit */
 #define CON_IBTEDIT      30 /**< OLC mode - idea/bug/typo edit */
 #define CON_MSGEDIT      31 /**< OLC mode - message editor */
-#define CON_GET_PROTOCOL 32 /**< Used at log-in while attempting to get protocols > */
+#define CON_SPEDIT       32 /**< OLC mode - spell editor	*/
+#define CON_GET_PROTOCOL 33 /**< Used at log-in while attempting to get protocols > */
 
 /* OLC States range - used by IS_IN_OLC and IS_PLAYING */
 #define FIRST_OLC_STATE CON_OEDIT     /**< The first CON_ state that is an OLC */
-#define LAST_OLC_STATE  CON_MSGEDIT   /**< The last CON_ state that is an OLC  */
+#define LAST_OLC_STATE  CON_SPEDIT   /**< The last CON_ state that is an OLC  */
 
 /* Character equipment positions: used as index for char_data.equipment[] */
 /* NOTE: Don't confuse these constants with the ITEM_ bitvectors
@@ -601,7 +603,7 @@
 #define MAX_TITLE_LENGTH      80     /**< Max PC title length */
 #define HOST_LENGTH           40     /**< Max hostname resolution length */
 #define PLR_DESC_LENGTH       4096   /**< Max length for PC description */
-#define MAX_SKILLS            200    /**< Max number of skills/spells */
+#define MAX_SKILLS            297    /**< Max number of skills/spells */
 #define MAX_AFFECT            32     /**< Max number of player affections */
 #define MAX_OBJ_AFFECT        6      /**< Max object affects */
 #define MAX_NOTE_LENGTH       4000   /**< Max length of text on a note obj */
@@ -996,7 +998,7 @@
   sh_int spell; /**< The spell that caused this */
   sh_int duration; /**< For how long its effects will last      */
   sbyte modifier;  /**< Added/subtracted to/from apropriate ability     */
-  byte location;   /**< Tells which ability to change(APPLY_XXX). */
+  sh_int location;   /**< Tells which ability to change(APPLY_XXX). */
   int bitvector[AF_ARRAY_MAX]; /**< Tells which bits to set (AFF_XXX). */
 
   struct affected_type *next; /**< The next affect in the list of affects. */
@@ -1050,6 +1052,7 @@
   long pref; /**< unique session id */
   
   struct list_data * events;
+  struct str_plrspells *plrspells; 
 };
 
 /** descriptor-related structures */
Common subdirectories: ./orig/util and ./util
diff -uN ./orig/utils.c ./utils.c
--- ./orig/utils.c	2020-02-25 19:18:51.526369106 -0500
+++ ./utils.c	2020-02-25 19:19:09.953725230 -0500
@@ -1489,3 +1489,24 @@
   parse_tab(buf);
   return(buf);
 }
+
+// strcasestr is not standard C89/C99
+// https://stackoverflow.com/questions/27303062/strstr-function-like-that-ignores-upper-or-lower-case
+//
+// There is more efficient version at the link above. 
+// This version is the easiest to understand from the link.
+char *stristr3(const char* haystack, const char* needle) {
+  do {
+    const char* h = haystack;
+    const char* n = needle;
+    while (tolower((unsigned char) *h) == tolower((unsigned char ) *n) && *n) {
+      h++;
+      n++;
+    }
+    if (*n == 0) {
+      return (char *) haystack;
+    }
+  } while (*haystack++);
+  return 0;
+}
+
diff -uN ./orig/utils.h ./utils.h
--- ./orig/utils.h	2020-02-25 19:18:51.526369106 -0500
+++ ./utils.h	2020-02-25 19:19:09.953725230 -0500
@@ -70,6 +70,7 @@
 int get_class_by_name(char *classname);
 char * convert_from_tabs(char * string);
 int count_non_protocol_chars(char * str);
+char *stristr3(const char* haystack, const char* needle);
 
 /* Public functions made available form weather.c */
 void weather_and_time(int mode);
@@ -160,8 +161,9 @@
 #define ETEXT_FILE       1 /**< ???? */
 #define SCRIPT_VARS_FILE 2 /**< Reference to a global variable file. */
 #define PLR_FILE         3 /**< The standard player file */
+#define PLR_SPELLS_FILE  4 /**< The players spells file */
 
-#define MAX_FILES        4 /**< Max number of files types vailable */
+#define MAX_FILES        5 /**< Max number of files types vailable */
 
 /* breadth-first searching for graph function (tracking, etc) */
 #define BFS_ERROR		(-1)       /**< Error in the search. */
@@ -417,9 +419,6 @@
 /** 1 if flag is set in the extra bits of obj, 0 if not. */
 #define OBJ_FLAGGED(obj, flag) (IS_SET_AR(GET_OBJ_EXTRA(obj), (flag)))
 
-/** 1 if spl has a flag set in routines, 0 if not. */
-#define HAS_SPELL_ROUTINE(spl, flag) (IS_SET(SPELL_ROUTINES(spl), (flag)))
-
 /** IS_AFFECTED for backwards compatibility */
 #define IS_AFFECTED(ch, skill) (AFF_FLAGGED((ch), (skill)))
 
